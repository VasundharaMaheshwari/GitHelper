{"version":3,"sources":["../../src/generated/types/accountState.ts","../../src/generated/types/authorityType.ts","../../src/generated/types/decryptableBalance.ts","../../src/generated/types/encryptedBalance.ts","../../src/generated/types/extension.ts","../../src/generated/types/extensionType.ts","../../src/generated/types/tokenMetadataField.ts","../../src/generated/types/transferFee.ts","../../src/generated/accounts/mint.ts","../../src/generated/accounts/multisig.ts","../../src/generated/accounts/token.ts","../../src/generated/programs/associatedToken.ts","../../src/generated/programs/token2022.ts","../../src/generated/errors/associatedToken.ts","../../src/generated/errors/token2022.ts","../../src/generated/shared/index.ts","../../src/generated/instructions/amountToUiAmount.ts","../../src/generated/instructions/applyConfidentialPendingBalance.ts","../../src/generated/instructions/approve.ts","../../src/generated/instructions/approveChecked.ts","../../src/generated/instructions/approveConfidentialTransferAccount.ts","../../src/generated/instructions/burn.ts","../../src/generated/instructions/burnChecked.ts","../../src/generated/instructions/closeAccount.ts","../../src/generated/instructions/confidentialDeposit.ts","../../src/generated/instructions/confidentialTransfer.ts","../../src/generated/instructions/confidentialTransferWithFee.ts","../../src/generated/instructions/confidentialWithdraw.ts","../../src/generated/instructions/configureConfidentialTransferAccount.ts","../../src/generated/pdas/associatedToken.ts","../../src/generated/instructions/createAssociatedToken.ts","../../src/generated/instructions/createAssociatedTokenIdempotent.ts","../../src/generated/instructions/createNativeMint.ts","../../src/generated/instructions/disableConfidentialCredits.ts","../../src/generated/instructions/disableCpiGuard.ts","../../src/generated/instructions/disableHarvestToMint.ts","../../src/generated/instructions/disableMemoTransfers.ts","../../src/generated/instructions/disableNonConfidentialCredits.ts","../../src/generated/instructions/emitTokenMetadata.ts","../../src/generated/instructions/emptyConfidentialTransferAccount.ts","../../src/generated/instructions/enableConfidentialCredits.ts","../../src/generated/instructions/enableCpiGuard.ts","../../src/generated/instructions/enableHarvestToMint.ts","../../src/generated/instructions/enableMemoTransfers.ts","../../src/generated/instructions/enableNonConfidentialCredits.ts","../../src/generated/instructions/freezeAccount.ts","../../src/generated/instructions/getAccountDataSize.ts","../../src/generated/instructions/harvestWithheldTokensToMint.ts","../../src/generated/instructions/harvestWithheldTokensToMintForConfidentialTransferFee.ts","../../src/generated/instructions/initializeAccount.ts","../../src/generated/instructions/initializeAccount2.ts","../../src/generated/instructions/initializeAccount3.ts","../../src/generated/instructions/initializeConfidentialTransferFee.ts","../../src/generated/instructions/initializeConfidentialTransferMint.ts","../../src/generated/instructions/initializeDefaultAccountState.ts","../../src/generated/instructions/initializeGroupMemberPointer.ts","../../src/generated/instructions/initializeGroupPointer.ts","../../src/generated/instructions/initializeImmutableOwner.ts","../../src/generated/instructions/initializeInterestBearingMint.ts","../../src/generated/instructions/initializeMetadataPointer.ts","../../src/generated/instructions/initializeMint.ts","../../src/generated/instructions/initializeMint2.ts","../../src/generated/instructions/initializeMintCloseAuthority.ts","../../src/generated/instructions/initializeMultisig.ts","../../src/generated/instructions/initializeMultisig2.ts","../../src/generated/instructions/initializeNonTransferableMint.ts","../../src/generated/instructions/initializePermanentDelegate.ts","../../src/generated/instructions/initializeTokenGroup.ts","../../src/generated/instructions/initializeTokenGroupMember.ts","../../src/generated/instructions/initializeTokenMetadata.ts","../../src/generated/instructions/initializeTransferFeeConfig.ts","../../src/generated/instructions/initializeTransferHook.ts","../../src/generated/instructions/mintTo.ts","../../src/generated/instructions/mintToChecked.ts","../../src/generated/instructions/reallocate.ts","../../src/generated/instructions/recoverNestedAssociatedToken.ts","../../src/generated/instructions/removeTokenMetadataKey.ts","../../src/generated/instructions/revoke.ts","../../src/generated/instructions/setAuthority.ts","../../src/generated/instructions/setTransferFee.ts","../../src/generated/instructions/syncNative.ts","../../src/generated/instructions/thawAccount.ts","../../src/generated/instructions/transfer.ts","../../src/generated/instructions/transferChecked.ts","../../src/generated/instructions/transferCheckedWithFee.ts","../../src/generated/instructions/uiAmountToAmount.ts","../../src/generated/instructions/updateConfidentialTransferMint.ts","../../src/generated/instructions/updateDefaultAccountState.ts","../../src/generated/instructions/updateGroupMemberPointer.ts","../../src/generated/instructions/updateGroupPointer.ts","../../src/generated/instructions/updateMetadataPointer.ts","../../src/generated/instructions/updateRateInterestBearingMint.ts","../../src/generated/instructions/updateTokenGroupMaxSize.ts","../../src/generated/instructions/updateTokenGroupUpdateAuthority.ts","../../src/generated/instructions/updateTokenMetadataField.ts","../../src/generated/instructions/updateTokenMetadataUpdateAuthority.ts","../../src/generated/instructions/updateTransferHook.ts","../../src/generated/instructions/withdrawExcessLamports.ts","../../src/generated/instructions/withdrawWithheldTokensFromAccounts.ts","../../src/generated/instructions/withdrawWithheldTokensFromAccountsForConfidentialTransferFee.ts","../../src/generated/instructions/withdrawWithheldTokensFromMint.ts","../../src/generated/instructions/withdrawWithheldTokensFromMintForConfidentialTransferFee.ts","../../src/amountToUiAmount.ts","../../src/getInitializeInstructionsForExtensions.ts","../../src/getTokenSize.ts","../../src/getMintSize.ts"],"names":["AccountState","getEnumEncoder","getEnumDecoder","combineCodec","AuthorityType","fixEncoderSize","getBytesEncoder","fixDecoderSize","getBytesDecoder","getDiscriminatedUnionEncoder","getUnitEncoder","addEncoderSizePrefix","getStructEncoder","getAddressEncoder","getU64Encoder","getU16Encoder","getOptionEncoder","getBooleanEncoder","getI16Encoder","getUtf8Encoder","getU32Encoder","getMapEncoder","getDiscriminatedUnionDecoder","getUnitDecoder","addDecoderSizePrefix","getStructDecoder","getAddressDecoder","getU64Decoder","getU16Decoder","getOptionDecoder","getBooleanDecoder","getI16Decoder","getUtf8Decoder","getU32Decoder","getMapDecoder","ExtensionType","getTupleEncoder","getTupleDecoder","getU8Encoder","getHiddenPrefixEncoder","getArrayEncoder","getConstantEncoder","padLeftEncoder","getU8Decoder","getHiddenPrefixDecoder","getArrayDecoder","getConstantDecoder","decodeAccount","assertAccountExists","fetchEncodedAccount","assertAccountsExist","fetchEncodedAccounts","AssociatedTokenInstruction","containsBytes","Token2022Account","Token2022Instruction","isProgramError","AccountRole","upgradeRoleToSigner","kitIsTransactionSigner","transformEncoder","getI8Encoder","getI8Decoder","getProgramDerivedAddress","none","fetchSysvarClock","unwrapOption","extension","isOption","wrapNullable","isNone"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\nexport enum AccountState {\n  Uninitialized,\n  Initialized,\n  Frozen,\n}\n\nexport type AccountStateArgs = AccountState;\n\nexport function getAccountStateEncoder(): Encoder<AccountStateArgs> {\n  return getEnumEncoder(AccountState);\n}\n\nexport function getAccountStateDecoder(): Decoder<AccountState> {\n  return getEnumDecoder(AccountState);\n}\n\nexport function getAccountStateCodec(): Codec<AccountStateArgs, AccountState> {\n  return combineCodec(getAccountStateEncoder(), getAccountStateDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\nexport enum AuthorityType {\n  MintTokens,\n  FreezeAccount,\n  AccountOwner,\n  CloseAccount,\n}\n\nexport type AuthorityTypeArgs = AuthorityType;\n\nexport function getAuthorityTypeEncoder(): Encoder<AuthorityTypeArgs> {\n  return getEnumEncoder(AuthorityType);\n}\n\nexport function getAuthorityTypeDecoder(): Decoder<AuthorityType> {\n  return getEnumDecoder(AuthorityType);\n}\n\nexport function getAuthorityTypeCodec(): Codec<\n  AuthorityTypeArgs,\n  AuthorityType\n> {\n  return combineCodec(getAuthorityTypeEncoder(), getAuthorityTypeDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\n\n/** Authenticated encryption containing an account balance. */\nexport type DecryptableBalance = ReadonlyUint8Array;\n\nexport type DecryptableBalanceArgs = DecryptableBalance;\n\nexport function getDecryptableBalanceEncoder(): Encoder<DecryptableBalanceArgs> {\n  return fixEncoderSize(getBytesEncoder(), 36);\n}\n\nexport function getDecryptableBalanceDecoder(): Decoder<DecryptableBalance> {\n  return fixDecoderSize(getBytesDecoder(), 36);\n}\n\nexport function getDecryptableBalanceCodec(): Codec<\n  DecryptableBalanceArgs,\n  DecryptableBalance\n> {\n  return combineCodec(\n    getDecryptableBalanceEncoder(),\n    getDecryptableBalanceDecoder()\n  );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\n\n/** ElGamal ciphertext containing an account balance. */\nexport type EncryptedBalance = ReadonlyUint8Array;\n\nexport type EncryptedBalanceArgs = EncryptedBalance;\n\nexport function getEncryptedBalanceEncoder(): Encoder<EncryptedBalanceArgs> {\n  return fixEncoderSize(getBytesEncoder(), 64);\n}\n\nexport function getEncryptedBalanceDecoder(): Decoder<EncryptedBalance> {\n  return fixDecoderSize(getBytesDecoder(), 64);\n}\n\nexport function getEncryptedBalanceCodec(): Codec<\n  EncryptedBalanceArgs,\n  EncryptedBalance\n> {\n  return combineCodec(\n    getEncryptedBalanceEncoder(),\n    getEncryptedBalanceDecoder()\n  );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getDiscriminatedUnionDecoder,\n  getDiscriminatedUnionEncoder,\n  getI16Decoder,\n  getI16Encoder,\n  getMapDecoder,\n  getMapEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getUnitDecoder,\n  getUnitEncoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type GetDiscriminatedUnionVariant,\n  type GetDiscriminatedUnionVariantContent,\n  type Option,\n  type OptionOrNullable,\n} from '@solana/kit';\nimport {\n  getAccountStateDecoder,\n  getAccountStateEncoder,\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  getEncryptedBalanceDecoder,\n  getEncryptedBalanceEncoder,\n  getTransferFeeDecoder,\n  getTransferFeeEncoder,\n  type AccountState,\n  type AccountStateArgs,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n  type EncryptedBalance,\n  type EncryptedBalanceArgs,\n  type TransferFee,\n  type TransferFeeArgs,\n} from '.';\n\nexport type Extension =\n  | { __kind: 'Uninitialized' }\n  | {\n      __kind: 'TransferFeeConfig';\n      /** Optional authority to set the fee. */\n      transferFeeConfigAuthority: Address;\n      /** Withdraw from mint instructions must be signed by this key. */\n      withdrawWithheldAuthority: Address;\n      /** Withheld transfer fee tokens that have been moved to the mint for withdrawal. */\n      withheldAmount: bigint;\n      /** Older transfer fee, used if the current epoch < newerTransferFee.epoch. */\n      olderTransferFee: TransferFee;\n      /** Newer transfer fee, used if the current epoch >= newerTransferFee.epoch. */\n      newerTransferFee: TransferFee;\n    }\n  | {\n      __kind: 'TransferFeeAmount';\n      /** Withheld transfer fee tokens that can be claimed by the fee authority. */\n      withheldAmount: bigint;\n    }\n  | { __kind: 'MintCloseAuthority'; closeAuthority: Address }\n  | {\n      __kind: 'ConfidentialTransferMint';\n      /**\n       * Authority to modify the `ConfidentialTransferMint` configuration and to\n       * approve new accounts (if `auto_approve_new_accounts` is true).\n       *\n       * The legacy Token Multisig account is not supported as the authority.\n       */\n      authority: Option<Address>;\n      /**\n       * Indicate if newly configured accounts must be approved by the\n       * `authority` before they may be used by the user.\n       *\n       * * If `true`, no approval is required and new accounts may be used immediately.\n       * * If `false`, the authority must approve newly configured accounts (see\n       *   `ConfidentialTransferInstruction::ConfigureAccount`).\n       */\n      autoApproveNewAccounts: boolean;\n      /** Authority to decode any transfer amount in a confidential transfer. */\n      auditorElgamalPubkey: Option<Address>;\n    }\n  | {\n      __kind: 'ConfidentialTransferAccount';\n      /**\n       * `true` if this account has been approved for use. All confidential\n       * transfer operations for the account will fail until approval is granted.\n       */\n      approved: boolean;\n      /** The public key associated with ElGamal encryption. */\n      elgamalPubkey: Address;\n      /** The low 16 bits of the pending balance (encrypted by `elgamal_pubkey`). */\n      pendingBalanceLow: EncryptedBalance;\n      /** The high 48 bits of the pending balance (encrypted by `elgamal_pubkey`). */\n      pendingBalanceHigh: EncryptedBalance;\n      /** The available balance (encrypted by `encrypiton_pubkey`). */\n      availableBalance: EncryptedBalance;\n      /** The decryptable available balance. */\n      decryptableAvailableBalance: DecryptableBalance;\n      /** If `false`, the extended account rejects any incoming confidential transfers. */\n      allowConfidentialCredits: boolean;\n      /** If `false`, the base account rejects any incoming transfers. */\n      allowNonConfidentialCredits: boolean;\n      /** The total number of `Deposit` and `Transfer` instructions that have credited `pending_balance`. */\n      pendingBalanceCreditCounter: bigint;\n      /**\n       * The maximum number of `Deposit` and `Transfer` instructions that can\n       * credit `pending_balance` before the `ApplyPendingBalance`\n       * instruction is executed.\n       */\n      maximumPendingBalanceCreditCounter: bigint;\n      /**\n       * The `expected_pending_balance_credit_counter` value that was included in\n       * the last `ApplyPendingBalance` instruction.\n       */\n      expectedPendingBalanceCreditCounter: bigint;\n      /**\n       * The actual `pending_balance_credit_counter` when the last\n       * `ApplyPendingBalance` instruction was executed.\n       */\n      actualPendingBalanceCreditCounter: bigint;\n    }\n  | { __kind: 'DefaultAccountState'; state: AccountState }\n  | { __kind: 'ImmutableOwner' }\n  | {\n      __kind: 'MemoTransfer';\n      /** Require transfers into this account to be accompanied by a memo. */\n      requireIncomingTransferMemos: boolean;\n    }\n  | { __kind: 'NonTransferable' }\n  | {\n      __kind: 'InterestBearingConfig';\n      rateAuthority: Address;\n      initializationTimestamp: bigint;\n      preUpdateAverageRate: number;\n      lastUpdateTimestamp: bigint;\n      currentRate: number;\n    }\n  | {\n      __kind: 'CpiGuard';\n      /** Lock certain token operations from taking place within CPI for this account. */\n      lockCpi: boolean;\n    }\n  | { __kind: 'PermanentDelegate'; delegate: Address }\n  | { __kind: 'NonTransferableAccount' }\n  | {\n      __kind: 'TransferHook';\n      /** The transfer hook update authority. */\n      authority: Address;\n      /** The transfer hook program account. */\n      programId: Address;\n    }\n  | {\n      __kind: 'TransferHookAccount';\n      /**\n       * Whether or not this account is currently transferring tokens\n       * True during the transfer hook cpi, otherwise false.\n       */\n      transferring: boolean;\n    }\n  | {\n      __kind: 'ConfidentialTransferFee';\n      /** Optional authority to set the withdraw withheld authority ElGamal key. */\n      authority: Option<Address>;\n      /**\n       * Withheld fees from accounts must be encrypted with this ElGamal key.\n       *\n       * Note that whoever holds the ElGamal private key for this ElGamal public\n       * key has the ability to decode any withheld fee amount that are\n       * associated with accounts. When combined with the fee parameters, the\n       * withheld fee amounts can reveal information about transfer amounts.\n       */\n      elgamalPubkey: Address;\n      /** If `false`, the harvest of withheld tokens to mint is rejected. */\n      harvestToMintEnabled: boolean;\n      /**\n       * Withheld confidential transfer fee tokens that have been moved to the\n       * mint for withdrawal.\n       */\n      withheldAmount: EncryptedBalance;\n    }\n  | {\n      __kind: 'ConfidentialTransferFeeAmount';\n      /** Amount withheld during confidential transfers, to be harvest to the mint. */\n      withheldAmount: EncryptedBalance;\n    }\n  | {\n      __kind: 'MetadataPointer';\n      /** Optional authority that can set the metadata address. */\n      authority: Option<Address>;\n      /** Optional Account Address that holds the metadata. */\n      metadataAddress: Option<Address>;\n    }\n  | {\n      __kind: 'TokenMetadata';\n      /** The authority that can sign to update the metadata. */\n      updateAuthority: Option<Address>;\n      /** The associated mint, used to counter spoofing to be sure that metadata belongs to a particular mint. */\n      mint: Address;\n      /** The longer name of the token. */\n      name: string;\n      /** The shortened symbol for the token. */\n      symbol: string;\n      /** The URI pointing to richer metadata. */\n      uri: string;\n      /** Any additional metadata about the token as key-value pairs. */\n      additionalMetadata: Map<string, string>;\n    }\n  | {\n      __kind: 'GroupPointer';\n      /** Optional authority that can set the group address. */\n      authority: Option<Address>;\n      /** Optional account address that holds the group. */\n      groupAddress: Option<Address>;\n    }\n  | {\n      __kind: 'TokenGroup';\n      /** The authority that can sign to update the group. */\n      updateAuthority: Option<Address>;\n      /** The associated mint, used to counter spoofing to be sure that group belongs to a particular mint. */\n      mint: Address;\n      /** The current number of group members. */\n      size: bigint;\n      /** The maximum number of group members. */\n      maxSize: bigint;\n    }\n  | {\n      __kind: 'GroupMemberPointer';\n      /** Optional authority that can set the member address. */\n      authority: Option<Address>;\n      /** Optional account address that holds the member. */\n      memberAddress: Option<Address>;\n    }\n  | {\n      __kind: 'TokenGroupMember';\n      /** The associated mint, used to counter spoofing to be sure that member belongs to a particular mint. */\n      mint: Address;\n      /** The pubkey of the `TokenGroup`. */\n      group: Address;\n      /** The member number. */\n      memberNumber: bigint;\n    };\n\nexport type ExtensionArgs =\n  | { __kind: 'Uninitialized' }\n  | {\n      __kind: 'TransferFeeConfig';\n      /** Optional authority to set the fee. */\n      transferFeeConfigAuthority: Address;\n      /** Withdraw from mint instructions must be signed by this key. */\n      withdrawWithheldAuthority: Address;\n      /** Withheld transfer fee tokens that have been moved to the mint for withdrawal. */\n      withheldAmount: number | bigint;\n      /** Older transfer fee, used if the current epoch < newerTransferFee.epoch. */\n      olderTransferFee: TransferFeeArgs;\n      /** Newer transfer fee, used if the current epoch >= newerTransferFee.epoch. */\n      newerTransferFee: TransferFeeArgs;\n    }\n  | {\n      __kind: 'TransferFeeAmount';\n      /** Withheld transfer fee tokens that can be claimed by the fee authority. */\n      withheldAmount: number | bigint;\n    }\n  | { __kind: 'MintCloseAuthority'; closeAuthority: Address }\n  | {\n      __kind: 'ConfidentialTransferMint';\n      /**\n       * Authority to modify the `ConfidentialTransferMint` configuration and to\n       * approve new accounts (if `auto_approve_new_accounts` is true).\n       *\n       * The legacy Token Multisig account is not supported as the authority.\n       */\n      authority: OptionOrNullable<Address>;\n      /**\n       * Indicate if newly configured accounts must be approved by the\n       * `authority` before they may be used by the user.\n       *\n       * * If `true`, no approval is required and new accounts may be used immediately.\n       * * If `false`, the authority must approve newly configured accounts (see\n       *   `ConfidentialTransferInstruction::ConfigureAccount`).\n       */\n      autoApproveNewAccounts: boolean;\n      /** Authority to decode any transfer amount in a confidential transfer. */\n      auditorElgamalPubkey: OptionOrNullable<Address>;\n    }\n  | {\n      __kind: 'ConfidentialTransferAccount';\n      /**\n       * `true` if this account has been approved for use. All confidential\n       * transfer operations for the account will fail until approval is granted.\n       */\n      approved: boolean;\n      /** The public key associated with ElGamal encryption. */\n      elgamalPubkey: Address;\n      /** The low 16 bits of the pending balance (encrypted by `elgamal_pubkey`). */\n      pendingBalanceLow: EncryptedBalanceArgs;\n      /** The high 48 bits of the pending balance (encrypted by `elgamal_pubkey`). */\n      pendingBalanceHigh: EncryptedBalanceArgs;\n      /** The available balance (encrypted by `encrypiton_pubkey`). */\n      availableBalance: EncryptedBalanceArgs;\n      /** The decryptable available balance. */\n      decryptableAvailableBalance: DecryptableBalanceArgs;\n      /** If `false`, the extended account rejects any incoming confidential transfers. */\n      allowConfidentialCredits: boolean;\n      /** If `false`, the base account rejects any incoming transfers. */\n      allowNonConfidentialCredits: boolean;\n      /** The total number of `Deposit` and `Transfer` instructions that have credited `pending_balance`. */\n      pendingBalanceCreditCounter: number | bigint;\n      /**\n       * The maximum number of `Deposit` and `Transfer` instructions that can\n       * credit `pending_balance` before the `ApplyPendingBalance`\n       * instruction is executed.\n       */\n      maximumPendingBalanceCreditCounter: number | bigint;\n      /**\n       * The `expected_pending_balance_credit_counter` value that was included in\n       * the last `ApplyPendingBalance` instruction.\n       */\n      expectedPendingBalanceCreditCounter: number | bigint;\n      /**\n       * The actual `pending_balance_credit_counter` when the last\n       * `ApplyPendingBalance` instruction was executed.\n       */\n      actualPendingBalanceCreditCounter: number | bigint;\n    }\n  | { __kind: 'DefaultAccountState'; state: AccountStateArgs }\n  | { __kind: 'ImmutableOwner' }\n  | {\n      __kind: 'MemoTransfer';\n      /** Require transfers into this account to be accompanied by a memo. */\n      requireIncomingTransferMemos: boolean;\n    }\n  | { __kind: 'NonTransferable' }\n  | {\n      __kind: 'InterestBearingConfig';\n      rateAuthority: Address;\n      initializationTimestamp: number | bigint;\n      preUpdateAverageRate: number;\n      lastUpdateTimestamp: number | bigint;\n      currentRate: number;\n    }\n  | {\n      __kind: 'CpiGuard';\n      /** Lock certain token operations from taking place within CPI for this account. */\n      lockCpi: boolean;\n    }\n  | { __kind: 'PermanentDelegate'; delegate: Address }\n  | { __kind: 'NonTransferableAccount' }\n  | {\n      __kind: 'TransferHook';\n      /** The transfer hook update authority. */\n      authority: Address;\n      /** The transfer hook program account. */\n      programId: Address;\n    }\n  | {\n      __kind: 'TransferHookAccount';\n      /**\n       * Whether or not this account is currently transferring tokens\n       * True during the transfer hook cpi, otherwise false.\n       */\n      transferring: boolean;\n    }\n  | {\n      __kind: 'ConfidentialTransferFee';\n      /** Optional authority to set the withdraw withheld authority ElGamal key. */\n      authority: OptionOrNullable<Address>;\n      /**\n       * Withheld fees from accounts must be encrypted with this ElGamal key.\n       *\n       * Note that whoever holds the ElGamal private key for this ElGamal public\n       * key has the ability to decode any withheld fee amount that are\n       * associated with accounts. When combined with the fee parameters, the\n       * withheld fee amounts can reveal information about transfer amounts.\n       */\n      elgamalPubkey: Address;\n      /** If `false`, the harvest of withheld tokens to mint is rejected. */\n      harvestToMintEnabled: boolean;\n      /**\n       * Withheld confidential transfer fee tokens that have been moved to the\n       * mint for withdrawal.\n       */\n      withheldAmount: EncryptedBalanceArgs;\n    }\n  | {\n      __kind: 'ConfidentialTransferFeeAmount';\n      /** Amount withheld during confidential transfers, to be harvest to the mint. */\n      withheldAmount: EncryptedBalanceArgs;\n    }\n  | {\n      __kind: 'MetadataPointer';\n      /** Optional authority that can set the metadata address. */\n      authority: OptionOrNullable<Address>;\n      /** Optional Account Address that holds the metadata. */\n      metadataAddress: OptionOrNullable<Address>;\n    }\n  | {\n      __kind: 'TokenMetadata';\n      /** The authority that can sign to update the metadata. */\n      updateAuthority: OptionOrNullable<Address>;\n      /** The associated mint, used to counter spoofing to be sure that metadata belongs to a particular mint. */\n      mint: Address;\n      /** The longer name of the token. */\n      name: string;\n      /** The shortened symbol for the token. */\n      symbol: string;\n      /** The URI pointing to richer metadata. */\n      uri: string;\n      /** Any additional metadata about the token as key-value pairs. */\n      additionalMetadata: Map<string, string>;\n    }\n  | {\n      __kind: 'GroupPointer';\n      /** Optional authority that can set the group address. */\n      authority: OptionOrNullable<Address>;\n      /** Optional account address that holds the group. */\n      groupAddress: OptionOrNullable<Address>;\n    }\n  | {\n      __kind: 'TokenGroup';\n      /** The authority that can sign to update the group. */\n      updateAuthority: OptionOrNullable<Address>;\n      /** The associated mint, used to counter spoofing to be sure that group belongs to a particular mint. */\n      mint: Address;\n      /** The current number of group members. */\n      size: number | bigint;\n      /** The maximum number of group members. */\n      maxSize: number | bigint;\n    }\n  | {\n      __kind: 'GroupMemberPointer';\n      /** Optional authority that can set the member address. */\n      authority: OptionOrNullable<Address>;\n      /** Optional account address that holds the member. */\n      memberAddress: OptionOrNullable<Address>;\n    }\n  | {\n      __kind: 'TokenGroupMember';\n      /** The associated mint, used to counter spoofing to be sure that member belongs to a particular mint. */\n      mint: Address;\n      /** The pubkey of the `TokenGroup`. */\n      group: Address;\n      /** The member number. */\n      memberNumber: number | bigint;\n    };\n\nexport function getExtensionEncoder(): Encoder<ExtensionArgs> {\n  return getDiscriminatedUnionEncoder(\n    [\n      ['Uninitialized', getUnitEncoder()],\n      [\n        'TransferFeeConfig',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['transferFeeConfigAuthority', getAddressEncoder()],\n            ['withdrawWithheldAuthority', getAddressEncoder()],\n            ['withheldAmount', getU64Encoder()],\n            ['olderTransferFee', getTransferFeeEncoder()],\n            ['newerTransferFee', getTransferFeeEncoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'TransferFeeAmount',\n        addEncoderSizePrefix(\n          getStructEncoder([['withheldAmount', getU64Encoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'MintCloseAuthority',\n        addEncoderSizePrefix(\n          getStructEncoder([['closeAuthority', getAddressEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferMint',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['autoApproveNewAccounts', getBooleanEncoder()],\n            [\n              'auditorElgamalPubkey',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferAccount',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['approved', getBooleanEncoder()],\n            ['elgamalPubkey', getAddressEncoder()],\n            ['pendingBalanceLow', getEncryptedBalanceEncoder()],\n            ['pendingBalanceHigh', getEncryptedBalanceEncoder()],\n            ['availableBalance', getEncryptedBalanceEncoder()],\n            ['decryptableAvailableBalance', getDecryptableBalanceEncoder()],\n            ['allowConfidentialCredits', getBooleanEncoder()],\n            ['allowNonConfidentialCredits', getBooleanEncoder()],\n            ['pendingBalanceCreditCounter', getU64Encoder()],\n            ['maximumPendingBalanceCreditCounter', getU64Encoder()],\n            ['expectedPendingBalanceCreditCounter', getU64Encoder()],\n            ['actualPendingBalanceCreditCounter', getU64Encoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'DefaultAccountState',\n        addEncoderSizePrefix(\n          getStructEncoder([['state', getAccountStateEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'ImmutableOwner',\n        addEncoderSizePrefix(getStructEncoder([]), getU16Encoder()),\n      ],\n      [\n        'MemoTransfer',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['requireIncomingTransferMemos', getBooleanEncoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'NonTransferable',\n        addEncoderSizePrefix(getStructEncoder([]), getU16Encoder()),\n      ],\n      [\n        'InterestBearingConfig',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['rateAuthority', getAddressEncoder()],\n            ['initializationTimestamp', getU64Encoder()],\n            ['preUpdateAverageRate', getI16Encoder()],\n            ['lastUpdateTimestamp', getU64Encoder()],\n            ['currentRate', getI16Encoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'CpiGuard',\n        addEncoderSizePrefix(\n          getStructEncoder([['lockCpi', getBooleanEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'PermanentDelegate',\n        addEncoderSizePrefix(\n          getStructEncoder([['delegate', getAddressEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'NonTransferableAccount',\n        addEncoderSizePrefix(getStructEncoder([]), getU16Encoder()),\n      ],\n      [\n        'TransferHook',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['authority', getAddressEncoder()],\n            ['programId', getAddressEncoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'TransferHookAccount',\n        addEncoderSizePrefix(\n          getStructEncoder([['transferring', getBooleanEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferFee',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['elgamalPubkey', getAddressEncoder()],\n            ['harvestToMintEnabled', getBooleanEncoder()],\n            ['withheldAmount', getEncryptedBalanceEncoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferFeeAmount',\n        addEncoderSizePrefix(\n          getStructEncoder([['withheldAmount', getEncryptedBalanceEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'MetadataPointer',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'metadataAddress',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'TokenMetadata',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'updateAuthority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['mint', getAddressEncoder()],\n            ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n            ['symbol', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n            ['uri', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n            [\n              'additionalMetadata',\n              getMapEncoder(\n                addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),\n                addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())\n              ),\n            ],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'GroupPointer',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'groupAddress',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'TokenGroup',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'updateAuthority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['mint', getAddressEncoder()],\n            ['size', getU64Encoder()],\n            ['maxSize', getU64Encoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'GroupMemberPointer',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'memberAddress',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'TokenGroupMember',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['mint', getAddressEncoder()],\n            ['group', getAddressEncoder()],\n            ['memberNumber', getU64Encoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n    ],\n    { size: getU16Encoder() }\n  );\n}\n\nexport function getExtensionDecoder(): Decoder<Extension> {\n  return getDiscriminatedUnionDecoder(\n    [\n      ['Uninitialized', getUnitDecoder()],\n      [\n        'TransferFeeConfig',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['transferFeeConfigAuthority', getAddressDecoder()],\n            ['withdrawWithheldAuthority', getAddressDecoder()],\n            ['withheldAmount', getU64Decoder()],\n            ['olderTransferFee', getTransferFeeDecoder()],\n            ['newerTransferFee', getTransferFeeDecoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'TransferFeeAmount',\n        addDecoderSizePrefix(\n          getStructDecoder([['withheldAmount', getU64Decoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'MintCloseAuthority',\n        addDecoderSizePrefix(\n          getStructDecoder([['closeAuthority', getAddressDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferMint',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['autoApproveNewAccounts', getBooleanDecoder()],\n            [\n              'auditorElgamalPubkey',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferAccount',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['approved', getBooleanDecoder()],\n            ['elgamalPubkey', getAddressDecoder()],\n            ['pendingBalanceLow', getEncryptedBalanceDecoder()],\n            ['pendingBalanceHigh', getEncryptedBalanceDecoder()],\n            ['availableBalance', getEncryptedBalanceDecoder()],\n            ['decryptableAvailableBalance', getDecryptableBalanceDecoder()],\n            ['allowConfidentialCredits', getBooleanDecoder()],\n            ['allowNonConfidentialCredits', getBooleanDecoder()],\n            ['pendingBalanceCreditCounter', getU64Decoder()],\n            ['maximumPendingBalanceCreditCounter', getU64Decoder()],\n            ['expectedPendingBalanceCreditCounter', getU64Decoder()],\n            ['actualPendingBalanceCreditCounter', getU64Decoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'DefaultAccountState',\n        addDecoderSizePrefix(\n          getStructDecoder([['state', getAccountStateDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'ImmutableOwner',\n        addDecoderSizePrefix(getStructDecoder([]), getU16Decoder()),\n      ],\n      [\n        'MemoTransfer',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['requireIncomingTransferMemos', getBooleanDecoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'NonTransferable',\n        addDecoderSizePrefix(getStructDecoder([]), getU16Decoder()),\n      ],\n      [\n        'InterestBearingConfig',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['rateAuthority', getAddressDecoder()],\n            ['initializationTimestamp', getU64Decoder()],\n            ['preUpdateAverageRate', getI16Decoder()],\n            ['lastUpdateTimestamp', getU64Decoder()],\n            ['currentRate', getI16Decoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'CpiGuard',\n        addDecoderSizePrefix(\n          getStructDecoder([['lockCpi', getBooleanDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'PermanentDelegate',\n        addDecoderSizePrefix(\n          getStructDecoder([['delegate', getAddressDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'NonTransferableAccount',\n        addDecoderSizePrefix(getStructDecoder([]), getU16Decoder()),\n      ],\n      [\n        'TransferHook',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['authority', getAddressDecoder()],\n            ['programId', getAddressDecoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'TransferHookAccount',\n        addDecoderSizePrefix(\n          getStructDecoder([['transferring', getBooleanDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferFee',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['elgamalPubkey', getAddressDecoder()],\n            ['harvestToMintEnabled', getBooleanDecoder()],\n            ['withheldAmount', getEncryptedBalanceDecoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferFeeAmount',\n        addDecoderSizePrefix(\n          getStructDecoder([['withheldAmount', getEncryptedBalanceDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'MetadataPointer',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'metadataAddress',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'TokenMetadata',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'updateAuthority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['mint', getAddressDecoder()],\n            ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n            ['symbol', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n            ['uri', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n            [\n              'additionalMetadata',\n              getMapDecoder(\n                addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()),\n                addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())\n              ),\n            ],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'GroupPointer',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'groupAddress',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'TokenGroup',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'updateAuthority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['mint', getAddressDecoder()],\n            ['size', getU64Decoder()],\n            ['maxSize', getU64Decoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'GroupMemberPointer',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'memberAddress',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'TokenGroupMember',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['mint', getAddressDecoder()],\n            ['group', getAddressDecoder()],\n            ['memberNumber', getU64Decoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n    ],\n    { size: getU16Decoder() }\n  );\n}\n\nexport function getExtensionCodec(): Codec<ExtensionArgs, Extension> {\n  return combineCodec(getExtensionEncoder(), getExtensionDecoder());\n}\n\n// Data Enum Helpers.\nexport function extension(\n  kind: 'Uninitialized'\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'Uninitialized'>;\nexport function extension(\n  kind: 'TransferFeeConfig',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TransferFeeConfig'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TransferFeeConfig'>;\nexport function extension(\n  kind: 'TransferFeeAmount',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TransferFeeAmount'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TransferFeeAmount'>;\nexport function extension(\n  kind: 'MintCloseAuthority',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'MintCloseAuthority'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'MintCloseAuthority'>;\nexport function extension(\n  kind: 'ConfidentialTransferMint',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ConfidentialTransferMint'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'ConfidentialTransferMint'\n>;\nexport function extension(\n  kind: 'ConfidentialTransferAccount',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ConfidentialTransferAccount'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'ConfidentialTransferAccount'\n>;\nexport function extension(\n  kind: 'DefaultAccountState',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'DefaultAccountState'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'DefaultAccountState'>;\nexport function extension(\n  kind: 'ImmutableOwner',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ImmutableOwner'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'ImmutableOwner'>;\nexport function extension(\n  kind: 'MemoTransfer',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'MemoTransfer'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'MemoTransfer'>;\nexport function extension(\n  kind: 'NonTransferable',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'NonTransferable'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'NonTransferable'>;\nexport function extension(\n  kind: 'InterestBearingConfig',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'InterestBearingConfig'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'InterestBearingConfig'\n>;\nexport function extension(\n  kind: 'CpiGuard',\n  data: GetDiscriminatedUnionVariantContent<ExtensionArgs, '__kind', 'CpiGuard'>\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'CpiGuard'>;\nexport function extension(\n  kind: 'PermanentDelegate',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'PermanentDelegate'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'PermanentDelegate'>;\nexport function extension(\n  kind: 'NonTransferableAccount',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'NonTransferableAccount'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'NonTransferableAccount'\n>;\nexport function extension(\n  kind: 'TransferHook',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TransferHook'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TransferHook'>;\nexport function extension(\n  kind: 'TransferHookAccount',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TransferHookAccount'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TransferHookAccount'>;\nexport function extension(\n  kind: 'ConfidentialTransferFee',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ConfidentialTransferFee'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'ConfidentialTransferFee'\n>;\nexport function extension(\n  kind: 'ConfidentialTransferFeeAmount',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ConfidentialTransferFeeAmount'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'ConfidentialTransferFeeAmount'\n>;\nexport function extension(\n  kind: 'MetadataPointer',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'MetadataPointer'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'MetadataPointer'>;\nexport function extension(\n  kind: 'TokenMetadata',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TokenMetadata'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TokenMetadata'>;\nexport function extension(\n  kind: 'GroupPointer',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'GroupPointer'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'GroupPointer'>;\nexport function extension(\n  kind: 'TokenGroup',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TokenGroup'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TokenGroup'>;\nexport function extension(\n  kind: 'GroupMemberPointer',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'GroupMemberPointer'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'GroupMemberPointer'>;\nexport function extension(\n  kind: 'TokenGroupMember',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TokenGroupMember'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TokenGroupMember'>;\nexport function extension<K extends ExtensionArgs['__kind'], Data>(\n  kind: K,\n  data?: Data\n) {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isExtension<K extends Extension['__kind']>(\n  kind: K,\n  value: Extension\n): value is Extension & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\n/**\n * Extensions that can be applied to mints or accounts.  Mint extensions must\n * only be applied to mint accounts, and account extensions must only be\n * applied to token holding accounts.\n */\n\nexport enum ExtensionType {\n  Uninitialized,\n  TransferFeeConfig,\n  TransferFeeAmount,\n  MintCloseAuthority,\n  ConfidentialTransferMint,\n  ConfidentialTransferAccount,\n  DefaultAccountState,\n  ImmutableOwner,\n  MemoTransfer,\n  NonTransferable,\n  InterestBearingConfig,\n  CpiGuard,\n  PermanentDelegate,\n  NonTransferableAccount,\n  TransferHook,\n  TransferHookAccount,\n  ConfidentialTransferFee,\n  ConfidentialTransferFeeAmount,\n  MetadataPointer,\n  TokenMetadata,\n  GroupPointer,\n  TokenGroup,\n  GroupMemberPointer,\n  TokenGroupMember,\n}\n\nexport type ExtensionTypeArgs = ExtensionType;\n\nexport function getExtensionTypeEncoder(): Encoder<ExtensionTypeArgs> {\n  return getEnumEncoder(ExtensionType, { size: getU16Encoder() });\n}\n\nexport function getExtensionTypeDecoder(): Decoder<ExtensionType> {\n  return getEnumDecoder(ExtensionType, { size: getU16Decoder() });\n}\n\nexport function getExtensionTypeCodec(): Codec<\n  ExtensionTypeArgs,\n  ExtensionType\n> {\n  return combineCodec(getExtensionTypeEncoder(), getExtensionTypeDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getDiscriminatedUnionDecoder,\n  getDiscriminatedUnionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getTupleDecoder,\n  getTupleEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUnitDecoder,\n  getUnitEncoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type GetDiscriminatedUnionVariant,\n  type GetDiscriminatedUnionVariantContent,\n} from '@solana/kit';\n\n/** Fields in the metadata account, used for updating. */\nexport type TokenMetadataField =\n  | { __kind: 'Name' }\n  | { __kind: 'Symbol' }\n  | { __kind: 'Uri' }\n  | { __kind: 'Key'; fields: readonly [string] };\n\nexport type TokenMetadataFieldArgs = TokenMetadataField;\n\nexport function getTokenMetadataFieldEncoder(): Encoder<TokenMetadataFieldArgs> {\n  return getDiscriminatedUnionEncoder([\n    ['Name', getUnitEncoder()],\n    ['Symbol', getUnitEncoder()],\n    ['Uri', getUnitEncoder()],\n    [\n      'Key',\n      getStructEncoder([\n        [\n          'fields',\n          getTupleEncoder([\n            addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),\n          ]),\n        ],\n      ]),\n    ],\n  ]);\n}\n\nexport function getTokenMetadataFieldDecoder(): Decoder<TokenMetadataField> {\n  return getDiscriminatedUnionDecoder([\n    ['Name', getUnitDecoder()],\n    ['Symbol', getUnitDecoder()],\n    ['Uri', getUnitDecoder()],\n    [\n      'Key',\n      getStructDecoder([\n        [\n          'fields',\n          getTupleDecoder([\n            addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()),\n          ]),\n        ],\n      ]),\n    ],\n  ]);\n}\n\nexport function getTokenMetadataFieldCodec(): Codec<\n  TokenMetadataFieldArgs,\n  TokenMetadataField\n> {\n  return combineCodec(\n    getTokenMetadataFieldEncoder(),\n    getTokenMetadataFieldDecoder()\n  );\n}\n\n// Data Enum Helpers.\nexport function tokenMetadataField(\n  kind: 'Name'\n): GetDiscriminatedUnionVariant<TokenMetadataFieldArgs, '__kind', 'Name'>;\nexport function tokenMetadataField(\n  kind: 'Symbol'\n): GetDiscriminatedUnionVariant<TokenMetadataFieldArgs, '__kind', 'Symbol'>;\nexport function tokenMetadataField(\n  kind: 'Uri'\n): GetDiscriminatedUnionVariant<TokenMetadataFieldArgs, '__kind', 'Uri'>;\nexport function tokenMetadataField(\n  kind: 'Key',\n  data: GetDiscriminatedUnionVariantContent<\n    TokenMetadataFieldArgs,\n    '__kind',\n    'Key'\n  >['fields']\n): GetDiscriminatedUnionVariant<TokenMetadataFieldArgs, '__kind', 'Key'>;\nexport function tokenMetadataField<\n  K extends TokenMetadataFieldArgs['__kind'],\n  Data,\n>(kind: K, data?: Data) {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isTokenMetadataField<K extends TokenMetadataField['__kind']>(\n  kind: K,\n  value: TokenMetadataField\n): value is TokenMetadataField & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\nexport type TransferFee = {\n  /** First epoch where the transfer fee takes effect. */\n  epoch: bigint;\n  /** Maximum fee assessed on transfers, expressed as an amount of tokens. */\n  maximumFee: bigint;\n  /**\n   * Amount of transfer collected as fees, expressed as basis points of the\n   * transfer amount, ie. increments of 0.01%.\n   */\n  transferFeeBasisPoints: number;\n};\n\nexport type TransferFeeArgs = {\n  /** First epoch where the transfer fee takes effect. */\n  epoch: number | bigint;\n  /** Maximum fee assessed on transfers, expressed as an amount of tokens. */\n  maximumFee: number | bigint;\n  /**\n   * Amount of transfer collected as fees, expressed as basis points of the\n   * transfer amount, ie. increments of 0.01%.\n   */\n  transferFeeBasisPoints: number;\n};\n\nexport function getTransferFeeEncoder(): Encoder<TransferFeeArgs> {\n  return getStructEncoder([\n    ['epoch', getU64Encoder()],\n    ['maximumFee', getU64Encoder()],\n    ['transferFeeBasisPoints', getU16Encoder()],\n  ]);\n}\n\nexport function getTransferFeeDecoder(): Decoder<TransferFee> {\n  return getStructDecoder([\n    ['epoch', getU64Decoder()],\n    ['maximumFee', getU64Decoder()],\n    ['transferFeeBasisPoints', getU16Decoder()],\n  ]);\n}\n\nexport function getTransferFeeCodec(): Codec<TransferFeeArgs, TransferFee> {\n  return combineCodec(getTransferFeeEncoder(), getTransferFeeDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getArrayDecoder,\n  getArrayEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getConstantDecoder,\n  getConstantEncoder,\n  getHiddenPrefixDecoder,\n  getHiddenPrefixEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  padLeftEncoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type Option,\n  type OptionOrNullable,\n} from '@solana/kit';\nimport {\n  getExtensionDecoder,\n  getExtensionEncoder,\n  type Extension,\n  type ExtensionArgs,\n} from '../types';\n\nexport type Mint = {\n  /**\n   * Optional authority used to mint new tokens. The mint authority may only\n   * be provided during mint creation. If no mint authority is present\n   * then the mint has a fixed supply and no further tokens may be minted.\n   */\n  mintAuthority: Option<Address>;\n  /** Total supply of tokens. */\n  supply: bigint;\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** Is `true` if this structure has been initialized. */\n  isInitialized: boolean;\n  /** Optional authority to freeze token accounts. */\n  freezeAuthority: Option<Address>;\n  /** The extensions activated on the mint account. */\n  extensions: Option<Array<Extension>>;\n};\n\nexport type MintArgs = {\n  /**\n   * Optional authority used to mint new tokens. The mint authority may only\n   * be provided during mint creation. If no mint authority is present\n   * then the mint has a fixed supply and no further tokens may be minted.\n   */\n  mintAuthority: OptionOrNullable<Address>;\n  /** Total supply of tokens. */\n  supply: number | bigint;\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** Is `true` if this structure has been initialized. */\n  isInitialized: boolean;\n  /** Optional authority to freeze token accounts. */\n  freezeAuthority: OptionOrNullable<Address>;\n  /** The extensions activated on the mint account. */\n  extensions: OptionOrNullable<Array<ExtensionArgs>>;\n};\n\nexport function getMintEncoder(): Encoder<MintArgs> {\n  return getStructEncoder([\n    [\n      'mintAuthority',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['supply', getU64Encoder()],\n    ['decimals', getU8Encoder()],\n    ['isInitialized', getBooleanEncoder()],\n    [\n      'freezeAuthority',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'extensions',\n      getOptionEncoder(\n        getHiddenPrefixEncoder(\n          getArrayEncoder(getExtensionEncoder(), { size: 'remainder' }),\n          [getConstantEncoder(padLeftEncoder(getU8Encoder(), 83).encode(1))]\n        ),\n        { prefix: null }\n      ),\n    ],\n  ]);\n}\n\nexport function getMintDecoder(): Decoder<Mint> {\n  return getStructDecoder([\n    [\n      'mintAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['supply', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n    ['isInitialized', getBooleanDecoder()],\n    [\n      'freezeAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'extensions',\n      getOptionDecoder(\n        getHiddenPrefixDecoder(\n          getArrayDecoder(getExtensionDecoder(), { size: 'remainder' }),\n          [getConstantDecoder(padLeftEncoder(getU8Encoder(), 83).encode(1))]\n        ),\n        { prefix: null }\n      ),\n    ],\n  ]);\n}\n\nexport function getMintCodec(): Codec<MintArgs, Mint> {\n  return combineCodec(getMintEncoder(), getMintDecoder());\n}\n\nexport function decodeMint<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Mint, TAddress>;\nexport function decodeMint<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Mint, TAddress>;\nexport function decodeMint<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Mint, TAddress> | MaybeAccount<Mint, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getMintDecoder()\n  );\n}\n\nexport async function fetchMint<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Mint, TAddress>> {\n  const maybeAccount = await fetchMaybeMint(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeMint<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Mint, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeMint(maybeAccount);\n}\n\nexport async function fetchAllMint(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Mint>[]> {\n  const maybeAccounts = await fetchAllMaybeMint(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeMint(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Mint>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeMint(maybeAccount));\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getArrayDecoder,\n  getArrayEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n} from '@solana/kit';\n\nexport type Multisig = {\n  /** Number of signers required. */\n  m: number;\n  /** Number of valid signers. */\n  n: number;\n  /** Is `true` if this structure has been initialized. */\n  isInitialized: boolean;\n  /** Signer public keys. */\n  signers: Array<Address>;\n};\n\nexport type MultisigArgs = Multisig;\n\nexport function getMultisigEncoder(): Encoder<MultisigArgs> {\n  return getStructEncoder([\n    ['m', getU8Encoder()],\n    ['n', getU8Encoder()],\n    ['isInitialized', getBooleanEncoder()],\n    ['signers', getArrayEncoder(getAddressEncoder(), { size: 11 })],\n  ]);\n}\n\nexport function getMultisigDecoder(): Decoder<Multisig> {\n  return getStructDecoder([\n    ['m', getU8Decoder()],\n    ['n', getU8Decoder()],\n    ['isInitialized', getBooleanDecoder()],\n    ['signers', getArrayDecoder(getAddressDecoder(), { size: 11 })],\n  ]);\n}\n\nexport function getMultisigCodec(): Codec<MultisigArgs, Multisig> {\n  return combineCodec(getMultisigEncoder(), getMultisigDecoder());\n}\n\nexport function decodeMultisig<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Multisig, TAddress>;\nexport function decodeMultisig<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Multisig, TAddress>;\nexport function decodeMultisig<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Multisig, TAddress> | MaybeAccount<Multisig, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getMultisigDecoder()\n  );\n}\n\nexport async function fetchMultisig<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Multisig, TAddress>> {\n  const maybeAccount = await fetchMaybeMultisig(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeMultisig<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Multisig, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeMultisig(maybeAccount);\n}\n\nexport async function fetchAllMultisig(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Multisig>[]> {\n  const maybeAccounts = await fetchAllMaybeMultisig(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeMultisig(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Multisig>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeMultisig(maybeAccount));\n}\n\nexport function getMultisigSize(): number {\n  return 355;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getArrayDecoder,\n  getArrayEncoder,\n  getConstantDecoder,\n  getConstantEncoder,\n  getHiddenPrefixDecoder,\n  getHiddenPrefixEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Encoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type Option,\n  type OptionOrNullable,\n} from '@solana/kit';\nimport {\n  getAccountStateDecoder,\n  getAccountStateEncoder,\n  getExtensionDecoder,\n  getExtensionEncoder,\n  type AccountState,\n  type AccountStateArgs,\n  type Extension,\n  type ExtensionArgs,\n} from '../types';\n\nexport type Token = {\n  /** The mint associated with this account. */\n  mint: Address;\n  /** The owner of this account. */\n  owner: Address;\n  /** The amount of tokens this account holds. */\n  amount: bigint;\n  /**\n   * If `delegate` is `Some` then `delegated_amount` represents\n   * the amount authorized by the delegate.\n   */\n  delegate: Option<Address>;\n  /** The account's state. */\n  state: AccountState;\n  /**\n   * If is_native.is_some, this is a native token, and the value logs the\n   * rent-exempt reserve. An Account is required to be rent-exempt, so\n   * the value is used by the Processor to ensure that wrapped SOL\n   * accounts do not drop below this threshold.\n   */\n  isNative: Option<bigint>;\n  /** The amount delegated. */\n  delegatedAmount: bigint;\n  /** Optional authority to close the account. */\n  closeAuthority: Option<Address>;\n  /** The extensions activated on the token account. */\n  extensions: Option<Array<Extension>>;\n};\n\nexport type TokenArgs = {\n  /** The mint associated with this account. */\n  mint: Address;\n  /** The owner of this account. */\n  owner: Address;\n  /** The amount of tokens this account holds. */\n  amount: number | bigint;\n  /**\n   * If `delegate` is `Some` then `delegated_amount` represents\n   * the amount authorized by the delegate.\n   */\n  delegate: OptionOrNullable<Address>;\n  /** The account's state. */\n  state: AccountStateArgs;\n  /**\n   * If is_native.is_some, this is a native token, and the value logs the\n   * rent-exempt reserve. An Account is required to be rent-exempt, so\n   * the value is used by the Processor to ensure that wrapped SOL\n   * accounts do not drop below this threshold.\n   */\n  isNative: OptionOrNullable<number | bigint>;\n  /** The amount delegated. */\n  delegatedAmount: number | bigint;\n  /** Optional authority to close the account. */\n  closeAuthority: OptionOrNullable<Address>;\n  /** The extensions activated on the token account. */\n  extensions: OptionOrNullable<Array<ExtensionArgs>>;\n};\n\nexport function getTokenEncoder(): Encoder<TokenArgs> {\n  return getStructEncoder([\n    ['mint', getAddressEncoder()],\n    ['owner', getAddressEncoder()],\n    ['amount', getU64Encoder()],\n    [\n      'delegate',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['state', getAccountStateEncoder()],\n    [\n      'isNative',\n      getOptionEncoder(getU64Encoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['delegatedAmount', getU64Encoder()],\n    [\n      'closeAuthority',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'extensions',\n      getOptionEncoder(\n        getHiddenPrefixEncoder(\n          getArrayEncoder(getExtensionEncoder(), { size: 'remainder' }),\n          [getConstantEncoder(getU8Encoder().encode(2))]\n        ),\n        { prefix: null }\n      ),\n    ],\n  ]);\n}\n\nexport function getTokenDecoder(): Decoder<Token> {\n  return getStructDecoder([\n    ['mint', getAddressDecoder()],\n    ['owner', getAddressDecoder()],\n    ['amount', getU64Decoder()],\n    [\n      'delegate',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['state', getAccountStateDecoder()],\n    [\n      'isNative',\n      getOptionDecoder(getU64Decoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['delegatedAmount', getU64Decoder()],\n    [\n      'closeAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'extensions',\n      getOptionDecoder(\n        getHiddenPrefixDecoder(\n          getArrayDecoder(getExtensionDecoder(), { size: 'remainder' }),\n          [getConstantDecoder(getU8Encoder().encode(2))]\n        ),\n        { prefix: null }\n      ),\n    ],\n  ]);\n}\n\nexport function getTokenCodec(): Codec<TokenArgs, Token> {\n  return combineCodec(getTokenEncoder(), getTokenDecoder());\n}\n\nexport function decodeToken<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Token, TAddress>;\nexport function decodeToken<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Token, TAddress>;\nexport function decodeToken<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Token, TAddress> | MaybeAccount<Token, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getTokenDecoder()\n  );\n}\n\nexport async function fetchToken<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Token, TAddress>> {\n  const maybeAccount = await fetchMaybeToken(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeToken<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Token, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeToken(maybeAccount);\n}\n\nexport async function fetchAllToken(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Token>[]> {\n  const maybeAccounts = await fetchAllMaybeToken(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeToken(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Token>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeToken(maybeAccount));\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU8Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedCreateAssociatedTokenIdempotentInstruction,\n  type ParsedCreateAssociatedTokenInstruction,\n  type ParsedRecoverNestedAssociatedTokenInstruction,\n} from '../instructions';\n\nexport const ASSOCIATED_TOKEN_PROGRAM_ADDRESS =\n  'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;\n\nexport enum AssociatedTokenInstruction {\n  CreateAssociatedToken,\n  CreateAssociatedTokenIdempotent,\n  RecoverNestedAssociatedToken,\n}\n\nexport function identifyAssociatedTokenInstruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): AssociatedTokenInstruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU8Encoder().encode(0), 0)) {\n    return AssociatedTokenInstruction.CreateAssociatedToken;\n  }\n  if (containsBytes(data, getU8Encoder().encode(1), 0)) {\n    return AssociatedTokenInstruction.CreateAssociatedTokenIdempotent;\n  }\n  if (containsBytes(data, getU8Encoder().encode(2), 0)) {\n    return AssociatedTokenInstruction.RecoverNestedAssociatedToken;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a associatedToken instruction.'\n  );\n}\n\nexport type ParsedAssociatedTokenInstruction<\n  TProgram extends string = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',\n> =\n  | ({\n      instructionType: AssociatedTokenInstruction.CreateAssociatedToken;\n    } & ParsedCreateAssociatedTokenInstruction<TProgram>)\n  | ({\n      instructionType: AssociatedTokenInstruction.CreateAssociatedTokenIdempotent;\n    } & ParsedCreateAssociatedTokenIdempotentInstruction<TProgram>)\n  | ({\n      instructionType: AssociatedTokenInstruction.RecoverNestedAssociatedToken;\n    } & ParsedRecoverNestedAssociatedTokenInstruction<TProgram>);\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU8Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedAmountToUiAmountInstruction,\n  type ParsedApplyConfidentialPendingBalanceInstruction,\n  type ParsedApproveCheckedInstruction,\n  type ParsedApproveConfidentialTransferAccountInstruction,\n  type ParsedApproveInstruction,\n  type ParsedBurnCheckedInstruction,\n  type ParsedBurnInstruction,\n  type ParsedCloseAccountInstruction,\n  type ParsedConfidentialDepositInstruction,\n  type ParsedConfidentialTransferInstruction,\n  type ParsedConfidentialTransferWithFeeInstruction,\n  type ParsedConfidentialWithdrawInstruction,\n  type ParsedConfigureConfidentialTransferAccountInstruction,\n  type ParsedCreateNativeMintInstruction,\n  type ParsedDisableConfidentialCreditsInstruction,\n  type ParsedDisableCpiGuardInstruction,\n  type ParsedDisableHarvestToMintInstruction,\n  type ParsedDisableMemoTransfersInstruction,\n  type ParsedDisableNonConfidentialCreditsInstruction,\n  type ParsedEmitTokenMetadataInstruction,\n  type ParsedEmptyConfidentialTransferAccountInstruction,\n  type ParsedEnableConfidentialCreditsInstruction,\n  type ParsedEnableCpiGuardInstruction,\n  type ParsedEnableHarvestToMintInstruction,\n  type ParsedEnableMemoTransfersInstruction,\n  type ParsedEnableNonConfidentialCreditsInstruction,\n  type ParsedFreezeAccountInstruction,\n  type ParsedGetAccountDataSizeInstruction,\n  type ParsedHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction,\n  type ParsedHarvestWithheldTokensToMintInstruction,\n  type ParsedInitializeAccount2Instruction,\n  type ParsedInitializeAccount3Instruction,\n  type ParsedInitializeAccountInstruction,\n  type ParsedInitializeConfidentialTransferFeeInstruction,\n  type ParsedInitializeConfidentialTransferMintInstruction,\n  type ParsedInitializeDefaultAccountStateInstruction,\n  type ParsedInitializeGroupMemberPointerInstruction,\n  type ParsedInitializeGroupPointerInstruction,\n  type ParsedInitializeImmutableOwnerInstruction,\n  type ParsedInitializeInterestBearingMintInstruction,\n  type ParsedInitializeMetadataPointerInstruction,\n  type ParsedInitializeMint2Instruction,\n  type ParsedInitializeMintCloseAuthorityInstruction,\n  type ParsedInitializeMintInstruction,\n  type ParsedInitializeMultisig2Instruction,\n  type ParsedInitializeMultisigInstruction,\n  type ParsedInitializeNonTransferableMintInstruction,\n  type ParsedInitializePermanentDelegateInstruction,\n  type ParsedInitializeTokenGroupInstruction,\n  type ParsedInitializeTokenGroupMemberInstruction,\n  type ParsedInitializeTokenMetadataInstruction,\n  type ParsedInitializeTransferFeeConfigInstruction,\n  type ParsedInitializeTransferHookInstruction,\n  type ParsedMintToCheckedInstruction,\n  type ParsedMintToInstruction,\n  type ParsedReallocateInstruction,\n  type ParsedRemoveTokenMetadataKeyInstruction,\n  type ParsedRevokeInstruction,\n  type ParsedSetAuthorityInstruction,\n  type ParsedSetTransferFeeInstruction,\n  type ParsedSyncNativeInstruction,\n  type ParsedThawAccountInstruction,\n  type ParsedTransferCheckedInstruction,\n  type ParsedTransferCheckedWithFeeInstruction,\n  type ParsedTransferInstruction,\n  type ParsedUiAmountToAmountInstruction,\n  type ParsedUpdateConfidentialTransferMintInstruction,\n  type ParsedUpdateDefaultAccountStateInstruction,\n  type ParsedUpdateGroupMemberPointerInstruction,\n  type ParsedUpdateGroupPointerInstruction,\n  type ParsedUpdateMetadataPointerInstruction,\n  type ParsedUpdateRateInterestBearingMintInstruction,\n  type ParsedUpdateTokenGroupMaxSizeInstruction,\n  type ParsedUpdateTokenGroupUpdateAuthorityInstruction,\n  type ParsedUpdateTokenMetadataFieldInstruction,\n  type ParsedUpdateTokenMetadataUpdateAuthorityInstruction,\n  type ParsedUpdateTransferHookInstruction,\n  type ParsedWithdrawExcessLamportsInstruction,\n  type ParsedWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction,\n  type ParsedWithdrawWithheldTokensFromAccountsInstruction,\n  type ParsedWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction,\n  type ParsedWithdrawWithheldTokensFromMintInstruction,\n} from '../instructions';\n\nexport const TOKEN_2022_PROGRAM_ADDRESS =\n  'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n\nexport enum Token2022Account {\n  Mint,\n  Token,\n  Multisig,\n}\n\nexport function identifyToken2022Account(\n  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): Token2022Account {\n  const data = 'data' in account ? account.data : account;\n  if (data.length === 82) {\n    return Token2022Account.Mint;\n  }\n  if (data.length === 165) {\n    return Token2022Account.Token;\n  }\n  if (data.length === 355) {\n    return Token2022Account.Multisig;\n  }\n  throw new Error(\n    'The provided account could not be identified as a token-2022 account.'\n  );\n}\n\nexport enum Token2022Instruction {\n  InitializeMint,\n  InitializeAccount,\n  InitializeMultisig,\n  Transfer,\n  Approve,\n  Revoke,\n  SetAuthority,\n  MintTo,\n  Burn,\n  CloseAccount,\n  FreezeAccount,\n  ThawAccount,\n  TransferChecked,\n  ApproveChecked,\n  MintToChecked,\n  BurnChecked,\n  InitializeAccount2,\n  SyncNative,\n  InitializeAccount3,\n  InitializeMultisig2,\n  InitializeMint2,\n  GetAccountDataSize,\n  InitializeImmutableOwner,\n  AmountToUiAmount,\n  UiAmountToAmount,\n  InitializeMintCloseAuthority,\n  InitializeTransferFeeConfig,\n  TransferCheckedWithFee,\n  WithdrawWithheldTokensFromMint,\n  WithdrawWithheldTokensFromAccounts,\n  HarvestWithheldTokensToMint,\n  SetTransferFee,\n  InitializeConfidentialTransferMint,\n  UpdateConfidentialTransferMint,\n  ConfigureConfidentialTransferAccount,\n  ApproveConfidentialTransferAccount,\n  EmptyConfidentialTransferAccount,\n  ConfidentialDeposit,\n  ConfidentialWithdraw,\n  ConfidentialTransfer,\n  ApplyConfidentialPendingBalance,\n  EnableConfidentialCredits,\n  DisableConfidentialCredits,\n  EnableNonConfidentialCredits,\n  DisableNonConfidentialCredits,\n  ConfidentialTransferWithFee,\n  InitializeDefaultAccountState,\n  UpdateDefaultAccountState,\n  Reallocate,\n  EnableMemoTransfers,\n  DisableMemoTransfers,\n  CreateNativeMint,\n  InitializeNonTransferableMint,\n  InitializeInterestBearingMint,\n  UpdateRateInterestBearingMint,\n  EnableCpiGuard,\n  DisableCpiGuard,\n  InitializePermanentDelegate,\n  InitializeTransferHook,\n  UpdateTransferHook,\n  InitializeConfidentialTransferFee,\n  WithdrawWithheldTokensFromMintForConfidentialTransferFee,\n  WithdrawWithheldTokensFromAccountsForConfidentialTransferFee,\n  HarvestWithheldTokensToMintForConfidentialTransferFee,\n  EnableHarvestToMint,\n  DisableHarvestToMint,\n  WithdrawExcessLamports,\n  InitializeMetadataPointer,\n  UpdateMetadataPointer,\n  InitializeGroupPointer,\n  UpdateGroupPointer,\n  InitializeGroupMemberPointer,\n  UpdateGroupMemberPointer,\n  InitializeTokenMetadata,\n  UpdateTokenMetadataField,\n  RemoveTokenMetadataKey,\n  UpdateTokenMetadataUpdateAuthority,\n  EmitTokenMetadata,\n  InitializeTokenGroup,\n  UpdateTokenGroupMaxSize,\n  UpdateTokenGroupUpdateAuthority,\n  InitializeTokenGroupMember,\n}\n\nexport function identifyToken2022Instruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): Token2022Instruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU8Encoder().encode(0), 0)) {\n    return Token2022Instruction.InitializeMint;\n  }\n  if (containsBytes(data, getU8Encoder().encode(1), 0)) {\n    return Token2022Instruction.InitializeAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(2), 0)) {\n    return Token2022Instruction.InitializeMultisig;\n  }\n  if (containsBytes(data, getU8Encoder().encode(3), 0)) {\n    return Token2022Instruction.Transfer;\n  }\n  if (containsBytes(data, getU8Encoder().encode(4), 0)) {\n    return Token2022Instruction.Approve;\n  }\n  if (containsBytes(data, getU8Encoder().encode(5), 0)) {\n    return Token2022Instruction.Revoke;\n  }\n  if (containsBytes(data, getU8Encoder().encode(6), 0)) {\n    return Token2022Instruction.SetAuthority;\n  }\n  if (containsBytes(data, getU8Encoder().encode(7), 0)) {\n    return Token2022Instruction.MintTo;\n  }\n  if (containsBytes(data, getU8Encoder().encode(8), 0)) {\n    return Token2022Instruction.Burn;\n  }\n  if (containsBytes(data, getU8Encoder().encode(9), 0)) {\n    return Token2022Instruction.CloseAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(10), 0)) {\n    return Token2022Instruction.FreezeAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(11), 0)) {\n    return Token2022Instruction.ThawAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(12), 0)) {\n    return Token2022Instruction.TransferChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(13), 0)) {\n    return Token2022Instruction.ApproveChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(14), 0)) {\n    return Token2022Instruction.MintToChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(15), 0)) {\n    return Token2022Instruction.BurnChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(16), 0)) {\n    return Token2022Instruction.InitializeAccount2;\n  }\n  if (containsBytes(data, getU8Encoder().encode(17), 0)) {\n    return Token2022Instruction.SyncNative;\n  }\n  if (containsBytes(data, getU8Encoder().encode(18), 0)) {\n    return Token2022Instruction.InitializeAccount3;\n  }\n  if (containsBytes(data, getU8Encoder().encode(19), 0)) {\n    return Token2022Instruction.InitializeMultisig2;\n  }\n  if (containsBytes(data, getU8Encoder().encode(20), 0)) {\n    return Token2022Instruction.InitializeMint2;\n  }\n  if (containsBytes(data, getU8Encoder().encode(21), 0)) {\n    return Token2022Instruction.GetAccountDataSize;\n  }\n  if (containsBytes(data, getU8Encoder().encode(22), 0)) {\n    return Token2022Instruction.InitializeImmutableOwner;\n  }\n  if (containsBytes(data, getU8Encoder().encode(23), 0)) {\n    return Token2022Instruction.AmountToUiAmount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(24), 0)) {\n    return Token2022Instruction.UiAmountToAmount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(25), 0)) {\n    return Token2022Instruction.InitializeMintCloseAuthority;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeTransferFeeConfig;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.TransferCheckedWithFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(2), 1)\n  ) {\n    return Token2022Instruction.WithdrawWithheldTokensFromMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(3), 1)\n  ) {\n    return Token2022Instruction.WithdrawWithheldTokensFromAccounts;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(4), 1)\n  ) {\n    return Token2022Instruction.HarvestWithheldTokensToMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(5), 1)\n  ) {\n    return Token2022Instruction.SetTransferFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeConfidentialTransferMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateConfidentialTransferMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(2), 1)\n  ) {\n    return Token2022Instruction.ConfigureConfidentialTransferAccount;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(3), 1)\n  ) {\n    return Token2022Instruction.ApproveConfidentialTransferAccount;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(4), 1)\n  ) {\n    return Token2022Instruction.EmptyConfidentialTransferAccount;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(5), 1)\n  ) {\n    return Token2022Instruction.ConfidentialDeposit;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(6), 1)\n  ) {\n    return Token2022Instruction.ConfidentialWithdraw;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(7), 1)\n  ) {\n    return Token2022Instruction.ConfidentialTransfer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(8), 1)\n  ) {\n    return Token2022Instruction.ApplyConfidentialPendingBalance;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(9), 1)\n  ) {\n    return Token2022Instruction.EnableConfidentialCredits;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(10), 1)\n  ) {\n    return Token2022Instruction.DisableConfidentialCredits;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(11), 1)\n  ) {\n    return Token2022Instruction.EnableNonConfidentialCredits;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(12), 1)\n  ) {\n    return Token2022Instruction.DisableNonConfidentialCredits;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(13), 1)\n  ) {\n    return Token2022Instruction.ConfidentialTransferWithFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(28), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeDefaultAccountState;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(28), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateDefaultAccountState;\n  }\n  if (containsBytes(data, getU8Encoder().encode(29), 0)) {\n    return Token2022Instruction.Reallocate;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(30), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.EnableMemoTransfers;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(30), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.DisableMemoTransfers;\n  }\n  if (containsBytes(data, getU8Encoder().encode(31), 0)) {\n    return Token2022Instruction.CreateNativeMint;\n  }\n  if (containsBytes(data, getU8Encoder().encode(32), 0)) {\n    return Token2022Instruction.InitializeNonTransferableMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(33), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeInterestBearingMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(33), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateRateInterestBearingMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(34), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.EnableCpiGuard;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(34), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.DisableCpiGuard;\n  }\n  if (containsBytes(data, getU8Encoder().encode(35), 0)) {\n    return Token2022Instruction.InitializePermanentDelegate;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(36), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeTransferHook;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(36), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateTransferHook;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeConfidentialTransferFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.WithdrawWithheldTokensFromMintForConfidentialTransferFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(2), 1)\n  ) {\n    return Token2022Instruction.WithdrawWithheldTokensFromAccountsForConfidentialTransferFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(3), 1)\n  ) {\n    return Token2022Instruction.HarvestWithheldTokensToMintForConfidentialTransferFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(4), 1)\n  ) {\n    return Token2022Instruction.EnableHarvestToMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(5), 1)\n  ) {\n    return Token2022Instruction.DisableHarvestToMint;\n  }\n  if (containsBytes(data, getU8Encoder().encode(38), 0)) {\n    return Token2022Instruction.WithdrawExcessLamports;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(39), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeMetadataPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(39), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateMetadataPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(40), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeGroupPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(40), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateGroupPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(41), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeGroupMemberPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(41), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateGroupMemberPointer;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([210, 225, 30, 162, 88, 184, 77, 141]),\n      0\n    )\n  ) {\n    return Token2022Instruction.InitializeTokenMetadata;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([221, 233, 49, 45, 181, 202, 220, 200]),\n      0\n    )\n  ) {\n    return Token2022Instruction.UpdateTokenMetadataField;\n  }\n  if (\n    containsBytes(data, new Uint8Array([234, 18, 32, 56, 89, 141, 37, 181]), 0)\n  ) {\n    return Token2022Instruction.RemoveTokenMetadataKey;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([215, 228, 166, 228, 84, 100, 86, 123]),\n      0\n    )\n  ) {\n    return Token2022Instruction.UpdateTokenMetadataUpdateAuthority;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([250, 166, 180, 250, 13, 12, 184, 70]),\n      0\n    )\n  ) {\n    return Token2022Instruction.EmitTokenMetadata;\n  }\n  if (\n    containsBytes(data, new Uint8Array([121, 113, 108, 39, 54, 51, 0, 4]), 0)\n  ) {\n    return Token2022Instruction.InitializeTokenGroup;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([108, 37, 171, 143, 248, 30, 18, 110]),\n      0\n    )\n  ) {\n    return Token2022Instruction.UpdateTokenGroupMaxSize;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([161, 105, 88, 1, 237, 221, 216, 203]),\n      0\n    )\n  ) {\n    return Token2022Instruction.UpdateTokenGroupUpdateAuthority;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([152, 32, 222, 176, 223, 237, 116, 134]),\n      0\n    )\n  ) {\n    return Token2022Instruction.InitializeTokenGroupMember;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a token-2022 instruction.'\n  );\n}\n\nexport type ParsedToken2022Instruction<\n  TProgram extends string = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb',\n> =\n  | ({\n      instructionType: Token2022Instruction.InitializeMint;\n    } & ParsedInitializeMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeAccount;\n    } & ParsedInitializeAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeMultisig;\n    } & ParsedInitializeMultisigInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Transfer;\n    } & ParsedTransferInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Approve;\n    } & ParsedApproveInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Revoke;\n    } & ParsedRevokeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.SetAuthority;\n    } & ParsedSetAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.MintTo;\n    } & ParsedMintToInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Burn;\n    } & ParsedBurnInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.CloseAccount;\n    } & ParsedCloseAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.FreezeAccount;\n    } & ParsedFreezeAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ThawAccount;\n    } & ParsedThawAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.TransferChecked;\n    } & ParsedTransferCheckedInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ApproveChecked;\n    } & ParsedApproveCheckedInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.MintToChecked;\n    } & ParsedMintToCheckedInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.BurnChecked;\n    } & ParsedBurnCheckedInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeAccount2;\n    } & ParsedInitializeAccount2Instruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.SyncNative;\n    } & ParsedSyncNativeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeAccount3;\n    } & ParsedInitializeAccount3Instruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeMultisig2;\n    } & ParsedInitializeMultisig2Instruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeMint2;\n    } & ParsedInitializeMint2Instruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.GetAccountDataSize;\n    } & ParsedGetAccountDataSizeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeImmutableOwner;\n    } & ParsedInitializeImmutableOwnerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.AmountToUiAmount;\n    } & ParsedAmountToUiAmountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UiAmountToAmount;\n    } & ParsedUiAmountToAmountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeMintCloseAuthority;\n    } & ParsedInitializeMintCloseAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeTransferFeeConfig;\n    } & ParsedInitializeTransferFeeConfigInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.TransferCheckedWithFee;\n    } & ParsedTransferCheckedWithFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.WithdrawWithheldTokensFromMint;\n    } & ParsedWithdrawWithheldTokensFromMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.WithdrawWithheldTokensFromAccounts;\n    } & ParsedWithdrawWithheldTokensFromAccountsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.HarvestWithheldTokensToMint;\n    } & ParsedHarvestWithheldTokensToMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.SetTransferFee;\n    } & ParsedSetTransferFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeConfidentialTransferMint;\n    } & ParsedInitializeConfidentialTransferMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateConfidentialTransferMint;\n    } & ParsedUpdateConfidentialTransferMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ConfigureConfidentialTransferAccount;\n    } & ParsedConfigureConfidentialTransferAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ApproveConfidentialTransferAccount;\n    } & ParsedApproveConfidentialTransferAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EmptyConfidentialTransferAccount;\n    } & ParsedEmptyConfidentialTransferAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ConfidentialDeposit;\n    } & ParsedConfidentialDepositInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ConfidentialWithdraw;\n    } & ParsedConfidentialWithdrawInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ConfidentialTransfer;\n    } & ParsedConfidentialTransferInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ApplyConfidentialPendingBalance;\n    } & ParsedApplyConfidentialPendingBalanceInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EnableConfidentialCredits;\n    } & ParsedEnableConfidentialCreditsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.DisableConfidentialCredits;\n    } & ParsedDisableConfidentialCreditsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EnableNonConfidentialCredits;\n    } & ParsedEnableNonConfidentialCreditsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.DisableNonConfidentialCredits;\n    } & ParsedDisableNonConfidentialCreditsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ConfidentialTransferWithFee;\n    } & ParsedConfidentialTransferWithFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeDefaultAccountState;\n    } & ParsedInitializeDefaultAccountStateInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateDefaultAccountState;\n    } & ParsedUpdateDefaultAccountStateInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Reallocate;\n    } & ParsedReallocateInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EnableMemoTransfers;\n    } & ParsedEnableMemoTransfersInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.DisableMemoTransfers;\n    } & ParsedDisableMemoTransfersInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.CreateNativeMint;\n    } & ParsedCreateNativeMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeNonTransferableMint;\n    } & ParsedInitializeNonTransferableMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeInterestBearingMint;\n    } & ParsedInitializeInterestBearingMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateRateInterestBearingMint;\n    } & ParsedUpdateRateInterestBearingMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EnableCpiGuard;\n    } & ParsedEnableCpiGuardInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.DisableCpiGuard;\n    } & ParsedDisableCpiGuardInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializePermanentDelegate;\n    } & ParsedInitializePermanentDelegateInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeTransferHook;\n    } & ParsedInitializeTransferHookInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateTransferHook;\n    } & ParsedUpdateTransferHookInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeConfidentialTransferFee;\n    } & ParsedInitializeConfidentialTransferFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.WithdrawWithheldTokensFromMintForConfidentialTransferFee;\n    } & ParsedWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.WithdrawWithheldTokensFromAccountsForConfidentialTransferFee;\n    } & ParsedWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.HarvestWithheldTokensToMintForConfidentialTransferFee;\n    } & ParsedHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EnableHarvestToMint;\n    } & ParsedEnableHarvestToMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.DisableHarvestToMint;\n    } & ParsedDisableHarvestToMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.WithdrawExcessLamports;\n    } & ParsedWithdrawExcessLamportsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeMetadataPointer;\n    } & ParsedInitializeMetadataPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateMetadataPointer;\n    } & ParsedUpdateMetadataPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeGroupPointer;\n    } & ParsedInitializeGroupPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateGroupPointer;\n    } & ParsedUpdateGroupPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeGroupMemberPointer;\n    } & ParsedInitializeGroupMemberPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateGroupMemberPointer;\n    } & ParsedUpdateGroupMemberPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeTokenMetadata;\n    } & ParsedInitializeTokenMetadataInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateTokenMetadataField;\n    } & ParsedUpdateTokenMetadataFieldInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.RemoveTokenMetadataKey;\n    } & ParsedRemoveTokenMetadataKeyInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateTokenMetadataUpdateAuthority;\n    } & ParsedUpdateTokenMetadataUpdateAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EmitTokenMetadata;\n    } & ParsedEmitTokenMetadataInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeTokenGroup;\n    } & ParsedInitializeTokenGroupInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateTokenGroupMaxSize;\n    } & ParsedUpdateTokenGroupMaxSizeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateTokenGroupUpdateAuthority;\n    } & ParsedUpdateTokenGroupUpdateAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeTokenGroupMember;\n    } & ParsedInitializeTokenGroupMemberInstruction<TProgram>);\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  isProgramError,\n  type Address,\n  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n  type SolanaError,\n} from '@solana/kit';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\n\n/** InvalidOwner: Associated token account owner does not match address derivation */\nexport const ASSOCIATED_TOKEN_ERROR__INVALID_OWNER = 0x0; // 0\n\nexport type AssociatedTokenError = typeof ASSOCIATED_TOKEN_ERROR__INVALID_OWNER;\n\nlet associatedTokenErrorMessages:\n  | Record<AssociatedTokenError, string>\n  | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  associatedTokenErrorMessages = {\n    [ASSOCIATED_TOKEN_ERROR__INVALID_OWNER]: `Associated token account owner does not match address derivation`,\n  };\n}\n\nexport function getAssociatedTokenErrorMessage(\n  code: AssociatedTokenError\n): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (\n      associatedTokenErrorMessages as Record<AssociatedTokenError, string>\n    )[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}\n\nexport function isAssociatedTokenError<\n  TProgramErrorCode extends AssociatedTokenError,\n>(\n  error: unknown,\n  transactionMessage: {\n    instructions: Record<number, { programAddress: Address }>;\n  },\n  code?: TProgramErrorCode\n): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &\n  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return isProgramError<TProgramErrorCode>(\n    error,\n    transactionMessage,\n    ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n    code\n  );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  isProgramError,\n  type Address,\n  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n  type SolanaError,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\n\n/** NotRentExempt: Lamport balance below rent-exempt threshold */\nexport const TOKEN_2022_ERROR__NOT_RENT_EXEMPT = 0x0; // 0\n/** InsufficientFunds: Insufficient funds */\nexport const TOKEN_2022_ERROR__INSUFFICIENT_FUNDS = 0x1; // 1\n/** InvalidMint: Invalid Mint */\nexport const TOKEN_2022_ERROR__INVALID_MINT = 0x2; // 2\n/** MintMismatch: Account not associated with this Mint */\nexport const TOKEN_2022_ERROR__MINT_MISMATCH = 0x3; // 3\n/** OwnerMismatch: Owner does not match */\nexport const TOKEN_2022_ERROR__OWNER_MISMATCH = 0x4; // 4\n/** FixedSupply: Fixed supply */\nexport const TOKEN_2022_ERROR__FIXED_SUPPLY = 0x5; // 5\n/** AlreadyInUse: Already in use */\nexport const TOKEN_2022_ERROR__ALREADY_IN_USE = 0x6; // 6\n/** InvalidNumberOfProvidedSigners: Invalid number of provided signers */\nexport const TOKEN_2022_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS = 0x7; // 7\n/** InvalidNumberOfRequiredSigners: Invalid number of required signers */\nexport const TOKEN_2022_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS = 0x8; // 8\n/** UninitializedState: State is unititialized */\nexport const TOKEN_2022_ERROR__UNINITIALIZED_STATE = 0x9; // 9\n/** NativeNotSupported: Instruction does not support native tokens */\nexport const TOKEN_2022_ERROR__NATIVE_NOT_SUPPORTED = 0xa; // 10\n/** NonNativeHasBalance: Non-native account can only be closed if its balance is zero */\nexport const TOKEN_2022_ERROR__NON_NATIVE_HAS_BALANCE = 0xb; // 11\n/** InvalidInstruction: Invalid instruction */\nexport const TOKEN_2022_ERROR__INVALID_INSTRUCTION = 0xc; // 12\n/** InvalidState: State is invalid for requested operation */\nexport const TOKEN_2022_ERROR__INVALID_STATE = 0xd; // 13\n/** Overflow: Operation overflowed */\nexport const TOKEN_2022_ERROR__OVERFLOW = 0xe; // 14\n/** AuthorityTypeNotSupported: Account does not support specified authority type */\nexport const TOKEN_2022_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED = 0xf; // 15\n/** MintCannotFreeze: This token mint cannot freeze accounts */\nexport const TOKEN_2022_ERROR__MINT_CANNOT_FREEZE = 0x10; // 16\n/** AccountFrozen: Account is frozen */\nexport const TOKEN_2022_ERROR__ACCOUNT_FROZEN = 0x11; // 17\n/** MintDecimalsMismatch: The provided decimals value different from the Mint decimals */\nexport const TOKEN_2022_ERROR__MINT_DECIMALS_MISMATCH = 0x12; // 18\n/** NonNativeNotSupported: Instruction does not support non-native tokens */\nexport const TOKEN_2022_ERROR__NON_NATIVE_NOT_SUPPORTED = 0x13; // 19\n\nexport type Token2022Error =\n  | typeof TOKEN_2022_ERROR__ACCOUNT_FROZEN\n  | typeof TOKEN_2022_ERROR__ALREADY_IN_USE\n  | typeof TOKEN_2022_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED\n  | typeof TOKEN_2022_ERROR__FIXED_SUPPLY\n  | typeof TOKEN_2022_ERROR__INSUFFICIENT_FUNDS\n  | typeof TOKEN_2022_ERROR__INVALID_INSTRUCTION\n  | typeof TOKEN_2022_ERROR__INVALID_MINT\n  | typeof TOKEN_2022_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS\n  | typeof TOKEN_2022_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS\n  | typeof TOKEN_2022_ERROR__INVALID_STATE\n  | typeof TOKEN_2022_ERROR__MINT_CANNOT_FREEZE\n  | typeof TOKEN_2022_ERROR__MINT_DECIMALS_MISMATCH\n  | typeof TOKEN_2022_ERROR__MINT_MISMATCH\n  | typeof TOKEN_2022_ERROR__NATIVE_NOT_SUPPORTED\n  | typeof TOKEN_2022_ERROR__NON_NATIVE_HAS_BALANCE\n  | typeof TOKEN_2022_ERROR__NON_NATIVE_NOT_SUPPORTED\n  | typeof TOKEN_2022_ERROR__NOT_RENT_EXEMPT\n  | typeof TOKEN_2022_ERROR__OVERFLOW\n  | typeof TOKEN_2022_ERROR__OWNER_MISMATCH\n  | typeof TOKEN_2022_ERROR__UNINITIALIZED_STATE;\n\nlet token2022ErrorMessages: Record<Token2022Error, string> | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  token2022ErrorMessages = {\n    [TOKEN_2022_ERROR__ACCOUNT_FROZEN]: `Account is frozen`,\n    [TOKEN_2022_ERROR__ALREADY_IN_USE]: `Already in use`,\n    [TOKEN_2022_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED]: `Account does not support specified authority type`,\n    [TOKEN_2022_ERROR__FIXED_SUPPLY]: `Fixed supply`,\n    [TOKEN_2022_ERROR__INSUFFICIENT_FUNDS]: `Insufficient funds`,\n    [TOKEN_2022_ERROR__INVALID_INSTRUCTION]: `Invalid instruction`,\n    [TOKEN_2022_ERROR__INVALID_MINT]: `Invalid Mint`,\n    [TOKEN_2022_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS]: `Invalid number of provided signers`,\n    [TOKEN_2022_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS]: `Invalid number of required signers`,\n    [TOKEN_2022_ERROR__INVALID_STATE]: `State is invalid for requested operation`,\n    [TOKEN_2022_ERROR__MINT_CANNOT_FREEZE]: `This token mint cannot freeze accounts`,\n    [TOKEN_2022_ERROR__MINT_DECIMALS_MISMATCH]: `The provided decimals value different from the Mint decimals`,\n    [TOKEN_2022_ERROR__MINT_MISMATCH]: `Account not associated with this Mint`,\n    [TOKEN_2022_ERROR__NATIVE_NOT_SUPPORTED]: `Instruction does not support native tokens`,\n    [TOKEN_2022_ERROR__NON_NATIVE_HAS_BALANCE]: `Non-native account can only be closed if its balance is zero`,\n    [TOKEN_2022_ERROR__NON_NATIVE_NOT_SUPPORTED]: `Instruction does not support non-native tokens`,\n    [TOKEN_2022_ERROR__NOT_RENT_EXEMPT]: `Lamport balance below rent-exempt threshold`,\n    [TOKEN_2022_ERROR__OVERFLOW]: `Operation overflowed`,\n    [TOKEN_2022_ERROR__OWNER_MISMATCH]: `Owner does not match`,\n    [TOKEN_2022_ERROR__UNINITIALIZED_STATE]: `State is unititialized`,\n  };\n}\n\nexport function getToken2022ErrorMessage(code: Token2022Error): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (token2022ErrorMessages as Record<Token2022Error, string>)[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}\n\nexport function isToken2022Error<TProgramErrorCode extends Token2022Error>(\n  error: unknown,\n  transactionMessage: {\n    instructions: Record<number, { programAddress: Address }>;\n  },\n  code?: TProgramErrorCode\n): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &\n  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return isProgramError<TProgramErrorCode>(\n    error,\n    transactionMessage,\n    TOKEN_2022_PROGRAM_ADDRESS,\n    code\n  );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  isProgramDerivedAddress,\n  isTransactionSigner as kitIsTransactionSigner,\n  type Address,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type ProgramDerivedAddress,\n  type TransactionSigner,\n  upgradeRoleToSigner,\n} from '@solana/kit';\n\n/**\n * Asserts that the given value is not null or undefined.\n * @internal\n */\nexport function expectSome<T>(value: T | null | undefined): T {\n  if (value == null) {\n    throw new Error('Expected a value but received null or undefined.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a PublicKey.\n * @internal\n */\nexport function expectAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): Address<T> {\n  if (!value) {\n    throw new Error('Expected a Address.');\n  }\n  if (typeof value === 'object' && 'address' in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0];\n  }\n  return value as Address<T>;\n}\n\n/**\n * Asserts that the given value is a PDA.\n * @internal\n */\nexport function expectProgramDerivedAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): ProgramDerivedAddress<T> {\n  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {\n    throw new Error('Expected a ProgramDerivedAddress.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a TransactionSigner.\n * @internal\n */\nexport function expectTransactionSigner<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): TransactionSigner<T> {\n  if (!value || !isTransactionSigner(value)) {\n    throw new Error('Expected a TransactionSigner.');\n  }\n  return value;\n}\n\n/**\n * Defines an instruction account to resolve.\n * @internal\n */\nexport type ResolvedAccount<\n  T extends string = string,\n  U extends\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null =\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null,\n> = {\n  isWritable: boolean;\n  value: U;\n};\n\n/**\n * Defines an instruction that stores additional bytes on-chain.\n * @internal\n */\nexport type IInstructionWithByteDelta = {\n  byteDelta: number;\n};\n\n/**\n * Get account metas and signers from resolved accounts.\n * @internal\n */\nexport function getAccountMetaFactory(\n  programAddress: Address,\n  optionalAccountStrategy: 'omitted' | 'programId'\n) {\n  return (\n    account: ResolvedAccount\n  ): IAccountMeta | IAccountSignerMeta | undefined => {\n    if (!account.value) {\n      if (optionalAccountStrategy === 'omitted') return;\n      return Object.freeze({\n        address: programAddress,\n        role: AccountRole.READONLY,\n      });\n    }\n\n    const writableRole = account.isWritable\n      ? AccountRole.WRITABLE\n      : AccountRole.READONLY;\n    return Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value)\n        ? upgradeRoleToSigner(writableRole)\n        : writableRole,\n      ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),\n    });\n  };\n}\n\nexport function isTransactionSigner<TAddress extends string = string>(\n  value:\n    | Address<TAddress>\n    | ProgramDerivedAddress<TAddress>\n    | TransactionSigner<TAddress>\n): value is TransactionSigner<TAddress> {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'address' in value &&\n    kitIsTransactionSigner(value)\n  );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR = 23;\n\nexport function getAmountToUiAmountDiscriminatorBytes() {\n  return getU8Encoder().encode(AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR);\n}\n\nexport type AmountToUiAmountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AmountToUiAmountInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to reformat. */\n  amount: bigint;\n};\n\nexport type AmountToUiAmountInstructionDataArgs = {\n  /** The amount of tokens to reformat. */\n  amount: number | bigint;\n};\n\nexport function getAmountToUiAmountInstructionDataEncoder(): Encoder<AmountToUiAmountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getAmountToUiAmountInstructionDataDecoder(): Decoder<AmountToUiAmountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getAmountToUiAmountInstructionDataCodec(): Codec<\n  AmountToUiAmountInstructionDataArgs,\n  AmountToUiAmountInstructionData\n> {\n  return combineCodec(\n    getAmountToUiAmountInstructionDataEncoder(),\n    getAmountToUiAmountInstructionDataDecoder()\n  );\n}\n\nexport type AmountToUiAmountInput<TAccountMint extends string = string> = {\n  /** The mint to calculate for. */\n  mint: Address<TAccountMint>;\n  amount: AmountToUiAmountInstructionDataArgs['amount'];\n};\n\nexport function getAmountToUiAmountInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: AmountToUiAmountInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): AmountToUiAmountInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getAmountToUiAmountInstructionDataEncoder().encode(\n      args as AmountToUiAmountInstructionDataArgs\n    ),\n  } as AmountToUiAmountInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedAmountToUiAmountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to calculate for. */\n    mint: TAccountMetas[0];\n  };\n  data: AmountToUiAmountInstructionData;\n};\n\nexport function parseAmountToUiAmountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAmountToUiAmountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getAmountToUiAmountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const APPLY_CONFIDENTIAL_PENDING_BALANCE_DISCRIMINATOR = 27;\n\nexport function getApplyConfidentialPendingBalanceDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    APPLY_CONFIDENTIAL_PENDING_BALANCE_DISCRIMINATOR\n  );\n}\n\nexport const APPLY_CONFIDENTIAL_PENDING_BALANCE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 8;\n\nexport function getApplyConfidentialPendingBalanceConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    APPLY_CONFIDENTIAL_PENDING_BALANCE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ApplyConfidentialPendingBalanceInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ApplyConfidentialPendingBalanceInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /**\n   * The expected number of pending balance credits since the last successful\n   * `ApplyPendingBalance` instruction\n   */\n  expectedPendingBalanceCreditCounter: bigint;\n  /**\n   * The new decryptable balance if the pending balance is applied\n   * successfully\n   */\n  newDecryptableAvailableBalance: DecryptableBalance;\n};\n\nexport type ApplyConfidentialPendingBalanceInstructionDataArgs = {\n  /**\n   * The expected number of pending balance credits since the last successful\n   * `ApplyPendingBalance` instruction\n   */\n  expectedPendingBalanceCreditCounter: number | bigint;\n  /**\n   * The new decryptable balance if the pending balance is applied\n   * successfully\n   */\n  newDecryptableAvailableBalance: DecryptableBalanceArgs;\n};\n\nexport function getApplyConfidentialPendingBalanceInstructionDataEncoder(): Encoder<ApplyConfidentialPendingBalanceInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['expectedPendingBalanceCreditCounter', getU64Encoder()],\n      ['newDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: APPLY_CONFIDENTIAL_PENDING_BALANCE_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        APPLY_CONFIDENTIAL_PENDING_BALANCE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getApplyConfidentialPendingBalanceInstructionDataDecoder(): Decoder<ApplyConfidentialPendingBalanceInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['expectedPendingBalanceCreditCounter', getU64Decoder()],\n    ['newDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n  ]);\n}\n\nexport function getApplyConfidentialPendingBalanceInstructionDataCodec(): Codec<\n  ApplyConfidentialPendingBalanceInstructionDataArgs,\n  ApplyConfidentialPendingBalanceInstructionData\n> {\n  return combineCodec(\n    getApplyConfidentialPendingBalanceInstructionDataEncoder(),\n    getApplyConfidentialPendingBalanceInstructionDataDecoder()\n  );\n}\n\nexport type ApplyConfidentialPendingBalanceInput<\n  TAccountToken extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  expectedPendingBalanceCreditCounter: ApplyConfidentialPendingBalanceInstructionDataArgs['expectedPendingBalanceCreditCounter'];\n  newDecryptableAvailableBalance: ApplyConfidentialPendingBalanceInstructionDataArgs['newDecryptableAvailableBalance'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getApplyConfidentialPendingBalanceInstruction<\n  TAccountToken extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ApplyConfidentialPendingBalanceInput<TAccountToken, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): ApplyConfidentialPendingBalanceInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getApplyConfidentialPendingBalanceInstructionDataEncoder().encode(\n      args as ApplyConfidentialPendingBalanceInstructionDataArgs\n    ),\n  } as ApplyConfidentialPendingBalanceInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedApplyConfidentialPendingBalanceInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[1];\n  };\n  data: ApplyConfidentialPendingBalanceInstructionData;\n};\n\nexport function parseApplyConfidentialPendingBalanceInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedApplyConfidentialPendingBalanceInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getApplyConfidentialPendingBalanceInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const APPROVE_DISCRIMINATOR = 4;\n\nexport function getApproveDiscriminatorBytes() {\n  return getU8Encoder().encode(APPROVE_DISCRIMINATOR);\n}\n\nexport type ApproveInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | IAccountMeta<string> = string,\n  TAccountDelegate extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountDelegate extends string\n        ? ReadonlyAccount<TAccountDelegate>\n        : TAccountDelegate,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ApproveInstructionData = {\n  discriminator: number;\n  /** The amount of tokens the delegate is approved for. */\n  amount: bigint;\n};\n\nexport type ApproveInstructionDataArgs = {\n  /** The amount of tokens the delegate is approved for. */\n  amount: number | bigint;\n};\n\nexport function getApproveInstructionDataEncoder(): Encoder<ApproveInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: APPROVE_DISCRIMINATOR })\n  );\n}\n\nexport function getApproveInstructionDataDecoder(): Decoder<ApproveInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getApproveInstructionDataCodec(): Codec<\n  ApproveInstructionDataArgs,\n  ApproveInstructionData\n> {\n  return combineCodec(\n    getApproveInstructionDataEncoder(),\n    getApproveInstructionDataDecoder()\n  );\n}\n\nexport type ApproveInput<\n  TAccountSource extends string = string,\n  TAccountDelegate extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The delegate. */\n  delegate: Address<TAccountDelegate>;\n  /** The source account owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  amount: ApproveInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getApproveInstruction<\n  TAccountSource extends string,\n  TAccountDelegate extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ApproveInput<TAccountSource, TAccountDelegate, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): ApproveInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountDelegate,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    delegate: { value: input.delegate ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.delegate),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getApproveInstructionDataEncoder().encode(\n      args as ApproveInstructionDataArgs\n    ),\n  } as ApproveInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountDelegate,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedApproveInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The delegate. */\n    delegate: TAccountMetas[1];\n    /** The source account owner or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: ApproveInstructionData;\n};\n\nexport function parseApproveInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedApproveInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      delegate: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getApproveInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const APPROVE_CHECKED_DISCRIMINATOR = 13;\n\nexport function getApproveCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(APPROVE_CHECKED_DISCRIMINATOR);\n}\n\nexport type ApproveCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountDelegate extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDelegate extends string\n        ? ReadonlyAccount<TAccountDelegate>\n        : TAccountDelegate,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ApproveCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of tokens the delegate is approved for. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type ApproveCheckedInstructionDataArgs = {\n  /** The amount of tokens the delegate is approved for. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getApproveCheckedInstructionDataEncoder(): Encoder<ApproveCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: APPROVE_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getApproveCheckedInstructionDataDecoder(): Decoder<ApproveCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getApproveCheckedInstructionDataCodec(): Codec<\n  ApproveCheckedInstructionDataArgs,\n  ApproveCheckedInstructionData\n> {\n  return combineCodec(\n    getApproveCheckedInstructionDataEncoder(),\n    getApproveCheckedInstructionDataDecoder()\n  );\n}\n\nexport type ApproveCheckedInput<\n  TAccountSource extends string = string,\n  TAccountMint extends string = string,\n  TAccountDelegate extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The delegate. */\n  delegate: Address<TAccountDelegate>;\n  /** The source account owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  amount: ApproveCheckedInstructionDataArgs['amount'];\n  decimals: ApproveCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getApproveCheckedInstruction<\n  TAccountSource extends string,\n  TAccountMint extends string,\n  TAccountDelegate extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ApproveCheckedInput<\n    TAccountSource,\n    TAccountMint,\n    TAccountDelegate,\n    TAccountOwner\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ApproveCheckedInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountMint,\n  TAccountDelegate,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    delegate: { value: input.delegate ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.delegate),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getApproveCheckedInstructionDataEncoder().encode(\n      args as ApproveCheckedInstructionDataArgs\n    ),\n  } as ApproveCheckedInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountMint,\n    TAccountDelegate,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedApproveCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The delegate. */\n    delegate: TAccountMetas[2];\n    /** The source account owner or its multisignature account. */\n    owner: TAccountMetas[3];\n  };\n  data: ApproveCheckedInstructionData;\n};\n\nexport function parseApproveCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedApproveCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      mint: getNextAccount(),\n      delegate: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getApproveCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR = 27;\n\nexport function getApproveConfidentialTransferAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR\n  );\n}\n\nexport const APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 3;\n\nexport function getApproveConfidentialTransferAccountConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ApproveConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlySignerAccount<TAccountAuthority> &\n            IAccountSignerMeta<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ApproveConfidentialTransferAccountInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n};\n\nexport type ApproveConfidentialTransferAccountInstructionDataArgs = {};\n\nexport function getApproveConfidentialTransferAccountInstructionDataEncoder(): Encoder<ApproveConfidentialTransferAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getApproveConfidentialTransferAccountInstructionDataDecoder(): Decoder<ApproveConfidentialTransferAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getApproveConfidentialTransferAccountInstructionDataCodec(): Codec<\n  ApproveConfidentialTransferAccountInstructionDataArgs,\n  ApproveConfidentialTransferAccountInstructionData\n> {\n  return combineCodec(\n    getApproveConfidentialTransferAccountInstructionDataEncoder(),\n    getApproveConfidentialTransferAccountInstructionDataDecoder()\n  );\n}\n\nexport type ApproveConfidentialTransferAccountInput<\n  TAccountToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account to approve. */\n  token: Address<TAccountToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /** Confidential transfer mint authority. */\n  authority: TransactionSigner<TAccountAuthority>;\n};\n\nexport function getApproveConfidentialTransferAccountInstruction<\n  TAccountToken extends string,\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ApproveConfidentialTransferAccountInput<\n    TAccountToken,\n    TAccountMint,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ApproveConfidentialTransferAccountInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountMint,\n  TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n    ],\n    programAddress,\n    data: getApproveConfidentialTransferAccountInstructionDataEncoder().encode(\n      {}\n    ),\n  } as ApproveConfidentialTransferAccountInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountMint,\n    TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedApproveConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account to approve. */\n    token: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /** Confidential transfer mint authority. */\n    authority: TAccountMetas[2];\n  };\n  data: ApproveConfidentialTransferAccountInstructionData;\n};\n\nexport function parseApproveConfidentialTransferAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedApproveConfidentialTransferAccountInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getApproveConfidentialTransferAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const BURN_DISCRIMINATOR = 8;\n\nexport function getBurnDiscriminatorBytes() {\n  return getU8Encoder().encode(BURN_DISCRIMINATOR);\n}\n\nexport type BurnInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type BurnInstructionData = {\n  /** The amount of tokens to burn. */\n  discriminator: number;\n  amount: bigint;\n};\n\nexport type BurnInstructionDataArgs = { amount: number | bigint };\n\nexport function getBurnInstructionDataEncoder(): Encoder<BurnInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: BURN_DISCRIMINATOR })\n  );\n}\n\nexport function getBurnInstructionDataDecoder(): Decoder<BurnInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getBurnInstructionDataCodec(): Codec<\n  BurnInstructionDataArgs,\n  BurnInstructionData\n> {\n  return combineCodec(\n    getBurnInstructionDataEncoder(),\n    getBurnInstructionDataDecoder()\n  );\n}\n\nexport type BurnInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The account to burn from. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: BurnInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getBurnInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: BurnInput<TAccountAccount, TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): BurnInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getBurnInstructionDataEncoder().encode(\n      args as BurnInstructionDataArgs\n    ),\n  } as BurnInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedBurnInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to burn from. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: BurnInstructionData;\n};\n\nexport function parseBurnInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedBurnInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getBurnInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const BURN_CHECKED_DISCRIMINATOR = 15;\n\nexport function getBurnCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(BURN_CHECKED_DISCRIMINATOR);\n}\n\nexport type BurnCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type BurnCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to burn. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type BurnCheckedInstructionDataArgs = {\n  /** The amount of tokens to burn. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getBurnCheckedInstructionDataEncoder(): Encoder<BurnCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: BURN_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getBurnCheckedInstructionDataDecoder(): Decoder<BurnCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getBurnCheckedInstructionDataCodec(): Codec<\n  BurnCheckedInstructionDataArgs,\n  BurnCheckedInstructionData\n> {\n  return combineCodec(\n    getBurnCheckedInstructionDataEncoder(),\n    getBurnCheckedInstructionDataDecoder()\n  );\n}\n\nexport type BurnCheckedInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The account to burn from. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: BurnCheckedInstructionDataArgs['amount'];\n  decimals: BurnCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getBurnCheckedInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: BurnCheckedInput<TAccountAccount, TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): BurnCheckedInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getBurnCheckedInstructionDataEncoder().encode(\n      args as BurnCheckedInstructionDataArgs\n    ),\n  } as BurnCheckedInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedBurnCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to burn from. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: BurnCheckedInstructionData;\n};\n\nexport function parseBurnCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedBurnCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getBurnCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CLOSE_ACCOUNT_DISCRIMINATOR = 9;\n\nexport function getCloseAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(CLOSE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type CloseAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountDestination extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CloseAccountInstructionData = { discriminator: number };\n\nexport type CloseAccountInstructionDataArgs = {};\n\nexport function getCloseAccountInstructionDataEncoder(): Encoder<CloseAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: CLOSE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getCloseAccountInstructionDataDecoder(): Decoder<CloseAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCloseAccountInstructionDataCodec(): Codec<\n  CloseAccountInstructionDataArgs,\n  CloseAccountInstructionData\n> {\n  return combineCodec(\n    getCloseAccountInstructionDataEncoder(),\n    getCloseAccountInstructionDataDecoder()\n  );\n}\n\nexport type CloseAccountInput<\n  TAccountAccount extends string = string,\n  TAccountDestination extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The account to close. */\n  account: Address<TAccountAccount>;\n  /** The destination account. */\n  destination: Address<TAccountDestination>;\n  /** The account's owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getCloseAccountInstruction<\n  TAccountAccount extends string,\n  TAccountDestination extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: CloseAccountInput<TAccountAccount, TAccountDestination, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): CloseAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountDestination,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getCloseAccountInstructionDataEncoder().encode({}),\n  } as CloseAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountDestination,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCloseAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to close. */\n    account: TAccountMetas[0];\n    /** The destination account. */\n    destination: TAccountMetas[1];\n    /** The account's owner or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: CloseAccountInstructionData;\n};\n\nexport function parseCloseAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCloseAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      destination: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getCloseAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CONFIDENTIAL_DEPOSIT_DISCRIMINATOR = 27;\n\nexport function getConfidentialDepositDiscriminatorBytes() {\n  return getU8Encoder().encode(CONFIDENTIAL_DEPOSIT_DISCRIMINATOR);\n}\n\nexport const CONFIDENTIAL_DEPOSIT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 5;\n\nexport function getConfidentialDepositConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIDENTIAL_DEPOSIT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ConfidentialDepositInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ConfidentialDepositInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /** The amount of tokens to deposit. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type ConfidentialDepositInstructionDataArgs = {\n  /** The amount of tokens to deposit. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getConfidentialDepositInstructionDataEncoder(): Encoder<ConfidentialDepositInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIDENTIAL_DEPOSIT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        CONFIDENTIAL_DEPOSIT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getConfidentialDepositInstructionDataDecoder(): Decoder<ConfidentialDepositInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getConfidentialDepositInstructionDataCodec(): Codec<\n  ConfidentialDepositInstructionDataArgs,\n  ConfidentialDepositInstructionData\n> {\n  return combineCodec(\n    getConfidentialDepositInstructionDataEncoder(),\n    getConfidentialDepositInstructionDataDecoder()\n  );\n}\n\nexport type ConfidentialDepositInput<\n  TAccountToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: ConfidentialDepositInstructionDataArgs['amount'];\n  decimals: ConfidentialDepositInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getConfidentialDepositInstruction<\n  TAccountToken extends string,\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ConfidentialDepositInput<\n    TAccountToken,\n    TAccountMint,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ConfidentialDepositInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getConfidentialDepositInstructionDataEncoder().encode(\n      args as ConfidentialDepositInstructionDataArgs\n    ),\n  } as ConfidentialDepositInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedConfidentialDepositInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: ConfidentialDepositInstructionData;\n};\n\nexport function parseConfidentialDepositInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedConfidentialDepositInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getConfidentialDepositInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 27;\n\nexport function getConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(CONFIDENTIAL_TRANSFER_DISCRIMINATOR);\n}\n\nexport const CONFIDENTIAL_TRANSFER_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 7;\n\nexport function getConfidentialTransferConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIDENTIAL_TRANSFER_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ConfidentialTransferInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSourceToken extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountDestinationToken extends string | IAccountMeta<string> = string,\n  TAccountInstructionsSysvar extends string | IAccountMeta<string> = string,\n  TAccountEqualityRecord extends string | IAccountMeta<string> = string,\n  TAccountCiphertextValidityRecord extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountRangeRecord extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSourceToken extends string\n        ? WritableAccount<TAccountSourceToken>\n        : TAccountSourceToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestinationToken extends string\n        ? WritableAccount<TAccountDestinationToken>\n        : TAccountDestinationToken,\n      TAccountInstructionsSysvar extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvar>\n        : TAccountInstructionsSysvar,\n      TAccountEqualityRecord extends string\n        ? ReadonlyAccount<TAccountEqualityRecord>\n        : TAccountEqualityRecord,\n      TAccountCiphertextValidityRecord extends string\n        ? ReadonlyAccount<TAccountCiphertextValidityRecord>\n        : TAccountCiphertextValidityRecord,\n      TAccountRangeRecord extends string\n        ? ReadonlyAccount<TAccountRangeRecord>\n        : TAccountRangeRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ConfidentialTransferInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /** The new source decryptable balance if the transfer succeeds. */\n  newSourceDecryptableAvailableBalance: DecryptableBalance;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `Transfer` instruction in the transaction. If the offset is\n   * `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext3HandlesValidity`\n   * instruction to the `Transfer` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  ciphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU128Data`\n   * instruction to the `Transfer` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport type ConfidentialTransferInstructionDataArgs = {\n  /** The new source decryptable balance if the transfer succeeds. */\n  newSourceDecryptableAvailableBalance: DecryptableBalanceArgs;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `Transfer` instruction in the transaction. If the offset is\n   * `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext3HandlesValidity`\n   * instruction to the `Transfer` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  ciphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU128Data`\n   * instruction to the `Transfer` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport function getConfidentialTransferInstructionDataEncoder(): Encoder<ConfidentialTransferInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['newSourceDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n      ['equalityProofInstructionOffset', getI8Encoder()],\n      ['ciphertextValidityProofInstructionOffset', getI8Encoder()],\n      ['rangeProofInstructionOffset', getI8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        CONFIDENTIAL_TRANSFER_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getConfidentialTransferInstructionDataDecoder(): Decoder<ConfidentialTransferInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['newSourceDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n    ['equalityProofInstructionOffset', getI8Decoder()],\n    ['ciphertextValidityProofInstructionOffset', getI8Decoder()],\n    ['rangeProofInstructionOffset', getI8Decoder()],\n  ]);\n}\n\nexport function getConfidentialTransferInstructionDataCodec(): Codec<\n  ConfidentialTransferInstructionDataArgs,\n  ConfidentialTransferInstructionData\n> {\n  return combineCodec(\n    getConfidentialTransferInstructionDataEncoder(),\n    getConfidentialTransferInstructionDataDecoder()\n  );\n}\n\nexport type ConfidentialTransferInput<\n  TAccountSourceToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountDestinationToken extends string = string,\n  TAccountInstructionsSysvar extends string = string,\n  TAccountEqualityRecord extends string = string,\n  TAccountCiphertextValidityRecord extends string = string,\n  TAccountRangeRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source SPL Token account. */\n  sourceToken: Address<TAccountSourceToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /** The destination SPL Token account. */\n  destinationToken: Address<TAccountDestinationToken>;\n  /**\n   * (Optional) Instructions sysvar if at least one of the\n   * `zk_elgamal_proof` instructions are included in the same\n   * transaction.\n   */\n  instructionsSysvar?: Address<TAccountInstructionsSysvar>;\n  /** (Optional) Equality proof record account or context state account. */\n  equalityRecord?: Address<TAccountEqualityRecord>;\n  /** (Optional) Ciphertext validity proof record account or context state account. */\n  ciphertextValidityRecord?: Address<TAccountCiphertextValidityRecord>;\n  /** (Optional) Range proof record account or context state account. */\n  rangeRecord?: Address<TAccountRangeRecord>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  newSourceDecryptableAvailableBalance: ConfidentialTransferInstructionDataArgs['newSourceDecryptableAvailableBalance'];\n  equalityProofInstructionOffset: ConfidentialTransferInstructionDataArgs['equalityProofInstructionOffset'];\n  ciphertextValidityProofInstructionOffset: ConfidentialTransferInstructionDataArgs['ciphertextValidityProofInstructionOffset'];\n  rangeProofInstructionOffset: ConfidentialTransferInstructionDataArgs['rangeProofInstructionOffset'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getConfidentialTransferInstruction<\n  TAccountSourceToken extends string,\n  TAccountMint extends string,\n  TAccountDestinationToken extends string,\n  TAccountInstructionsSysvar extends string,\n  TAccountEqualityRecord extends string,\n  TAccountCiphertextValidityRecord extends string,\n  TAccountRangeRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ConfidentialTransferInput<\n    TAccountSourceToken,\n    TAccountMint,\n    TAccountDestinationToken,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountCiphertextValidityRecord,\n    TAccountRangeRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ConfidentialTransferInstruction<\n  TProgramAddress,\n  TAccountSourceToken,\n  TAccountMint,\n  TAccountDestinationToken,\n  TAccountInstructionsSysvar,\n  TAccountEqualityRecord,\n  TAccountCiphertextValidityRecord,\n  TAccountRangeRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    sourceToken: { value: input.sourceToken ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destinationToken: {\n      value: input.destinationToken ?? null,\n      isWritable: true,\n    },\n    instructionsSysvar: {\n      value: input.instructionsSysvar ?? null,\n      isWritable: false,\n    },\n    equalityRecord: { value: input.equalityRecord ?? null, isWritable: false },\n    ciphertextValidityRecord: {\n      value: input.ciphertextValidityRecord ?? null,\n      isWritable: false,\n    },\n    rangeRecord: { value: input.rangeRecord ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.sourceToken),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destinationToken),\n      getAccountMeta(accounts.instructionsSysvar),\n      getAccountMeta(accounts.equalityRecord),\n      getAccountMeta(accounts.ciphertextValidityRecord),\n      getAccountMeta(accounts.rangeRecord),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getConfidentialTransferInstructionDataEncoder().encode(\n      args as ConfidentialTransferInstructionDataArgs\n    ),\n  } as ConfidentialTransferInstruction<\n    TProgramAddress,\n    TAccountSourceToken,\n    TAccountMint,\n    TAccountDestinationToken,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountCiphertextValidityRecord,\n    TAccountRangeRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedConfidentialTransferInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source SPL Token account. */\n    sourceToken: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /** The destination SPL Token account. */\n    destinationToken: TAccountMetas[2];\n    /**\n     * (Optional) Instructions sysvar if at least one of the\n     * `zk_elgamal_proof` instructions are included in the same\n     * transaction.\n     */\n\n    instructionsSysvar?: TAccountMetas[3] | undefined;\n    /** (Optional) Equality proof record account or context state account. */\n    equalityRecord?: TAccountMetas[4] | undefined;\n    /** (Optional) Ciphertext validity proof record account or context state account. */\n    ciphertextValidityRecord?: TAccountMetas[5] | undefined;\n    /** (Optional) Range proof record account or context state account. */\n    rangeRecord?: TAccountMetas[6] | undefined;\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[7];\n  };\n  data: ConfidentialTransferInstructionData;\n};\n\nexport function parseConfidentialTransferInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedConfidentialTransferInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 8) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      sourceToken: getNextAccount(),\n      mint: getNextAccount(),\n      destinationToken: getNextAccount(),\n      instructionsSysvar: getNextOptionalAccount(),\n      equalityRecord: getNextOptionalAccount(),\n      ciphertextValidityRecord: getNextOptionalAccount(),\n      rangeRecord: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getConfidentialTransferInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const CONFIDENTIAL_TRANSFER_WITH_FEE_DISCRIMINATOR = 27;\n\nexport function getConfidentialTransferWithFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(CONFIDENTIAL_TRANSFER_WITH_FEE_DISCRIMINATOR);\n}\n\nexport const CONFIDENTIAL_TRANSFER_WITH_FEE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 13;\n\nexport function getConfidentialTransferWithFeeConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIDENTIAL_TRANSFER_WITH_FEE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ConfidentialTransferWithFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSourceToken extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountDestinationToken extends string | IAccountMeta<string> = string,\n  TAccountInstructionsSysvar extends string | IAccountMeta<string> = string,\n  TAccountEqualityRecord extends string | IAccountMeta<string> = string,\n  TAccountTransferAmountCiphertextValidityRecord extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountFeeSigmaRecord extends string | IAccountMeta<string> = string,\n  TAccountFeeCiphertextValidityRecord extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountRangeRecord extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSourceToken extends string\n        ? WritableAccount<TAccountSourceToken>\n        : TAccountSourceToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestinationToken extends string\n        ? WritableAccount<TAccountDestinationToken>\n        : TAccountDestinationToken,\n      TAccountInstructionsSysvar extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvar>\n        : TAccountInstructionsSysvar,\n      TAccountEqualityRecord extends string\n        ? ReadonlyAccount<TAccountEqualityRecord>\n        : TAccountEqualityRecord,\n      TAccountTransferAmountCiphertextValidityRecord extends string\n        ? ReadonlyAccount<TAccountTransferAmountCiphertextValidityRecord>\n        : TAccountTransferAmountCiphertextValidityRecord,\n      TAccountFeeSigmaRecord extends string\n        ? ReadonlyAccount<TAccountFeeSigmaRecord>\n        : TAccountFeeSigmaRecord,\n      TAccountFeeCiphertextValidityRecord extends string\n        ? ReadonlyAccount<TAccountFeeCiphertextValidityRecord>\n        : TAccountFeeCiphertextValidityRecord,\n      TAccountRangeRecord extends string\n        ? ReadonlyAccount<TAccountRangeRecord>\n        : TAccountRangeRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ConfidentialTransferWithFeeInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /** The new source decryptable balance if the transfer succeeds. */\n  newSourceDecryptableAvailableBalance: DecryptableBalance;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `TransferWithFee` instruction in the transaction. If the offset\n   * is `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext3HandlesValidity`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  transferAmountCiphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::VerifyPercentageWithFee`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  feeSigmaProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext2HandlesValidity`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  feeCiphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU256Data`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport type ConfidentialTransferWithFeeInstructionDataArgs = {\n  /** The new source decryptable balance if the transfer succeeds. */\n  newSourceDecryptableAvailableBalance: DecryptableBalanceArgs;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `TransferWithFee` instruction in the transaction. If the offset\n   * is `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext3HandlesValidity`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  transferAmountCiphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::VerifyPercentageWithFee`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  feeSigmaProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext2HandlesValidity`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  feeCiphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU256Data`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport function getConfidentialTransferWithFeeInstructionDataEncoder(): Encoder<ConfidentialTransferWithFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['newSourceDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n      ['equalityProofInstructionOffset', getI8Encoder()],\n      [\n        'transferAmountCiphertextValidityProofInstructionOffset',\n        getI8Encoder(),\n      ],\n      ['feeSigmaProofInstructionOffset', getI8Encoder()],\n      ['feeCiphertextValidityProofInstructionOffset', getI8Encoder()],\n      ['rangeProofInstructionOffset', getI8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIDENTIAL_TRANSFER_WITH_FEE_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        CONFIDENTIAL_TRANSFER_WITH_FEE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getConfidentialTransferWithFeeInstructionDataDecoder(): Decoder<ConfidentialTransferWithFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['newSourceDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n    ['equalityProofInstructionOffset', getI8Decoder()],\n    ['transferAmountCiphertextValidityProofInstructionOffset', getI8Decoder()],\n    ['feeSigmaProofInstructionOffset', getI8Decoder()],\n    ['feeCiphertextValidityProofInstructionOffset', getI8Decoder()],\n    ['rangeProofInstructionOffset', getI8Decoder()],\n  ]);\n}\n\nexport function getConfidentialTransferWithFeeInstructionDataCodec(): Codec<\n  ConfidentialTransferWithFeeInstructionDataArgs,\n  ConfidentialTransferWithFeeInstructionData\n> {\n  return combineCodec(\n    getConfidentialTransferWithFeeInstructionDataEncoder(),\n    getConfidentialTransferWithFeeInstructionDataDecoder()\n  );\n}\n\nexport type ConfidentialTransferWithFeeInput<\n  TAccountSourceToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountDestinationToken extends string = string,\n  TAccountInstructionsSysvar extends string = string,\n  TAccountEqualityRecord extends string = string,\n  TAccountTransferAmountCiphertextValidityRecord extends string = string,\n  TAccountFeeSigmaRecord extends string = string,\n  TAccountFeeCiphertextValidityRecord extends string = string,\n  TAccountRangeRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source SPL Token account. */\n  sourceToken: Address<TAccountSourceToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /** The destination SPL Token account. */\n  destinationToken: Address<TAccountDestinationToken>;\n  /**\n   * (Optional) Instructions sysvar if at least one of the\n   * `zk_elgamal_proof` instructions are included in the same\n   * transaction.\n   */\n  instructionsSysvar?: Address<TAccountInstructionsSysvar>;\n  /** (Optional) Equality proof record account or context state account. */\n  equalityRecord?: Address<TAccountEqualityRecord>;\n  /**\n   * (Optional) Transfer amount ciphertext validity proof record\n   * account or context state account.\n   */\n  transferAmountCiphertextValidityRecord?: Address<TAccountTransferAmountCiphertextValidityRecord>;\n  /** (Optional) Fee sigma proof record account or context state account. */\n  feeSigmaRecord?: Address<TAccountFeeSigmaRecord>;\n  /** (Optional) Fee ciphertext validity proof record account or context state account. */\n  feeCiphertextValidityRecord?: Address<TAccountFeeCiphertextValidityRecord>;\n  /** (Optional) Range proof record account or context state account. */\n  rangeRecord?: Address<TAccountRangeRecord>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  newSourceDecryptableAvailableBalance: ConfidentialTransferWithFeeInstructionDataArgs['newSourceDecryptableAvailableBalance'];\n  equalityProofInstructionOffset: ConfidentialTransferWithFeeInstructionDataArgs['equalityProofInstructionOffset'];\n  transferAmountCiphertextValidityProofInstructionOffset: ConfidentialTransferWithFeeInstructionDataArgs['transferAmountCiphertextValidityProofInstructionOffset'];\n  feeSigmaProofInstructionOffset: ConfidentialTransferWithFeeInstructionDataArgs['feeSigmaProofInstructionOffset'];\n  feeCiphertextValidityProofInstructionOffset: ConfidentialTransferWithFeeInstructionDataArgs['feeCiphertextValidityProofInstructionOffset'];\n  rangeProofInstructionOffset: ConfidentialTransferWithFeeInstructionDataArgs['rangeProofInstructionOffset'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getConfidentialTransferWithFeeInstruction<\n  TAccountSourceToken extends string,\n  TAccountMint extends string,\n  TAccountDestinationToken extends string,\n  TAccountInstructionsSysvar extends string,\n  TAccountEqualityRecord extends string,\n  TAccountTransferAmountCiphertextValidityRecord extends string,\n  TAccountFeeSigmaRecord extends string,\n  TAccountFeeCiphertextValidityRecord extends string,\n  TAccountRangeRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ConfidentialTransferWithFeeInput<\n    TAccountSourceToken,\n    TAccountMint,\n    TAccountDestinationToken,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountTransferAmountCiphertextValidityRecord,\n    TAccountFeeSigmaRecord,\n    TAccountFeeCiphertextValidityRecord,\n    TAccountRangeRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ConfidentialTransferWithFeeInstruction<\n  TProgramAddress,\n  TAccountSourceToken,\n  TAccountMint,\n  TAccountDestinationToken,\n  TAccountInstructionsSysvar,\n  TAccountEqualityRecord,\n  TAccountTransferAmountCiphertextValidityRecord,\n  TAccountFeeSigmaRecord,\n  TAccountFeeCiphertextValidityRecord,\n  TAccountRangeRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    sourceToken: { value: input.sourceToken ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destinationToken: {\n      value: input.destinationToken ?? null,\n      isWritable: true,\n    },\n    instructionsSysvar: {\n      value: input.instructionsSysvar ?? null,\n      isWritable: false,\n    },\n    equalityRecord: { value: input.equalityRecord ?? null, isWritable: false },\n    transferAmountCiphertextValidityRecord: {\n      value: input.transferAmountCiphertextValidityRecord ?? null,\n      isWritable: false,\n    },\n    feeSigmaRecord: { value: input.feeSigmaRecord ?? null, isWritable: false },\n    feeCiphertextValidityRecord: {\n      value: input.feeCiphertextValidityRecord ?? null,\n      isWritable: false,\n    },\n    rangeRecord: { value: input.rangeRecord ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.sourceToken),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destinationToken),\n      getAccountMeta(accounts.instructionsSysvar),\n      getAccountMeta(accounts.equalityRecord),\n      getAccountMeta(accounts.transferAmountCiphertextValidityRecord),\n      getAccountMeta(accounts.feeSigmaRecord),\n      getAccountMeta(accounts.feeCiphertextValidityRecord),\n      getAccountMeta(accounts.rangeRecord),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getConfidentialTransferWithFeeInstructionDataEncoder().encode(\n      args as ConfidentialTransferWithFeeInstructionDataArgs\n    ),\n  } as ConfidentialTransferWithFeeInstruction<\n    TProgramAddress,\n    TAccountSourceToken,\n    TAccountMint,\n    TAccountDestinationToken,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountTransferAmountCiphertextValidityRecord,\n    TAccountFeeSigmaRecord,\n    TAccountFeeCiphertextValidityRecord,\n    TAccountRangeRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedConfidentialTransferWithFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source SPL Token account. */\n    sourceToken: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /** The destination SPL Token account. */\n    destinationToken: TAccountMetas[2];\n    /**\n     * (Optional) Instructions sysvar if at least one of the\n     * `zk_elgamal_proof` instructions are included in the same\n     * transaction.\n     */\n\n    instructionsSysvar?: TAccountMetas[3] | undefined;\n    /** (Optional) Equality proof record account or context state account. */\n    equalityRecord?: TAccountMetas[4] | undefined;\n    /**\n     * (Optional) Transfer amount ciphertext validity proof record\n     * account or context state account.\n     */\n\n    transferAmountCiphertextValidityRecord?: TAccountMetas[5] | undefined;\n    /** (Optional) Fee sigma proof record account or context state account. */\n    feeSigmaRecord?: TAccountMetas[6] | undefined;\n    /** (Optional) Fee ciphertext validity proof record account or context state account. */\n    feeCiphertextValidityRecord?: TAccountMetas[7] | undefined;\n    /** (Optional) Range proof record account or context state account. */\n    rangeRecord?: TAccountMetas[8] | undefined;\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[9];\n  };\n  data: ConfidentialTransferWithFeeInstructionData;\n};\n\nexport function parseConfidentialTransferWithFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedConfidentialTransferWithFeeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 10) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      sourceToken: getNextAccount(),\n      mint: getNextAccount(),\n      destinationToken: getNextAccount(),\n      instructionsSysvar: getNextOptionalAccount(),\n      equalityRecord: getNextOptionalAccount(),\n      transferAmountCiphertextValidityRecord: getNextOptionalAccount(),\n      feeSigmaRecord: getNextOptionalAccount(),\n      feeCiphertextValidityRecord: getNextOptionalAccount(),\n      rangeRecord: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getConfidentialTransferWithFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const CONFIDENTIAL_WITHDRAW_DISCRIMINATOR = 27;\n\nexport function getConfidentialWithdrawDiscriminatorBytes() {\n  return getU8Encoder().encode(CONFIDENTIAL_WITHDRAW_DISCRIMINATOR);\n}\n\nexport const CONFIDENTIAL_WITHDRAW_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 6;\n\nexport function getConfidentialWithdrawConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIDENTIAL_WITHDRAW_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ConfidentialWithdrawInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountInstructionsSysvar extends string | IAccountMeta<string> = string,\n  TAccountEqualityRecord extends string | IAccountMeta<string> = string,\n  TAccountRangeRecord extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountInstructionsSysvar extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvar>\n        : TAccountInstructionsSysvar,\n      TAccountEqualityRecord extends string\n        ? ReadonlyAccount<TAccountEqualityRecord>\n        : TAccountEqualityRecord,\n      TAccountRangeRecord extends string\n        ? ReadonlyAccount<TAccountRangeRecord>\n        : TAccountRangeRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ConfidentialWithdrawInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /** The amount of tokens to withdraw. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The new decryptable balance if the withdrawal succeeds. */\n  newDecryptableAvailableBalance: DecryptableBalance;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `Withdraw` instruction in the transaction. If the offset is\n   * `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU64`\n   * instruction to the `Withdraw` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport type ConfidentialWithdrawInstructionDataArgs = {\n  /** The amount of tokens to withdraw. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The new decryptable balance if the withdrawal succeeds. */\n  newDecryptableAvailableBalance: DecryptableBalanceArgs;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `Withdraw` instruction in the transaction. If the offset is\n   * `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU64`\n   * instruction to the `Withdraw` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport function getConfidentialWithdrawInstructionDataEncoder(): Encoder<ConfidentialWithdrawInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n      ['newDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n      ['equalityProofInstructionOffset', getI8Encoder()],\n      ['rangeProofInstructionOffset', getI8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIDENTIAL_WITHDRAW_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        CONFIDENTIAL_WITHDRAW_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getConfidentialWithdrawInstructionDataDecoder(): Decoder<ConfidentialWithdrawInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n    ['newDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n    ['equalityProofInstructionOffset', getI8Decoder()],\n    ['rangeProofInstructionOffset', getI8Decoder()],\n  ]);\n}\n\nexport function getConfidentialWithdrawInstructionDataCodec(): Codec<\n  ConfidentialWithdrawInstructionDataArgs,\n  ConfidentialWithdrawInstructionData\n> {\n  return combineCodec(\n    getConfidentialWithdrawInstructionDataEncoder(),\n    getConfidentialWithdrawInstructionDataDecoder()\n  );\n}\n\nexport type ConfidentialWithdrawInput<\n  TAccountToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountInstructionsSysvar extends string = string,\n  TAccountEqualityRecord extends string = string,\n  TAccountRangeRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /**\n   * Instructions sysvar if at least one of the\n   * `zk_elgamal_proof` instructions are included in the same\n   * transaction.\n   */\n  instructionsSysvar?: Address<TAccountInstructionsSysvar>;\n  /** (Optional) Equality proof record account or context state account. */\n  equalityRecord?: Address<TAccountEqualityRecord>;\n  /** (Optional) Range proof record account or context state account. */\n  rangeRecord?: Address<TAccountRangeRecord>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: ConfidentialWithdrawInstructionDataArgs['amount'];\n  decimals: ConfidentialWithdrawInstructionDataArgs['decimals'];\n  newDecryptableAvailableBalance: ConfidentialWithdrawInstructionDataArgs['newDecryptableAvailableBalance'];\n  equalityProofInstructionOffset: ConfidentialWithdrawInstructionDataArgs['equalityProofInstructionOffset'];\n  rangeProofInstructionOffset: ConfidentialWithdrawInstructionDataArgs['rangeProofInstructionOffset'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getConfidentialWithdrawInstruction<\n  TAccountToken extends string,\n  TAccountMint extends string,\n  TAccountInstructionsSysvar extends string,\n  TAccountEqualityRecord extends string,\n  TAccountRangeRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ConfidentialWithdrawInput<\n    TAccountToken,\n    TAccountMint,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountRangeRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ConfidentialWithdrawInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountMint,\n  TAccountInstructionsSysvar,\n  TAccountEqualityRecord,\n  TAccountRangeRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    instructionsSysvar: {\n      value: input.instructionsSysvar ?? null,\n      isWritable: false,\n    },\n    equalityRecord: { value: input.equalityRecord ?? null, isWritable: false },\n    rangeRecord: { value: input.rangeRecord ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.instructionsSysvar),\n      getAccountMeta(accounts.equalityRecord),\n      getAccountMeta(accounts.rangeRecord),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getConfidentialWithdrawInstructionDataEncoder().encode(\n      args as ConfidentialWithdrawInstructionDataArgs\n    ),\n  } as ConfidentialWithdrawInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountMint,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountRangeRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedConfidentialWithdrawInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /**\n     * Instructions sysvar if at least one of the\n     * `zk_elgamal_proof` instructions are included in the same\n     * transaction.\n     */\n\n    instructionsSysvar?: TAccountMetas[2] | undefined;\n    /** (Optional) Equality proof record account or context state account. */\n    equalityRecord?: TAccountMetas[3] | undefined;\n    /** (Optional) Range proof record account or context state account. */\n    rangeRecord?: TAccountMetas[4] | undefined;\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[5];\n  };\n  data: ConfidentialWithdrawInstructionData;\n};\n\nexport function parseConfidentialWithdrawInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedConfidentialWithdrawInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      mint: getNextAccount(),\n      instructionsSysvar: getNextOptionalAccount(),\n      equalityRecord: getNextOptionalAccount(),\n      rangeRecord: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getConfidentialWithdrawInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR = 27;\n\nexport function getConfigureConfidentialTransferAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR\n  );\n}\n\nexport const CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 2;\n\nexport function getConfigureConfidentialTransferAccountConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ConfigureConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountInstructionsSysvarOrContextState extends\n    | string\n    | IAccountMeta<string> = 'Sysvar1nstructions1111111111111111111111111',\n  TAccountRecord extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountInstructionsSysvarOrContextState extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvarOrContextState>\n        : TAccountInstructionsSysvarOrContextState,\n      TAccountRecord extends string\n        ? ReadonlyAccount<TAccountRecord>\n        : TAccountRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ConfigureConfidentialTransferAccountInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /** The decryptable balance (always 0) once the configure account succeeds. */\n  decryptableZeroBalance: DecryptableBalance;\n  /**\n   * The maximum number of despots and transfers that an account can receiver\n   * before the `ApplyPendingBalance` is executed\n   */\n  maximumPendingBalanceCreditCounter: bigint;\n  /**\n   * Relative location of the `ProofInstruction::ZeroCiphertextProof`\n   * instruction to the `ConfigureAccount` instruction in the\n   * transaction. If the offset is `0`, then use a context state account\n   * for the proof.\n   */\n  proofInstructionOffset: number;\n};\n\nexport type ConfigureConfidentialTransferAccountInstructionDataArgs = {\n  /** The decryptable balance (always 0) once the configure account succeeds. */\n  decryptableZeroBalance: DecryptableBalanceArgs;\n  /**\n   * The maximum number of despots and transfers that an account can receiver\n   * before the `ApplyPendingBalance` is executed\n   */\n  maximumPendingBalanceCreditCounter: number | bigint;\n  /**\n   * Relative location of the `ProofInstruction::ZeroCiphertextProof`\n   * instruction to the `ConfigureAccount` instruction in the\n   * transaction. If the offset is `0`, then use a context state account\n   * for the proof.\n   */\n  proofInstructionOffset: number;\n};\n\nexport function getConfigureConfidentialTransferAccountInstructionDataEncoder(): Encoder<ConfigureConfidentialTransferAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['decryptableZeroBalance', getDecryptableBalanceEncoder()],\n      ['maximumPendingBalanceCreditCounter', getU64Encoder()],\n      ['proofInstructionOffset', getI8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getConfigureConfidentialTransferAccountInstructionDataDecoder(): Decoder<ConfigureConfidentialTransferAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['decryptableZeroBalance', getDecryptableBalanceDecoder()],\n    ['maximumPendingBalanceCreditCounter', getU64Decoder()],\n    ['proofInstructionOffset', getI8Decoder()],\n  ]);\n}\n\nexport function getConfigureConfidentialTransferAccountInstructionDataCodec(): Codec<\n  ConfigureConfidentialTransferAccountInstructionDataArgs,\n  ConfigureConfidentialTransferAccountInstructionData\n> {\n  return combineCodec(\n    getConfigureConfidentialTransferAccountInstructionDataEncoder(),\n    getConfigureConfidentialTransferAccountInstructionDataDecoder()\n  );\n}\n\nexport type ConfigureConfidentialTransferAccountInput<\n  TAccountToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountInstructionsSysvarOrContextState extends string = string,\n  TAccountRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /**\n   * Instructions sysvar if `VerifyPubkeyValidity` is included in\n   * the same transaction or context state account if\n   * `VerifyPubkeyValidity` is pre-verified into a context state\n   * account.\n   */\n  instructionsSysvarOrContextState?: Address<TAccountInstructionsSysvarOrContextState>;\n  /** (Optional) Record account if the accompanying proof is to be read from a record account. */\n  record?: Address<TAccountRecord>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  decryptableZeroBalance: ConfigureConfidentialTransferAccountInstructionDataArgs['decryptableZeroBalance'];\n  maximumPendingBalanceCreditCounter: ConfigureConfidentialTransferAccountInstructionDataArgs['maximumPendingBalanceCreditCounter'];\n  proofInstructionOffset: ConfigureConfidentialTransferAccountInstructionDataArgs['proofInstructionOffset'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getConfigureConfidentialTransferAccountInstruction<\n  TAccountToken extends string,\n  TAccountMint extends string,\n  TAccountInstructionsSysvarOrContextState extends string,\n  TAccountRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ConfigureConfidentialTransferAccountInput<\n    TAccountToken,\n    TAccountMint,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ConfigureConfidentialTransferAccountInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountMint,\n  TAccountInstructionsSysvarOrContextState,\n  TAccountRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    instructionsSysvarOrContextState: {\n      value: input.instructionsSysvarOrContextState ?? null,\n      isWritable: false,\n    },\n    record: { value: input.record ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.instructionsSysvarOrContextState.value) {\n    accounts.instructionsSysvarOrContextState.value =\n      'Sysvar1nstructions1111111111111111111111111' as Address<'Sysvar1nstructions1111111111111111111111111'>;\n  }\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.instructionsSysvarOrContextState),\n      getAccountMeta(accounts.record),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getConfigureConfidentialTransferAccountInstructionDataEncoder().encode(\n      args as ConfigureConfidentialTransferAccountInstructionDataArgs\n    ),\n  } as ConfigureConfidentialTransferAccountInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountMint,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedConfigureConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /**\n     * Instructions sysvar if `VerifyPubkeyValidity` is included in\n     * the same transaction or context state account if\n     * `VerifyPubkeyValidity` is pre-verified into a context state\n     * account.\n     */\n\n    instructionsSysvarOrContextState: TAccountMetas[2];\n    /** (Optional) Record account if the accompanying proof is to be read from a record account. */\n    record?: TAccountMetas[3] | undefined;\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[4];\n  };\n  data: ConfigureConfidentialTransferAccountInstructionData;\n};\n\nexport function parseConfigureConfidentialTransferAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedConfigureConfidentialTransferAccountInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      mint: getNextAccount(),\n      instructionsSysvarOrContextState: getNextAccount(),\n      record: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getConfigureConfidentialTransferAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  getAddressEncoder,\n  getProgramDerivedAddress,\n  type Address,\n  type ProgramDerivedAddress,\n} from '@solana/kit';\n\nexport type AssociatedTokenSeeds = {\n  /** The wallet address of the associated token account. */\n  owner: Address;\n  /** The address of the token program to use. */\n  tokenProgram: Address;\n  /** The mint address of the associated token account. */\n  mint: Address;\n};\n\nexport async function findAssociatedTokenPda(\n  seeds: AssociatedTokenSeeds,\n  config: { programAddress?: Address | undefined } = {}\n): Promise<ProgramDerivedAddress> {\n  const {\n    programAddress = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>,\n  } = config;\n  return await getProgramDerivedAddress({\n    programAddress,\n    seeds: [\n      getAddressEncoder().encode(seeds.owner),\n      getAddressEncoder().encode(seeds.tokenProgram),\n      getAddressEncoder().encode(seeds.mint),\n    ],\n  });\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { findAssociatedTokenPda } from '../pdas';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport {\n  expectAddress,\n  getAccountMetaFactory,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR = 0;\n\nexport function getCreateAssociatedTokenDiscriminatorBytes() {\n  return getU8Encoder().encode(CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR);\n}\n\nexport type CreateAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountAta extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountAta extends string ? WritableAccount<TAccountAta> : TAccountAta,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAssociatedTokenInstructionData = { discriminator: number };\n\nexport type CreateAssociatedTokenInstructionDataArgs = {};\n\nexport function getCreateAssociatedTokenInstructionDataEncoder(): Encoder<CreateAssociatedTokenInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getCreateAssociatedTokenInstructionDataDecoder(): Decoder<CreateAssociatedTokenInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCreateAssociatedTokenInstructionDataCodec(): Codec<\n  CreateAssociatedTokenInstructionDataArgs,\n  CreateAssociatedTokenInstructionData\n> {\n  return combineCodec(\n    getCreateAssociatedTokenInstructionDataEncoder(),\n    getCreateAssociatedTokenInstructionDataDecoder()\n  );\n}\n\nexport type CreateAssociatedTokenAsyncInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata?: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport async function getCreateAssociatedTokenInstructionAsync<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenAsyncInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): Promise<\n  CreateAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n  if (!accounts.ata.value) {\n    accounts.ata.value = await findAssociatedTokenPda({\n      owner: expectAddress(accounts.owner.value),\n      tokenProgram: expectAddress(accounts.tokenProgram.value),\n      mint: expectAddress(accounts.mint.value),\n    });\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getCreateAssociatedTokenInstructionDataEncoder().encode({}),\n  } as CreateAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type CreateAssociatedTokenInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getCreateAssociatedTokenInstruction<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateAssociatedTokenInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountAta,\n  TAccountOwner,\n  TAccountMint,\n  TAccountSystemProgram,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getCreateAssociatedTokenInstructionDataEncoder().encode({}),\n  } as CreateAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCreateAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Funding account (must be a system account). */\n    payer: TAccountMetas[0];\n    /** Associated token account address to be created. */\n    ata: TAccountMetas[1];\n    /** Wallet address for the new associated token account. */\n    owner: TAccountMetas[2];\n    /** The token mint for the new associated token account. */\n    mint: TAccountMetas[3];\n    /** System program. */\n    systemProgram: TAccountMetas[4];\n    /** SPL Token program. */\n    tokenProgram: TAccountMetas[5];\n  };\n  data: CreateAssociatedTokenInstructionData;\n};\n\nexport function parseCreateAssociatedTokenInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCreateAssociatedTokenInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      ata: getNextAccount(),\n      owner: getNextAccount(),\n      mint: getNextAccount(),\n      systemProgram: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getCreateAssociatedTokenInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { findAssociatedTokenPda } from '../pdas';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport {\n  expectAddress,\n  getAccountMetaFactory,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR = 1;\n\nexport function getCreateAssociatedTokenIdempotentDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR\n  );\n}\n\nexport type CreateAssociatedTokenIdempotentInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountAta extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountAta extends string ? WritableAccount<TAccountAta> : TAccountAta,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAssociatedTokenIdempotentInstructionData = {\n  discriminator: number;\n};\n\nexport type CreateAssociatedTokenIdempotentInstructionDataArgs = {};\n\nexport function getCreateAssociatedTokenIdempotentInstructionDataEncoder(): Encoder<CreateAssociatedTokenIdempotentInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getCreateAssociatedTokenIdempotentInstructionDataDecoder(): Decoder<CreateAssociatedTokenIdempotentInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCreateAssociatedTokenIdempotentInstructionDataCodec(): Codec<\n  CreateAssociatedTokenIdempotentInstructionDataArgs,\n  CreateAssociatedTokenIdempotentInstructionData\n> {\n  return combineCodec(\n    getCreateAssociatedTokenIdempotentInstructionDataEncoder(),\n    getCreateAssociatedTokenIdempotentInstructionDataDecoder()\n  );\n}\n\nexport type CreateAssociatedTokenIdempotentAsyncInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata?: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport async function getCreateAssociatedTokenIdempotentInstructionAsync<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenIdempotentAsyncInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): Promise<\n  CreateAssociatedTokenIdempotentInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n  if (!accounts.ata.value) {\n    accounts.ata.value = await findAssociatedTokenPda({\n      owner: expectAddress(accounts.owner.value),\n      tokenProgram: expectAddress(accounts.tokenProgram.value),\n      mint: expectAddress(accounts.mint.value),\n    });\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getCreateAssociatedTokenIdempotentInstructionDataEncoder().encode({}),\n  } as CreateAssociatedTokenIdempotentInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type CreateAssociatedTokenIdempotentInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getCreateAssociatedTokenIdempotentInstruction<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenIdempotentInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateAssociatedTokenIdempotentInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountAta,\n  TAccountOwner,\n  TAccountMint,\n  TAccountSystemProgram,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getCreateAssociatedTokenIdempotentInstructionDataEncoder().encode({}),\n  } as CreateAssociatedTokenIdempotentInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCreateAssociatedTokenIdempotentInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Funding account (must be a system account). */\n    payer: TAccountMetas[0];\n    /** Associated token account address to be created. */\n    ata: TAccountMetas[1];\n    /** Wallet address for the new associated token account. */\n    owner: TAccountMetas[2];\n    /** The token mint for the new associated token account. */\n    mint: TAccountMetas[3];\n    /** System program. */\n    systemProgram: TAccountMetas[4];\n    /** SPL Token program. */\n    tokenProgram: TAccountMetas[5];\n  };\n  data: CreateAssociatedTokenIdempotentInstructionData;\n};\n\nexport function parseCreateAssociatedTokenIdempotentInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCreateAssociatedTokenIdempotentInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      ata: getNextAccount(),\n      owner: getNextAccount(),\n      mint: getNextAccount(),\n      systemProgram: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getCreateAssociatedTokenIdempotentInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CREATE_NATIVE_MINT_DISCRIMINATOR = 31;\n\nexport function getCreateNativeMintDiscriminatorBytes() {\n  return getU8Encoder().encode(CREATE_NATIVE_MINT_DISCRIMINATOR);\n}\n\nexport type CreateNativeMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountNativeMint extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountNativeMint extends string\n        ? WritableAccount<TAccountNativeMint>\n        : TAccountNativeMint,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateNativeMintInstructionData = { discriminator: number };\n\nexport type CreateNativeMintInstructionDataArgs = {};\n\nexport function getCreateNativeMintInstructionDataEncoder(): Encoder<CreateNativeMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: CREATE_NATIVE_MINT_DISCRIMINATOR })\n  );\n}\n\nexport function getCreateNativeMintInstructionDataDecoder(): Decoder<CreateNativeMintInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCreateNativeMintInstructionDataCodec(): Codec<\n  CreateNativeMintInstructionDataArgs,\n  CreateNativeMintInstructionData\n> {\n  return combineCodec(\n    getCreateNativeMintInstructionDataEncoder(),\n    getCreateNativeMintInstructionDataDecoder()\n  );\n}\n\nexport type CreateNativeMintInput<\n  TAccountPayer extends string = string,\n  TAccountNativeMint extends string = string,\n  TAccountSystemProgram extends string = string,\n> = {\n  /** Funding account (must be a system account) */\n  payer: TransactionSigner<TAccountPayer>;\n  /** The native mint address */\n  nativeMint: Address<TAccountNativeMint>;\n  /** System program for mint account funding */\n  systemProgram?: Address<TAccountSystemProgram>;\n};\n\nexport function getCreateNativeMintInstruction<\n  TAccountPayer extends string,\n  TAccountNativeMint extends string,\n  TAccountSystemProgram extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: CreateNativeMintInput<\n    TAccountPayer,\n    TAccountNativeMint,\n    TAccountSystemProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateNativeMintInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountNativeMint,\n  TAccountSystemProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    nativeMint: { value: input.nativeMint ?? null, isWritable: true },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.nativeMint),\n      getAccountMeta(accounts.systemProgram),\n    ],\n    programAddress,\n    data: getCreateNativeMintInstructionDataEncoder().encode({}),\n  } as CreateNativeMintInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountNativeMint,\n    TAccountSystemProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCreateNativeMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Funding account (must be a system account) */\n    payer: TAccountMetas[0];\n    /** The native mint address */\n    nativeMint: TAccountMetas[1];\n    /** System program for mint account funding */\n    systemProgram: TAccountMetas[2];\n  };\n  data: CreateNativeMintInstructionData;\n};\n\nexport function parseCreateNativeMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCreateNativeMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      nativeMint: getNextAccount(),\n      systemProgram: getNextAccount(),\n    },\n    data: getCreateNativeMintInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DISABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;\n\nexport function getDisableConfidentialCreditsDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR);\n}\n\nexport const DISABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 10;\n\nexport function getDisableConfidentialCreditsConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    DISABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type DisableConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DisableConfidentialCreditsInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n};\n\nexport type DisableConfidentialCreditsInstructionDataArgs = {};\n\nexport function getDisableConfidentialCreditsInstructionDataEncoder(): Encoder<DisableConfidentialCreditsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        DISABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDisableConfidentialCreditsInstructionDataDecoder(): Decoder<DisableConfidentialCreditsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getDisableConfidentialCreditsInstructionDataCodec(): Codec<\n  DisableConfidentialCreditsInstructionDataArgs,\n  DisableConfidentialCreditsInstructionData\n> {\n  return combineCodec(\n    getDisableConfidentialCreditsInstructionDataEncoder(),\n    getDisableConfidentialCreditsInstructionDataDecoder()\n  );\n}\n\nexport type DisableConfidentialCreditsInput<\n  TAccountToken extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getDisableConfidentialCreditsInstruction<\n  TAccountToken extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: DisableConfidentialCreditsInput<TAccountToken, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): DisableConfidentialCreditsInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getDisableConfidentialCreditsInstructionDataEncoder().encode({}),\n  } as DisableConfidentialCreditsInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedDisableConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[1];\n  };\n  data: DisableConfidentialCreditsInstructionData;\n};\n\nexport function parseDisableConfidentialCreditsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedDisableConfidentialCreditsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getDisableConfidentialCreditsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DISABLE_CPI_GUARD_DISCRIMINATOR = 34;\n\nexport function getDisableCpiGuardDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_CPI_GUARD_DISCRIMINATOR);\n}\n\nexport const DISABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR = 1;\n\nexport function getDisableCpiGuardCpiGuardDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR);\n}\n\nexport type DisableCpiGuardInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DisableCpiGuardInstructionData = {\n  discriminator: number;\n  cpiGuardDiscriminator: number;\n};\n\nexport type DisableCpiGuardInstructionDataArgs = {};\n\nexport function getDisableCpiGuardInstructionDataEncoder(): Encoder<DisableCpiGuardInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['cpiGuardDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_CPI_GUARD_DISCRIMINATOR,\n      cpiGuardDiscriminator: DISABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDisableCpiGuardInstructionDataDecoder(): Decoder<DisableCpiGuardInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['cpiGuardDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getDisableCpiGuardInstructionDataCodec(): Codec<\n  DisableCpiGuardInstructionDataArgs,\n  DisableCpiGuardInstructionData\n> {\n  return combineCodec(\n    getDisableCpiGuardInstructionDataEncoder(),\n    getDisableCpiGuardInstructionDataDecoder()\n  );\n}\n\nexport type DisableCpiGuardInput<\n  TAccountToken extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The token account to update. */\n  token: Address<TAccountToken>;\n  /** The account's owner/delegate or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getDisableCpiGuardInstruction<\n  TAccountToken extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: DisableCpiGuardInput<TAccountToken, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): DisableCpiGuardInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getDisableCpiGuardInstructionDataEncoder().encode({}),\n  } as DisableCpiGuardInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedDisableCpiGuardInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token account to update. */\n    token: TAccountMetas[0];\n    /** The account's owner/delegate or its multisignature account. */\n    owner: TAccountMetas[1];\n  };\n  data: DisableCpiGuardInstructionData;\n};\n\nexport function parseDisableCpiGuardInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedDisableCpiGuardInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getDisableCpiGuardInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DISABLE_HARVEST_TO_MINT_DISCRIMINATOR = 37;\n\nexport function getDisableHarvestToMintDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_HARVEST_TO_MINT_DISCRIMINATOR);\n}\n\nexport const DISABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 5;\n\nexport function getDisableHarvestToMintConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    DISABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type DisableHarvestToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DisableHarvestToMintInstructionData = {\n  discriminator: number;\n  confidentialTransferFeeDiscriminator: number;\n};\n\nexport type DisableHarvestToMintInstructionDataArgs = {};\n\nexport function getDisableHarvestToMintInstructionDataEncoder(): Encoder<DisableHarvestToMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_HARVEST_TO_MINT_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        DISABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDisableHarvestToMintInstructionDataDecoder(): Decoder<DisableHarvestToMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getDisableHarvestToMintInstructionDataCodec(): Codec<\n  DisableHarvestToMintInstructionDataArgs,\n  DisableHarvestToMintInstructionData\n> {\n  return combineCodec(\n    getDisableHarvestToMintInstructionDataEncoder(),\n    getDisableHarvestToMintInstructionDataDecoder()\n  );\n}\n\nexport type DisableHarvestToMintInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The confidential transfer fee authority */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getDisableHarvestToMintInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: DisableHarvestToMintInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): DisableHarvestToMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getDisableHarvestToMintInstructionDataEncoder().encode({}),\n  } as DisableHarvestToMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedDisableHarvestToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. */\n    mint: TAccountMetas[0];\n    /** The confidential transfer fee authority */\n    authority: TAccountMetas[1];\n  };\n  data: DisableHarvestToMintInstructionData;\n};\n\nexport function parseDisableHarvestToMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedDisableHarvestToMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getDisableHarvestToMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DISABLE_MEMO_TRANSFERS_DISCRIMINATOR = 30;\n\nexport function getDisableMemoTransfersDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_MEMO_TRANSFERS_DISCRIMINATOR);\n}\n\nexport const DISABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR = 1;\n\nexport function getDisableMemoTransfersMemoTransfersDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    DISABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR\n  );\n}\n\nexport type DisableMemoTransfersInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DisableMemoTransfersInstructionData = {\n  discriminator: number;\n  memoTransfersDiscriminator: number;\n};\n\nexport type DisableMemoTransfersInstructionDataArgs = {};\n\nexport function getDisableMemoTransfersInstructionDataEncoder(): Encoder<DisableMemoTransfersInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['memoTransfersDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_MEMO_TRANSFERS_DISCRIMINATOR,\n      memoTransfersDiscriminator:\n        DISABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDisableMemoTransfersInstructionDataDecoder(): Decoder<DisableMemoTransfersInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['memoTransfersDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getDisableMemoTransfersInstructionDataCodec(): Codec<\n  DisableMemoTransfersInstructionDataArgs,\n  DisableMemoTransfersInstructionData\n> {\n  return combineCodec(\n    getDisableMemoTransfersInstructionDataEncoder(),\n    getDisableMemoTransfersInstructionDataDecoder()\n  );\n}\n\nexport type DisableMemoTransfersInput<\n  TAccountToken extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The token account to update. */\n  token: Address<TAccountToken>;\n  /** The account's owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getDisableMemoTransfersInstruction<\n  TAccountToken extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: DisableMemoTransfersInput<TAccountToken, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): DisableMemoTransfersInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getDisableMemoTransfersInstructionDataEncoder().encode({}),\n  } as DisableMemoTransfersInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedDisableMemoTransfersInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token account to update. */\n    token: TAccountMetas[0];\n    /** The account's owner or its multisignature account. */\n    owner: TAccountMetas[1];\n  };\n  data: DisableMemoTransfersInstructionData;\n};\n\nexport function parseDisableMemoTransfersInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedDisableMemoTransfersInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getDisableMemoTransfersInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DISABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;\n\nexport function getDisableNonConfidentialCreditsDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR);\n}\n\nexport const DISABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 12;\n\nexport function getDisableNonConfidentialCreditsConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    DISABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type DisableNonConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DisableNonConfidentialCreditsInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n};\n\nexport type DisableNonConfidentialCreditsInstructionDataArgs = {};\n\nexport function getDisableNonConfidentialCreditsInstructionDataEncoder(): Encoder<DisableNonConfidentialCreditsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        DISABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDisableNonConfidentialCreditsInstructionDataDecoder(): Decoder<DisableNonConfidentialCreditsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getDisableNonConfidentialCreditsInstructionDataCodec(): Codec<\n  DisableNonConfidentialCreditsInstructionDataArgs,\n  DisableNonConfidentialCreditsInstructionData\n> {\n  return combineCodec(\n    getDisableNonConfidentialCreditsInstructionDataEncoder(),\n    getDisableNonConfidentialCreditsInstructionDataDecoder()\n  );\n}\n\nexport type DisableNonConfidentialCreditsInput<\n  TAccountToken extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getDisableNonConfidentialCreditsInstruction<\n  TAccountToken extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: DisableNonConfidentialCreditsInput<TAccountToken, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): DisableNonConfidentialCreditsInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getDisableNonConfidentialCreditsInstructionDataEncoder().encode({}),\n  } as DisableNonConfidentialCreditsInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedDisableNonConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[1];\n  };\n  data: DisableNonConfidentialCreditsInstructionData;\n};\n\nexport function parseDisableNonConfidentialCreditsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedDisableNonConfidentialCreditsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getDisableNonConfidentialCreditsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  none,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const EMIT_TOKEN_METADATA_DISCRIMINATOR = new Uint8Array([\n  250, 166, 180, 250, 13, 12, 184, 70,\n]);\n\nexport function getEmitTokenMetadataDiscriminatorBytes() {\n  return getBytesEncoder().encode(EMIT_TOKEN_METADATA_DISCRIMINATOR);\n}\n\nexport type EmitTokenMetadataInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMetadata extends string\n        ? ReadonlyAccount<TAccountMetadata>\n        : TAccountMetadata,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EmitTokenMetadataInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** Start of range of data to emit */\n  start: Option<bigint>;\n  /** End of range of data to emit */\n  end: Option<bigint>;\n};\n\nexport type EmitTokenMetadataInstructionDataArgs = {\n  /** Start of range of data to emit */\n  start?: OptionOrNullable<number | bigint>;\n  /** End of range of data to emit */\n  end?: OptionOrNullable<number | bigint>;\n};\n\nexport function getEmitTokenMetadataInstructionDataEncoder(): Encoder<EmitTokenMetadataInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      ['start', getOptionEncoder(getU64Encoder())],\n      ['end', getOptionEncoder(getU64Encoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: EMIT_TOKEN_METADATA_DISCRIMINATOR,\n      start: value.start ?? none(),\n      end: value.end ?? none(),\n    })\n  );\n}\n\nexport function getEmitTokenMetadataInstructionDataDecoder(): Decoder<EmitTokenMetadataInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    ['start', getOptionDecoder(getU64Decoder())],\n    ['end', getOptionDecoder(getU64Decoder())],\n  ]);\n}\n\nexport function getEmitTokenMetadataInstructionDataCodec(): Codec<\n  EmitTokenMetadataInstructionDataArgs,\n  EmitTokenMetadataInstructionData\n> {\n  return combineCodec(\n    getEmitTokenMetadataInstructionDataEncoder(),\n    getEmitTokenMetadataInstructionDataDecoder()\n  );\n}\n\nexport type EmitTokenMetadataInput<TAccountMetadata extends string = string> = {\n  metadata: Address<TAccountMetadata>;\n  start?: EmitTokenMetadataInstructionDataArgs['start'];\n  end?: EmitTokenMetadataInstructionDataArgs['end'];\n};\n\nexport function getEmitTokenMetadataInstruction<\n  TAccountMetadata extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EmitTokenMetadataInput<TAccountMetadata>,\n  config?: { programAddress?: TProgramAddress }\n): EmitTokenMetadataInstruction<TProgramAddress, TAccountMetadata> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.metadata)],\n    programAddress,\n    data: getEmitTokenMetadataInstructionDataEncoder().encode(\n      args as EmitTokenMetadataInstructionDataArgs\n    ),\n  } as EmitTokenMetadataInstruction<TProgramAddress, TAccountMetadata>;\n\n  return instruction;\n}\n\nexport type ParsedEmitTokenMetadataInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    metadata: TAccountMetas[0];\n  };\n  data: EmitTokenMetadataInstructionData;\n};\n\nexport function parseEmitTokenMetadataInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedEmitTokenMetadataInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      metadata: getNextAccount(),\n    },\n    data: getEmitTokenMetadataInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR = 27;\n\nexport function getEmptyConfidentialTransferAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR\n  );\n}\n\nexport const EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 4;\n\nexport function getEmptyConfidentialTransferAccountConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type EmptyConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountInstructionsSysvarOrContextState extends\n    | string\n    | IAccountMeta<string> = 'Sysvar1nstructions1111111111111111111111111',\n  TAccountRecord extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountInstructionsSysvarOrContextState extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvarOrContextState>\n        : TAccountInstructionsSysvarOrContextState,\n      TAccountRecord extends string\n        ? ReadonlyAccount<TAccountRecord>\n        : TAccountRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EmptyConfidentialTransferAccountInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /**\n   * Relative location of the `ProofInstruction::VerifyCloseAccount`\n   * instruction to the `EmptyAccount` instruction in the transaction. If\n   * the offset is `0`, then use a context state account for the proof.\n   */\n  proofInstructionOffset: number;\n};\n\nexport type EmptyConfidentialTransferAccountInstructionDataArgs = {\n  /**\n   * Relative location of the `ProofInstruction::VerifyCloseAccount`\n   * instruction to the `EmptyAccount` instruction in the transaction. If\n   * the offset is `0`, then use a context state account for the proof.\n   */\n  proofInstructionOffset: number;\n};\n\nexport function getEmptyConfidentialTransferAccountInstructionDataEncoder(): Encoder<EmptyConfidentialTransferAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['proofInstructionOffset', getI8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEmptyConfidentialTransferAccountInstructionDataDecoder(): Decoder<EmptyConfidentialTransferAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['proofInstructionOffset', getI8Decoder()],\n  ]);\n}\n\nexport function getEmptyConfidentialTransferAccountInstructionDataCodec(): Codec<\n  EmptyConfidentialTransferAccountInstructionDataArgs,\n  EmptyConfidentialTransferAccountInstructionData\n> {\n  return combineCodec(\n    getEmptyConfidentialTransferAccountInstructionDataEncoder(),\n    getEmptyConfidentialTransferAccountInstructionDataDecoder()\n  );\n}\n\nexport type EmptyConfidentialTransferAccountInput<\n  TAccountToken extends string = string,\n  TAccountInstructionsSysvarOrContextState extends string = string,\n  TAccountRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /**\n   * Instructions sysvar if `VerifyZeroCiphertext` is included in\n   * the same transaction or context state account if\n   * `VerifyZeroCiphertext` is pre-verified into a context state\n   * account.\n   */\n  instructionsSysvarOrContextState?: Address<TAccountInstructionsSysvarOrContextState>;\n  /** (Optional) Record account if the accompanying proof is to be read from a record account. */\n  record?: Address<TAccountRecord>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  proofInstructionOffset: EmptyConfidentialTransferAccountInstructionDataArgs['proofInstructionOffset'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEmptyConfidentialTransferAccountInstruction<\n  TAccountToken extends string,\n  TAccountInstructionsSysvarOrContextState extends string,\n  TAccountRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EmptyConfidentialTransferAccountInput<\n    TAccountToken,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): EmptyConfidentialTransferAccountInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountInstructionsSysvarOrContextState,\n  TAccountRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    instructionsSysvarOrContextState: {\n      value: input.instructionsSysvarOrContextState ?? null,\n      isWritable: false,\n    },\n    record: { value: input.record ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.instructionsSysvarOrContextState.value) {\n    accounts.instructionsSysvarOrContextState.value =\n      'Sysvar1nstructions1111111111111111111111111' as Address<'Sysvar1nstructions1111111111111111111111111'>;\n  }\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.instructionsSysvarOrContextState),\n      getAccountMeta(accounts.record),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getEmptyConfidentialTransferAccountInstructionDataEncoder().encode(\n      args as EmptyConfidentialTransferAccountInstructionDataArgs\n    ),\n  } as EmptyConfidentialTransferAccountInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedEmptyConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /**\n     * Instructions sysvar if `VerifyZeroCiphertext` is included in\n     * the same transaction or context state account if\n     * `VerifyZeroCiphertext` is pre-verified into a context state\n     * account.\n     */\n\n    instructionsSysvarOrContextState: TAccountMetas[1];\n    /** (Optional) Record account if the accompanying proof is to be read from a record account. */\n    record?: TAccountMetas[2] | undefined;\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[3];\n  };\n  data: EmptyConfidentialTransferAccountInstructionData;\n};\n\nexport function parseEmptyConfidentialTransferAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedEmptyConfidentialTransferAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      instructionsSysvarOrContextState: getNextAccount(),\n      record: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getEmptyConfidentialTransferAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ENABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;\n\nexport function getEnableConfidentialCreditsDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR);\n}\n\nexport const ENABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 9;\n\nexport function getEnableConfidentialCreditsConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    ENABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type EnableConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EnableConfidentialCreditsInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n};\n\nexport type EnableConfidentialCreditsInstructionDataArgs = {};\n\nexport function getEnableConfidentialCreditsInstructionDataEncoder(): Encoder<EnableConfidentialCreditsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        ENABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEnableConfidentialCreditsInstructionDataDecoder(): Decoder<EnableConfidentialCreditsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getEnableConfidentialCreditsInstructionDataCodec(): Codec<\n  EnableConfidentialCreditsInstructionDataArgs,\n  EnableConfidentialCreditsInstructionData\n> {\n  return combineCodec(\n    getEnableConfidentialCreditsInstructionDataEncoder(),\n    getEnableConfidentialCreditsInstructionDataDecoder()\n  );\n}\n\nexport type EnableConfidentialCreditsInput<\n  TAccountToken extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEnableConfidentialCreditsInstruction<\n  TAccountToken extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EnableConfidentialCreditsInput<TAccountToken, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): EnableConfidentialCreditsInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getEnableConfidentialCreditsInstructionDataEncoder().encode({}),\n  } as EnableConfidentialCreditsInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedEnableConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[1];\n  };\n  data: EnableConfidentialCreditsInstructionData;\n};\n\nexport function parseEnableConfidentialCreditsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedEnableConfidentialCreditsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getEnableConfidentialCreditsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ENABLE_CPI_GUARD_DISCRIMINATOR = 34;\n\nexport function getEnableCpiGuardDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_CPI_GUARD_DISCRIMINATOR);\n}\n\nexport const ENABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR = 0;\n\nexport function getEnableCpiGuardCpiGuardDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR);\n}\n\nexport type EnableCpiGuardInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EnableCpiGuardInstructionData = {\n  discriminator: number;\n  cpiGuardDiscriminator: number;\n};\n\nexport type EnableCpiGuardInstructionDataArgs = {};\n\nexport function getEnableCpiGuardInstructionDataEncoder(): Encoder<EnableCpiGuardInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['cpiGuardDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_CPI_GUARD_DISCRIMINATOR,\n      cpiGuardDiscriminator: ENABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEnableCpiGuardInstructionDataDecoder(): Decoder<EnableCpiGuardInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['cpiGuardDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getEnableCpiGuardInstructionDataCodec(): Codec<\n  EnableCpiGuardInstructionDataArgs,\n  EnableCpiGuardInstructionData\n> {\n  return combineCodec(\n    getEnableCpiGuardInstructionDataEncoder(),\n    getEnableCpiGuardInstructionDataDecoder()\n  );\n}\n\nexport type EnableCpiGuardInput<\n  TAccountToken extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The token account to update. */\n  token: Address<TAccountToken>;\n  /** The account's owner/delegate or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEnableCpiGuardInstruction<\n  TAccountToken extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EnableCpiGuardInput<TAccountToken, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): EnableCpiGuardInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getEnableCpiGuardInstructionDataEncoder().encode({}),\n  } as EnableCpiGuardInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedEnableCpiGuardInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token account to update. */\n    token: TAccountMetas[0];\n    /** The account's owner/delegate or its multisignature account. */\n    owner: TAccountMetas[1];\n  };\n  data: EnableCpiGuardInstructionData;\n};\n\nexport function parseEnableCpiGuardInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedEnableCpiGuardInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getEnableCpiGuardInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ENABLE_HARVEST_TO_MINT_DISCRIMINATOR = 37;\n\nexport function getEnableHarvestToMintDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_HARVEST_TO_MINT_DISCRIMINATOR);\n}\n\nexport const ENABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 4;\n\nexport function getEnableHarvestToMintConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    ENABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type EnableHarvestToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EnableHarvestToMintInstructionData = {\n  discriminator: number;\n  confidentialTransferFeeDiscriminator: number;\n};\n\nexport type EnableHarvestToMintInstructionDataArgs = {};\n\nexport function getEnableHarvestToMintInstructionDataEncoder(): Encoder<EnableHarvestToMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_HARVEST_TO_MINT_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        ENABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEnableHarvestToMintInstructionDataDecoder(): Decoder<EnableHarvestToMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getEnableHarvestToMintInstructionDataCodec(): Codec<\n  EnableHarvestToMintInstructionDataArgs,\n  EnableHarvestToMintInstructionData\n> {\n  return combineCodec(\n    getEnableHarvestToMintInstructionDataEncoder(),\n    getEnableHarvestToMintInstructionDataDecoder()\n  );\n}\n\nexport type EnableHarvestToMintInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The confidential transfer fee authority */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEnableHarvestToMintInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EnableHarvestToMintInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): EnableHarvestToMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getEnableHarvestToMintInstructionDataEncoder().encode({}),\n  } as EnableHarvestToMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedEnableHarvestToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. */\n    mint: TAccountMetas[0];\n    /** The confidential transfer fee authority */\n    authority: TAccountMetas[1];\n  };\n  data: EnableHarvestToMintInstructionData;\n};\n\nexport function parseEnableHarvestToMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedEnableHarvestToMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getEnableHarvestToMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ENABLE_MEMO_TRANSFERS_DISCRIMINATOR = 30;\n\nexport function getEnableMemoTransfersDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_MEMO_TRANSFERS_DISCRIMINATOR);\n}\n\nexport const ENABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR = 0;\n\nexport function getEnableMemoTransfersMemoTransfersDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    ENABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR\n  );\n}\n\nexport type EnableMemoTransfersInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EnableMemoTransfersInstructionData = {\n  discriminator: number;\n  memoTransfersDiscriminator: number;\n};\n\nexport type EnableMemoTransfersInstructionDataArgs = {};\n\nexport function getEnableMemoTransfersInstructionDataEncoder(): Encoder<EnableMemoTransfersInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['memoTransfersDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_MEMO_TRANSFERS_DISCRIMINATOR,\n      memoTransfersDiscriminator:\n        ENABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEnableMemoTransfersInstructionDataDecoder(): Decoder<EnableMemoTransfersInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['memoTransfersDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getEnableMemoTransfersInstructionDataCodec(): Codec<\n  EnableMemoTransfersInstructionDataArgs,\n  EnableMemoTransfersInstructionData\n> {\n  return combineCodec(\n    getEnableMemoTransfersInstructionDataEncoder(),\n    getEnableMemoTransfersInstructionDataDecoder()\n  );\n}\n\nexport type EnableMemoTransfersInput<\n  TAccountToken extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The token account to update. */\n  token: Address<TAccountToken>;\n  /** The account's owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEnableMemoTransfersInstruction<\n  TAccountToken extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EnableMemoTransfersInput<TAccountToken, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): EnableMemoTransfersInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getEnableMemoTransfersInstructionDataEncoder().encode({}),\n  } as EnableMemoTransfersInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedEnableMemoTransfersInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token account to update. */\n    token: TAccountMetas[0];\n    /** The account's owner or its multisignature account. */\n    owner: TAccountMetas[1];\n  };\n  data: EnableMemoTransfersInstructionData;\n};\n\nexport function parseEnableMemoTransfersInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedEnableMemoTransfersInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getEnableMemoTransfersInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ENABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;\n\nexport function getEnableNonConfidentialCreditsDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR);\n}\n\nexport const ENABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 11;\n\nexport function getEnableNonConfidentialCreditsConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    ENABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type EnableNonConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EnableNonConfidentialCreditsInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n};\n\nexport type EnableNonConfidentialCreditsInstructionDataArgs = {};\n\nexport function getEnableNonConfidentialCreditsInstructionDataEncoder(): Encoder<EnableNonConfidentialCreditsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        ENABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEnableNonConfidentialCreditsInstructionDataDecoder(): Decoder<EnableNonConfidentialCreditsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getEnableNonConfidentialCreditsInstructionDataCodec(): Codec<\n  EnableNonConfidentialCreditsInstructionDataArgs,\n  EnableNonConfidentialCreditsInstructionData\n> {\n  return combineCodec(\n    getEnableNonConfidentialCreditsInstructionDataEncoder(),\n    getEnableNonConfidentialCreditsInstructionDataDecoder()\n  );\n}\n\nexport type EnableNonConfidentialCreditsInput<\n  TAccountToken extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEnableNonConfidentialCreditsInstruction<\n  TAccountToken extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EnableNonConfidentialCreditsInput<TAccountToken, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): EnableNonConfidentialCreditsInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getEnableNonConfidentialCreditsInstructionDataEncoder().encode({}),\n  } as EnableNonConfidentialCreditsInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedEnableNonConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[1];\n  };\n  data: EnableNonConfidentialCreditsInstructionData;\n};\n\nexport function parseEnableNonConfidentialCreditsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedEnableNonConfidentialCreditsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getEnableNonConfidentialCreditsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const FREEZE_ACCOUNT_DISCRIMINATOR = 10;\n\nexport function getFreezeAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(FREEZE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type FreezeAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type FreezeAccountInstructionData = { discriminator: number };\n\nexport type FreezeAccountInstructionDataArgs = {};\n\nexport function getFreezeAccountInstructionDataEncoder(): Encoder<FreezeAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: FREEZE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getFreezeAccountInstructionDataDecoder(): Decoder<FreezeAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getFreezeAccountInstructionDataCodec(): Codec<\n  FreezeAccountInstructionDataArgs,\n  FreezeAccountInstructionData\n> {\n  return combineCodec(\n    getFreezeAccountInstructionDataEncoder(),\n    getFreezeAccountInstructionDataDecoder()\n  );\n}\n\nexport type FreezeAccountInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The account to freeze. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The mint freeze authority or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getFreezeAccountInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: FreezeAccountInput<TAccountAccount, TAccountMint, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): FreezeAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getFreezeAccountInstructionDataEncoder().encode({}),\n  } as FreezeAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedFreezeAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to freeze. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The mint freeze authority or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: FreezeAccountInstructionData;\n};\n\nexport function parseFreezeAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedFreezeAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getFreezeAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR = 21;\n\nexport function getGetAccountDataSizeDiscriminatorBytes() {\n  return getU8Encoder().encode(GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR);\n}\n\nexport type GetAccountDataSizeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type GetAccountDataSizeInstructionData = { discriminator: number };\n\nexport type GetAccountDataSizeInstructionDataArgs = {};\n\nexport function getGetAccountDataSizeInstructionDataEncoder(): Encoder<GetAccountDataSizeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getGetAccountDataSizeInstructionDataDecoder(): Decoder<GetAccountDataSizeInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getGetAccountDataSizeInstructionDataCodec(): Codec<\n  GetAccountDataSizeInstructionDataArgs,\n  GetAccountDataSizeInstructionData\n> {\n  return combineCodec(\n    getGetAccountDataSizeInstructionDataEncoder(),\n    getGetAccountDataSizeInstructionDataDecoder()\n  );\n}\n\nexport type GetAccountDataSizeInput<TAccountMint extends string = string> = {\n  /** The mint to calculate for. */\n  mint: Address<TAccountMint>;\n};\n\nexport function getGetAccountDataSizeInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: GetAccountDataSizeInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): GetAccountDataSizeInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getGetAccountDataSizeInstructionDataEncoder().encode({}),\n  } as GetAccountDataSizeInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedGetAccountDataSizeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to calculate for. */\n    mint: TAccountMetas[0];\n  };\n  data: GetAccountDataSizeInstructionData;\n};\n\nexport function parseGetAccountDataSizeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedGetAccountDataSizeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getGetAccountDataSizeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const HARVEST_WITHHELD_TOKENS_TO_MINT_DISCRIMINATOR = 26;\n\nexport function getHarvestWithheldTokensToMintDiscriminatorBytes() {\n  return getU8Encoder().encode(HARVEST_WITHHELD_TOKENS_TO_MINT_DISCRIMINATOR);\n}\n\nexport const HARVEST_WITHHELD_TOKENS_TO_MINT_TRANSFER_FEE_DISCRIMINATOR = 4;\n\nexport function getHarvestWithheldTokensToMintTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    HARVEST_WITHHELD_TOKENS_TO_MINT_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type HarvestWithheldTokensToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type HarvestWithheldTokensToMintInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n};\n\nexport type HarvestWithheldTokensToMintInstructionDataArgs = {};\n\nexport function getHarvestWithheldTokensToMintInstructionDataEncoder(): Encoder<HarvestWithheldTokensToMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: HARVEST_WITHHELD_TOKENS_TO_MINT_DISCRIMINATOR,\n      transferFeeDiscriminator:\n        HARVEST_WITHHELD_TOKENS_TO_MINT_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getHarvestWithheldTokensToMintInstructionDataDecoder(): Decoder<HarvestWithheldTokensToMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getHarvestWithheldTokensToMintInstructionDataCodec(): Codec<\n  HarvestWithheldTokensToMintInstructionDataArgs,\n  HarvestWithheldTokensToMintInstructionData\n> {\n  return combineCodec(\n    getHarvestWithheldTokensToMintInstructionDataEncoder(),\n    getHarvestWithheldTokensToMintInstructionDataDecoder()\n  );\n}\n\nexport type HarvestWithheldTokensToMintInput<\n  TAccountMint extends string = string,\n> = {\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  sources: Array<Address>;\n};\n\nexport function getHarvestWithheldTokensToMintInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: HarvestWithheldTokensToMintInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): HarvestWithheldTokensToMintInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = args.sources.map((address) => ({\n    address,\n    role: AccountRole.WRITABLE,\n  }));\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint), ...remainingAccounts],\n    programAddress,\n    data: getHarvestWithheldTokensToMintInstructionDataEncoder().encode({}),\n  } as HarvestWithheldTokensToMintInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedHarvestWithheldTokensToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. */\n    mint: TAccountMetas[0];\n  };\n  data: HarvestWithheldTokensToMintInstructionData;\n};\n\nexport function parseHarvestWithheldTokensToMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedHarvestWithheldTokensToMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getHarvestWithheldTokensToMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport const HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 3;\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type HarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionData =\n  { discriminator: number; confidentialTransferFeeDiscriminator: number };\n\nexport type HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataArgs =\n  {};\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataEncoder(): Encoder<HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator:\n        HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataDecoder(): Decoder<HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataCodec(): Codec<\n  HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataArgs,\n  HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionData\n> {\n  return combineCodec(\n    getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataEncoder(),\n    getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataDecoder()\n  );\n}\n\nexport type HarvestWithheldTokensToMintForConfidentialTransferFeeInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  sources?: Array<Address>;\n};\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: HarvestWithheldTokensToMintForConfidentialTransferFeeInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): HarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TProgramAddress,\n  TAccountMint\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.sources ?? []).map(\n    (address) => ({ address, role: AccountRole.WRITABLE })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint), ...remainingAccounts],\n    programAddress,\n    data: getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataEncoder().encode(\n      {}\n    ),\n  } as HarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n    TProgramAddress,\n    TAccountMint\n  >;\n\n  return instruction;\n}\n\nexport type ParsedHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n  };\n  data: HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionData;\n};\n\nexport function parseHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_ACCOUNT_DISCRIMINATOR = 1;\n\nexport function getInitializeAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type InitializeAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeAccountInstructionData = { discriminator: number };\n\nexport type InitializeAccountInstructionDataArgs = {};\n\nexport function getInitializeAccountInstructionDataEncoder(): Encoder<InitializeAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeAccountInstructionDataDecoder(): Decoder<InitializeAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getInitializeAccountInstructionDataCodec(): Codec<\n  InitializeAccountInstructionDataArgs,\n  InitializeAccountInstructionData\n> {\n  return combineCodec(\n    getInitializeAccountInstructionDataEncoder(),\n    getInitializeAccountInstructionDataDecoder()\n  );\n}\n\nexport type InitializeAccountInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountOwner extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n  /** The mint this account will be associated with. */\n  mint: Address<TAccountMint>;\n  /** The new account's owner/multisignature. */\n  owner: Address<TAccountOwner>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n};\n\nexport function getInitializeAccountInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountOwner extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeAccountInput<\n    TAccountAccount,\n    TAccountMint,\n    TAccountOwner,\n    TAccountRent\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  TAccountOwner,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.rent),\n    ],\n    programAddress,\n    data: getInitializeAccountInstructionDataEncoder().encode({}),\n  } as InitializeAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    TAccountOwner,\n    TAccountRent\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n    /** The mint this account will be associated with. */\n    mint: TAccountMetas[1];\n    /** The new account's owner/multisignature. */\n    owner: TAccountMetas[2];\n    /** Rent sysvar. */\n    rent: TAccountMetas[3];\n  };\n  data: InitializeAccountInstructionData;\n};\n\nexport function parseInitializeAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_ACCOUNT2_DISCRIMINATOR = 16;\n\nexport function getInitializeAccount2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT2_DISCRIMINATOR);\n}\n\nexport type InitializeAccount2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeAccount2InstructionData = {\n  discriminator: number;\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport type InitializeAccount2InstructionDataArgs = {\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport function getInitializeAccount2InstructionDataEncoder(): Encoder<InitializeAccount2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['owner', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT2_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeAccount2InstructionDataDecoder(): Decoder<InitializeAccount2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['owner', getAddressDecoder()],\n  ]);\n}\n\nexport function getInitializeAccount2InstructionDataCodec(): Codec<\n  InitializeAccount2InstructionDataArgs,\n  InitializeAccount2InstructionData\n> {\n  return combineCodec(\n    getInitializeAccount2InstructionDataEncoder(),\n    getInitializeAccount2InstructionDataDecoder()\n  );\n}\n\nexport type InitializeAccount2Input<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n  /** The mint this account will be associated with. */\n  mint: Address<TAccountMint>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n  owner: InitializeAccount2InstructionDataArgs['owner'];\n};\n\nexport function getInitializeAccount2Instruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeAccount2Input<TAccountAccount, TAccountMint, TAccountRent>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeAccount2Instruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.rent),\n    ],\n    programAddress,\n    data: getInitializeAccount2InstructionDataEncoder().encode(\n      args as InitializeAccount2InstructionDataArgs\n    ),\n  } as InitializeAccount2Instruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    TAccountRent\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeAccount2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n    /** The mint this account will be associated with. */\n    mint: TAccountMetas[1];\n    /** Rent sysvar. */\n    rent: TAccountMetas[2];\n  };\n  data: InitializeAccount2InstructionData;\n};\n\nexport function parseInitializeAccount2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeAccount2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeAccount2InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_ACCOUNT3_DISCRIMINATOR = 18;\n\nexport function getInitializeAccount3DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT3_DISCRIMINATOR);\n}\n\nexport type InitializeAccount3Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeAccount3InstructionData = {\n  discriminator: number;\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport type InitializeAccount3InstructionDataArgs = {\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport function getInitializeAccount3InstructionDataEncoder(): Encoder<InitializeAccount3InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['owner', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT3_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeAccount3InstructionDataDecoder(): Decoder<InitializeAccount3InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['owner', getAddressDecoder()],\n  ]);\n}\n\nexport function getInitializeAccount3InstructionDataCodec(): Codec<\n  InitializeAccount3InstructionDataArgs,\n  InitializeAccount3InstructionData\n> {\n  return combineCodec(\n    getInitializeAccount3InstructionDataEncoder(),\n    getInitializeAccount3InstructionDataDecoder()\n  );\n}\n\nexport type InitializeAccount3Input<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n  /** The mint this account will be associated with. */\n  mint: Address<TAccountMint>;\n  owner: InitializeAccount3InstructionDataArgs['owner'];\n};\n\nexport function getInitializeAccount3Instruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeAccount3Input<TAccountAccount, TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeAccount3Instruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.account), getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeAccount3InstructionDataEncoder().encode(\n      args as InitializeAccount3InstructionDataArgs\n    ),\n  } as InitializeAccount3Instruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeAccount3Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n    /** The mint this account will be associated with. */\n    mint: TAccountMetas[1];\n  };\n  data: InitializeAccount3InstructionData;\n};\n\nexport function parseInitializeAccount3Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeAccount3Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n    },\n    data: getInitializeAccount3InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;\n\nexport function getInitializeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport const INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 0;\n\nexport function getInitializeConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type InitializeConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeConfidentialTransferFeeInstructionData = {\n  discriminator: number;\n  confidentialTransferFeeDiscriminator: number;\n  /** Optional authority to set the withdraw withheld authority ElGamal key */\n  authority: Option<Address>;\n  /** Withheld fees from accounts must be encrypted with this ElGamal key */\n  withdrawWithheldAuthorityElGamalPubkey: Option<Address>;\n};\n\nexport type InitializeConfidentialTransferFeeInstructionDataArgs = {\n  /** Optional authority to set the withdraw withheld authority ElGamal key */\n  authority: OptionOrNullable<Address>;\n  /** Withheld fees from accounts must be encrypted with this ElGamal key */\n  withdrawWithheldAuthorityElGamalPubkey: OptionOrNullable<Address>;\n};\n\nexport function getInitializeConfidentialTransferFeeInstructionDataEncoder(): Encoder<InitializeConfidentialTransferFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      [\n        'withdrawWithheldAuthorityElGamalPubkey',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeConfidentialTransferFeeInstructionDataDecoder(): Decoder<InitializeConfidentialTransferFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'withdrawWithheldAuthorityElGamalPubkey',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeConfidentialTransferFeeInstructionDataCodec(): Codec<\n  InitializeConfidentialTransferFeeInstructionDataArgs,\n  InitializeConfidentialTransferFeeInstructionData\n> {\n  return combineCodec(\n    getInitializeConfidentialTransferFeeInstructionDataEncoder(),\n    getInitializeConfidentialTransferFeeInstructionDataDecoder()\n  );\n}\n\nexport type InitializeConfidentialTransferFeeInput<\n  TAccountMint extends string = string,\n> = {\n  /** The SPL Token mint. */\n  mint: Address<TAccountMint>;\n  authority: InitializeConfidentialTransferFeeInstructionDataArgs['authority'];\n  withdrawWithheldAuthorityElGamalPubkey: InitializeConfidentialTransferFeeInstructionDataArgs['withdrawWithheldAuthorityElGamalPubkey'];\n};\n\nexport function getInitializeConfidentialTransferFeeInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeConfidentialTransferFeeInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeConfidentialTransferFeeInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeConfidentialTransferFeeInstructionDataEncoder().encode(\n      args as InitializeConfidentialTransferFeeInstructionDataArgs\n    ),\n  } as InitializeConfidentialTransferFeeInstruction<\n    TProgramAddress,\n    TAccountMint\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token mint. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeConfidentialTransferFeeInstructionData;\n};\n\nexport function parseInitializeConfidentialTransferFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeConfidentialTransferFeeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeConfidentialTransferFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR = 27;\n\nexport function getInitializeConfidentialTransferMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR\n  );\n}\n\nexport const INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 0;\n\nexport function getInitializeConfidentialTransferMintConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type InitializeConfidentialTransferMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeConfidentialTransferMintInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /**\n   * Authority to modify the `ConfidentialTransferMint` configuration and to\n   * approve new accounts.\n   */\n  authority: Option<Address>;\n  /**\n   * Determines if newly configured accounts must be approved by the\n   * `authority` before they may be used by the user.\n   */\n  autoApproveNewAccounts: boolean;\n  /** New authority to decode any transfer amount in a confidential transfer. */\n  auditorElgamalPubkey: Option<Address>;\n};\n\nexport type InitializeConfidentialTransferMintInstructionDataArgs = {\n  /**\n   * Authority to modify the `ConfidentialTransferMint` configuration and to\n   * approve new accounts.\n   */\n  authority: OptionOrNullable<Address>;\n  /**\n   * Determines if newly configured accounts must be approved by the\n   * `authority` before they may be used by the user.\n   */\n  autoApproveNewAccounts: boolean;\n  /** New authority to decode any transfer amount in a confidential transfer. */\n  auditorElgamalPubkey: OptionOrNullable<Address>;\n};\n\nexport function getInitializeConfidentialTransferMintInstructionDataEncoder(): Encoder<InitializeConfidentialTransferMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      ['autoApproveNewAccounts', getBooleanEncoder()],\n      [\n        'auditorElgamalPubkey',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeConfidentialTransferMintInstructionDataDecoder(): Decoder<InitializeConfidentialTransferMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['autoApproveNewAccounts', getBooleanDecoder()],\n    [\n      'auditorElgamalPubkey',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeConfidentialTransferMintInstructionDataCodec(): Codec<\n  InitializeConfidentialTransferMintInstructionDataArgs,\n  InitializeConfidentialTransferMintInstructionData\n> {\n  return combineCodec(\n    getInitializeConfidentialTransferMintInstructionDataEncoder(),\n    getInitializeConfidentialTransferMintInstructionDataDecoder()\n  );\n}\n\nexport type InitializeConfidentialTransferMintInput<\n  TAccountMint extends string = string,\n> = {\n  /** The SPL Token mint. */\n  mint: Address<TAccountMint>;\n  authority: InitializeConfidentialTransferMintInstructionDataArgs['authority'];\n  autoApproveNewAccounts: InitializeConfidentialTransferMintInstructionDataArgs['autoApproveNewAccounts'];\n  auditorElgamalPubkey: InitializeConfidentialTransferMintInstructionDataArgs['auditorElgamalPubkey'];\n};\n\nexport function getInitializeConfidentialTransferMintInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeConfidentialTransferMintInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeConfidentialTransferMintInstruction<\n  TProgramAddress,\n  TAccountMint\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeConfidentialTransferMintInstructionDataEncoder().encode(\n      args as InitializeConfidentialTransferMintInstructionDataArgs\n    ),\n  } as InitializeConfidentialTransferMintInstruction<\n    TProgramAddress,\n    TAccountMint\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeConfidentialTransferMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token mint. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeConfidentialTransferMintInstructionData;\n};\n\nexport function parseInitializeConfidentialTransferMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeConfidentialTransferMintInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeConfidentialTransferMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getAccountStateDecoder,\n  getAccountStateEncoder,\n  type AccountState,\n  type AccountStateArgs,\n} from '../types';\n\nexport const INITIALIZE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 28;\n\nexport function getInitializeDefaultAccountStateDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 0;\n\nexport function getInitializeDefaultAccountStateDefaultAccountStateDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR\n  );\n}\n\nexport type InitializeDefaultAccountStateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeDefaultAccountStateInstructionData = {\n  discriminator: number;\n  defaultAccountStateDiscriminator: number;\n  /** The state each new token account should start with. */\n  state: AccountState;\n};\n\nexport type InitializeDefaultAccountStateInstructionDataArgs = {\n  /** The state each new token account should start with. */\n  state: AccountStateArgs;\n};\n\nexport function getInitializeDefaultAccountStateInstructionDataEncoder(): Encoder<InitializeDefaultAccountStateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['defaultAccountStateDiscriminator', getU8Encoder()],\n      ['state', getAccountStateEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR,\n      defaultAccountStateDiscriminator:\n        INITIALIZE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeDefaultAccountStateInstructionDataDecoder(): Decoder<InitializeDefaultAccountStateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['defaultAccountStateDiscriminator', getU8Decoder()],\n    ['state', getAccountStateDecoder()],\n  ]);\n}\n\nexport function getInitializeDefaultAccountStateInstructionDataCodec(): Codec<\n  InitializeDefaultAccountStateInstructionDataArgs,\n  InitializeDefaultAccountStateInstructionData\n> {\n  return combineCodec(\n    getInitializeDefaultAccountStateInstructionDataEncoder(),\n    getInitializeDefaultAccountStateInstructionDataDecoder()\n  );\n}\n\nexport type InitializeDefaultAccountStateInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  state: InitializeDefaultAccountStateInstructionDataArgs['state'];\n};\n\nexport function getInitializeDefaultAccountStateInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeDefaultAccountStateInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeDefaultAccountStateInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeDefaultAccountStateInstructionDataEncoder().encode(\n      args as InitializeDefaultAccountStateInstructionDataArgs\n    ),\n  } as InitializeDefaultAccountStateInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeDefaultAccountStateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeDefaultAccountStateInstructionData;\n};\n\nexport function parseInitializeDefaultAccountStateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeDefaultAccountStateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeDefaultAccountStateInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_GROUP_MEMBER_POINTER_DISCRIMINATOR = 41;\n\nexport function getInitializeGroupMemberPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_GROUP_MEMBER_POINTER_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR = 0;\n\nexport function getInitializeGroupMemberPointerGroupMemberPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type InitializeGroupMemberPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeGroupMemberPointerInstructionData = {\n  discriminator: number;\n  groupMemberPointerDiscriminator: number;\n  /** The public key for the account that can update the group member address. */\n  authority: Option<Address>;\n  /** The account address that holds the member. */\n  memberAddress: Option<Address>;\n};\n\nexport type InitializeGroupMemberPointerInstructionDataArgs = {\n  /** The public key for the account that can update the group member address. */\n  authority: OptionOrNullable<Address>;\n  /** The account address that holds the member. */\n  memberAddress: OptionOrNullable<Address>;\n};\n\nexport function getInitializeGroupMemberPointerInstructionDataEncoder(): Encoder<InitializeGroupMemberPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['groupMemberPointerDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      [\n        'memberAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_GROUP_MEMBER_POINTER_DISCRIMINATOR,\n      groupMemberPointerDiscriminator:\n        INITIALIZE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeGroupMemberPointerInstructionDataDecoder(): Decoder<InitializeGroupMemberPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['groupMemberPointerDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'memberAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeGroupMemberPointerInstructionDataCodec(): Codec<\n  InitializeGroupMemberPointerInstructionDataArgs,\n  InitializeGroupMemberPointerInstructionData\n> {\n  return combineCodec(\n    getInitializeGroupMemberPointerInstructionDataEncoder(),\n    getInitializeGroupMemberPointerInstructionDataDecoder()\n  );\n}\n\nexport type InitializeGroupMemberPointerInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  authority: InitializeGroupMemberPointerInstructionDataArgs['authority'];\n  memberAddress: InitializeGroupMemberPointerInstructionDataArgs['memberAddress'];\n};\n\nexport function getInitializeGroupMemberPointerInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeGroupMemberPointerInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeGroupMemberPointerInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeGroupMemberPointerInstructionDataEncoder().encode(\n      args as InitializeGroupMemberPointerInstructionDataArgs\n    ),\n  } as InitializeGroupMemberPointerInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeGroupMemberPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeGroupMemberPointerInstructionData;\n};\n\nexport function parseInitializeGroupMemberPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeGroupMemberPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeGroupMemberPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_GROUP_POINTER_DISCRIMINATOR = 40;\n\nexport function getInitializeGroupPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_GROUP_POINTER_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR = 0;\n\nexport function getInitializeGroupPointerGroupPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type InitializeGroupPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeGroupPointerInstructionData = {\n  discriminator: number;\n  groupPointerDiscriminator: number;\n  /** The public key for the account that can update the group address. */\n  authority: Option<Address>;\n  /** The account address that holds the group. */\n  groupAddress: Option<Address>;\n};\n\nexport type InitializeGroupPointerInstructionDataArgs = {\n  /** The public key for the account that can update the group address. */\n  authority: OptionOrNullable<Address>;\n  /** The account address that holds the group. */\n  groupAddress: OptionOrNullable<Address>;\n};\n\nexport function getInitializeGroupPointerInstructionDataEncoder(): Encoder<InitializeGroupPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['groupPointerDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      [\n        'groupAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_GROUP_POINTER_DISCRIMINATOR,\n      groupPointerDiscriminator:\n        INITIALIZE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeGroupPointerInstructionDataDecoder(): Decoder<InitializeGroupPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['groupPointerDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'groupAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeGroupPointerInstructionDataCodec(): Codec<\n  InitializeGroupPointerInstructionDataArgs,\n  InitializeGroupPointerInstructionData\n> {\n  return combineCodec(\n    getInitializeGroupPointerInstructionDataEncoder(),\n    getInitializeGroupPointerInstructionDataDecoder()\n  );\n}\n\nexport type InitializeGroupPointerInput<TAccountMint extends string = string> =\n  {\n    /** The mint to initialize. */\n    mint: Address<TAccountMint>;\n    authority: InitializeGroupPointerInstructionDataArgs['authority'];\n    groupAddress: InitializeGroupPointerInstructionDataArgs['groupAddress'];\n  };\n\nexport function getInitializeGroupPointerInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeGroupPointerInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeGroupPointerInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeGroupPointerInstructionDataEncoder().encode(\n      args as InitializeGroupPointerInstructionDataArgs\n    ),\n  } as InitializeGroupPointerInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeGroupPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeGroupPointerInstructionData;\n};\n\nexport function parseInitializeGroupPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeGroupPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeGroupPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR = 22;\n\nexport function getInitializeImmutableOwnerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR);\n}\n\nexport type InitializeImmutableOwnerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeImmutableOwnerInstructionData = { discriminator: number };\n\nexport type InitializeImmutableOwnerInstructionDataArgs = {};\n\nexport function getInitializeImmutableOwnerInstructionDataEncoder(): Encoder<InitializeImmutableOwnerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeImmutableOwnerInstructionDataDecoder(): Decoder<InitializeImmutableOwnerInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getInitializeImmutableOwnerInstructionDataCodec(): Codec<\n  InitializeImmutableOwnerInstructionDataArgs,\n  InitializeImmutableOwnerInstructionData\n> {\n  return combineCodec(\n    getInitializeImmutableOwnerInstructionDataEncoder(),\n    getInitializeImmutableOwnerInstructionDataDecoder()\n  );\n}\n\nexport type InitializeImmutableOwnerInput<\n  TAccountAccount extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n};\n\nexport function getInitializeImmutableOwnerInstruction<\n  TAccountAccount extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeImmutableOwnerInput<TAccountAccount>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeImmutableOwnerInstruction<TProgramAddress, TAccountAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.account)],\n    programAddress,\n    data: getInitializeImmutableOwnerInstructionDataEncoder().encode({}),\n  } as InitializeImmutableOwnerInstruction<TProgramAddress, TAccountAccount>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeImmutableOwnerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n  };\n  data: InitializeImmutableOwnerInstructionData;\n};\n\nexport function parseInitializeImmutableOwnerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeImmutableOwnerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n    },\n    data: getInitializeImmutableOwnerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getI16Decoder,\n  getI16Encoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_INTEREST_BEARING_MINT_DISCRIMINATOR = 33;\n\nexport function getInitializeInterestBearingMintDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_INTEREST_BEARING_MINT_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR = 0;\n\nexport function getInitializeInterestBearingMintInterestBearingMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR\n  );\n}\n\nexport type InitializeInterestBearingMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeInterestBearingMintInstructionData = {\n  discriminator: number;\n  interestBearingMintDiscriminator: number;\n  /** The public key for the account that can update the rate */\n  rateAuthority: Option<Address>;\n  /** The initial interest rate */\n  rate: number;\n};\n\nexport type InitializeInterestBearingMintInstructionDataArgs = {\n  /** The public key for the account that can update the rate */\n  rateAuthority: OptionOrNullable<Address>;\n  /** The initial interest rate */\n  rate: number;\n};\n\nexport function getInitializeInterestBearingMintInstructionDataEncoder(): Encoder<InitializeInterestBearingMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['interestBearingMintDiscriminator', getU8Encoder()],\n      [\n        'rateAuthority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      ['rate', getI16Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_INTEREST_BEARING_MINT_DISCRIMINATOR,\n      interestBearingMintDiscriminator:\n        INITIALIZE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeInterestBearingMintInstructionDataDecoder(): Decoder<InitializeInterestBearingMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['interestBearingMintDiscriminator', getU8Decoder()],\n    [\n      'rateAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['rate', getI16Decoder()],\n  ]);\n}\n\nexport function getInitializeInterestBearingMintInstructionDataCodec(): Codec<\n  InitializeInterestBearingMintInstructionDataArgs,\n  InitializeInterestBearingMintInstructionData\n> {\n  return combineCodec(\n    getInitializeInterestBearingMintInstructionDataEncoder(),\n    getInitializeInterestBearingMintInstructionDataDecoder()\n  );\n}\n\nexport type InitializeInterestBearingMintInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  rateAuthority: InitializeInterestBearingMintInstructionDataArgs['rateAuthority'];\n  rate: InitializeInterestBearingMintInstructionDataArgs['rate'];\n};\n\nexport function getInitializeInterestBearingMintInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeInterestBearingMintInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeInterestBearingMintInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeInterestBearingMintInstructionDataEncoder().encode(\n      args as InitializeInterestBearingMintInstructionDataArgs\n    ),\n  } as InitializeInterestBearingMintInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeInterestBearingMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeInterestBearingMintInstructionData;\n};\n\nexport function parseInitializeInterestBearingMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeInterestBearingMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeInterestBearingMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_METADATA_POINTER_DISCRIMINATOR = 39;\n\nexport function getInitializeMetadataPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_METADATA_POINTER_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR = 0;\n\nexport function getInitializeMetadataPointerMetadataPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type InitializeMetadataPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMetadataPointerInstructionData = {\n  discriminator: number;\n  metadataPointerDiscriminator: number;\n  /** The public key for the account that can update the metadata address. */\n  authority: Option<Address>;\n  /** The account address that holds the metadata. */\n  metadataAddress: Option<Address>;\n};\n\nexport type InitializeMetadataPointerInstructionDataArgs = {\n  /** The public key for the account that can update the metadata address. */\n  authority: OptionOrNullable<Address>;\n  /** The account address that holds the metadata. */\n  metadataAddress: OptionOrNullable<Address>;\n};\n\nexport function getInitializeMetadataPointerInstructionDataEncoder(): Encoder<InitializeMetadataPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['metadataPointerDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      [\n        'metadataAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_METADATA_POINTER_DISCRIMINATOR,\n      metadataPointerDiscriminator:\n        INITIALIZE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeMetadataPointerInstructionDataDecoder(): Decoder<InitializeMetadataPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['metadataPointerDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'metadataAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeMetadataPointerInstructionDataCodec(): Codec<\n  InitializeMetadataPointerInstructionDataArgs,\n  InitializeMetadataPointerInstructionData\n> {\n  return combineCodec(\n    getInitializeMetadataPointerInstructionDataEncoder(),\n    getInitializeMetadataPointerInstructionDataDecoder()\n  );\n}\n\nexport type InitializeMetadataPointerInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  authority: InitializeMetadataPointerInstructionDataArgs['authority'];\n  metadataAddress: InitializeMetadataPointerInstructionDataArgs['metadataAddress'];\n};\n\nexport function getInitializeMetadataPointerInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMetadataPointerInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMetadataPointerInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeMetadataPointerInstructionDataEncoder().encode(\n      args as InitializeMetadataPointerInstructionDataArgs\n    ),\n  } as InitializeMetadataPointerInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeMetadataPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeMetadataPointerInstructionData;\n};\n\nexport function parseInitializeMetadataPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeMetadataPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeMetadataPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  none,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MINT_DISCRIMINATOR = 0;\n\nexport function getInitializeMintDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MINT_DISCRIMINATOR);\n}\n\nexport type InitializeMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMintInstructionData = {\n  discriminator: number;\n  /** Number of decimals in token account amounts. */\n  decimals: number;\n  /** Minting authority. */\n  mintAuthority: Address;\n  /** Optional authority that can freeze token accounts. */\n  freezeAuthority: Option<Address>;\n};\n\nexport type InitializeMintInstructionDataArgs = {\n  /** Number of decimals in token account amounts. */\n  decimals: number;\n  /** Minting authority. */\n  mintAuthority: Address;\n  /** Optional authority that can freeze token accounts. */\n  freezeAuthority?: OptionOrNullable<Address>;\n};\n\nexport function getInitializeMintInstructionDataEncoder(): Encoder<InitializeMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['decimals', getU8Encoder()],\n      ['mintAuthority', getAddressEncoder()],\n      ['freezeAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_MINT_DISCRIMINATOR,\n      freezeAuthority: value.freezeAuthority ?? none(),\n    })\n  );\n}\n\nexport function getInitializeMintInstructionDataDecoder(): Decoder<InitializeMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['decimals', getU8Decoder()],\n    ['mintAuthority', getAddressDecoder()],\n    ['freezeAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getInitializeMintInstructionDataCodec(): Codec<\n  InitializeMintInstructionDataArgs,\n  InitializeMintInstructionData\n> {\n  return combineCodec(\n    getInitializeMintInstructionDataEncoder(),\n    getInitializeMintInstructionDataDecoder()\n  );\n}\n\nexport type InitializeMintInput<\n  TAccountMint extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** Token mint account. */\n  mint: Address<TAccountMint>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n  decimals: InitializeMintInstructionDataArgs['decimals'];\n  mintAuthority: InitializeMintInstructionDataArgs['mintAuthority'];\n  freezeAuthority?: InitializeMintInstructionDataArgs['freezeAuthority'];\n};\n\nexport function getInitializeMintInstruction<\n  TAccountMint extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMintInput<TAccountMint, TAccountRent>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMintInstruction<TProgramAddress, TAccountMint, TAccountRent> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint), getAccountMeta(accounts.rent)],\n    programAddress,\n    data: getInitializeMintInstructionDataEncoder().encode(\n      args as InitializeMintInstructionDataArgs\n    ),\n  } as InitializeMintInstruction<TProgramAddress, TAccountMint, TAccountRent>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Token mint account. */\n    mint: TAccountMetas[0];\n    /** Rent sysvar. */\n    rent: TAccountMetas[1];\n  };\n  data: InitializeMintInstructionData;\n};\n\nexport function parseInitializeMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeMintInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  none,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MINT2_DISCRIMINATOR = 20;\n\nexport function getInitializeMint2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MINT2_DISCRIMINATOR);\n}\n\nexport type InitializeMint2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMint2InstructionData = {\n  discriminator: number;\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The authority/multisignature to mint tokens. */\n  mintAuthority: Address;\n  /** The optional freeze authority/multisignature of the mint. */\n  freezeAuthority: Option<Address>;\n};\n\nexport type InitializeMint2InstructionDataArgs = {\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The authority/multisignature to mint tokens. */\n  mintAuthority: Address;\n  /** The optional freeze authority/multisignature of the mint. */\n  freezeAuthority?: OptionOrNullable<Address>;\n};\n\nexport function getInitializeMint2InstructionDataEncoder(): Encoder<InitializeMint2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['decimals', getU8Encoder()],\n      ['mintAuthority', getAddressEncoder()],\n      ['freezeAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_MINT2_DISCRIMINATOR,\n      freezeAuthority: value.freezeAuthority ?? none(),\n    })\n  );\n}\n\nexport function getInitializeMint2InstructionDataDecoder(): Decoder<InitializeMint2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['decimals', getU8Decoder()],\n    ['mintAuthority', getAddressDecoder()],\n    ['freezeAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getInitializeMint2InstructionDataCodec(): Codec<\n  InitializeMint2InstructionDataArgs,\n  InitializeMint2InstructionData\n> {\n  return combineCodec(\n    getInitializeMint2InstructionDataEncoder(),\n    getInitializeMint2InstructionDataDecoder()\n  );\n}\n\nexport type InitializeMint2Input<TAccountMint extends string = string> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  decimals: InitializeMint2InstructionDataArgs['decimals'];\n  mintAuthority: InitializeMint2InstructionDataArgs['mintAuthority'];\n  freezeAuthority?: InitializeMint2InstructionDataArgs['freezeAuthority'];\n};\n\nexport function getInitializeMint2Instruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMint2Input<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMint2Instruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeMint2InstructionDataEncoder().encode(\n      args as InitializeMint2InstructionDataArgs\n    ),\n  } as InitializeMint2Instruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeMint2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeMint2InstructionData;\n};\n\nexport function parseInitializeMint2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeMint2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeMint2InstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MINT_CLOSE_AUTHORITY_DISCRIMINATOR = 25;\n\nexport function getInitializeMintCloseAuthorityDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MINT_CLOSE_AUTHORITY_DISCRIMINATOR);\n}\n\nexport type InitializeMintCloseAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMintCloseAuthorityInstructionData = {\n  discriminator: number;\n  /** Authority that must sign the `CloseAccount` instruction on a mint. */\n  closeAuthority: Option<Address>;\n};\n\nexport type InitializeMintCloseAuthorityInstructionDataArgs = {\n  /** Authority that must sign the `CloseAccount` instruction on a mint. */\n  closeAuthority: OptionOrNullable<Address>;\n};\n\nexport function getInitializeMintCloseAuthorityInstructionDataEncoder(): Encoder<InitializeMintCloseAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['closeAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_MINT_CLOSE_AUTHORITY_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeMintCloseAuthorityInstructionDataDecoder(): Decoder<InitializeMintCloseAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['closeAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getInitializeMintCloseAuthorityInstructionDataCodec(): Codec<\n  InitializeMintCloseAuthorityInstructionDataArgs,\n  InitializeMintCloseAuthorityInstructionData\n> {\n  return combineCodec(\n    getInitializeMintCloseAuthorityInstructionDataEncoder(),\n    getInitializeMintCloseAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type InitializeMintCloseAuthorityInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  closeAuthority: InitializeMintCloseAuthorityInstructionDataArgs['closeAuthority'];\n};\n\nexport function getInitializeMintCloseAuthorityInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMintCloseAuthorityInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMintCloseAuthorityInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeMintCloseAuthorityInstructionDataEncoder().encode(\n      args as InitializeMintCloseAuthorityInstructionDataArgs\n    ),\n  } as InitializeMintCloseAuthorityInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeMintCloseAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeMintCloseAuthorityInstructionData;\n};\n\nexport function parseInitializeMintCloseAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeMintCloseAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeMintCloseAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MULTISIG_DISCRIMINATOR = 2;\n\nexport function getInitializeMultisigDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MULTISIG_DISCRIMINATOR);\n}\n\nexport type InitializeMultisigInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMultisig extends string | IAccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMultisig extends string\n        ? WritableAccount<TAccountMultisig>\n        : TAccountMultisig,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMultisigInstructionData = {\n  discriminator: number;\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport type InitializeMultisigInstructionDataArgs = {\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport function getInitializeMultisigInstructionDataEncoder(): Encoder<InitializeMultisigInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['m', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_MULTISIG_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeMultisigInstructionDataDecoder(): Decoder<InitializeMultisigInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['m', getU8Decoder()],\n  ]);\n}\n\nexport function getInitializeMultisigInstructionDataCodec(): Codec<\n  InitializeMultisigInstructionDataArgs,\n  InitializeMultisigInstructionData\n> {\n  return combineCodec(\n    getInitializeMultisigInstructionDataEncoder(),\n    getInitializeMultisigInstructionDataDecoder()\n  );\n}\n\nexport type InitializeMultisigInput<\n  TAccountMultisig extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** The multisignature account to initialize. */\n  multisig: Address<TAccountMultisig>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n  m: InitializeMultisigInstructionDataArgs['m'];\n  signers: Array<Address>;\n};\n\nexport function getInitializeMultisigInstruction<\n  TAccountMultisig extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMultisigInput<TAccountMultisig, TAccountRent>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMultisigInstruction<\n  TProgramAddress,\n  TAccountMultisig,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    multisig: { value: input.multisig ?? null, isWritable: true },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = args.signers.map((address) => ({\n    address,\n    role: AccountRole.READONLY,\n  }));\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.multisig),\n      getAccountMeta(accounts.rent),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getInitializeMultisigInstructionDataEncoder().encode(\n      args as InitializeMultisigInstructionDataArgs\n    ),\n  } as InitializeMultisigInstruction<\n    TProgramAddress,\n    TAccountMultisig,\n    TAccountRent\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeMultisigInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The multisignature account to initialize. */\n    multisig: TAccountMetas[0];\n    /** Rent sysvar. */\n    rent: TAccountMetas[1];\n  };\n  data: InitializeMultisigInstructionData;\n};\n\nexport function parseInitializeMultisigInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeMultisigInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      multisig: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeMultisigInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MULTISIG2_DISCRIMINATOR = 19;\n\nexport function getInitializeMultisig2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MULTISIG2_DISCRIMINATOR);\n}\n\nexport type InitializeMultisig2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMultisig extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMultisig extends string\n        ? WritableAccount<TAccountMultisig>\n        : TAccountMultisig,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMultisig2InstructionData = {\n  discriminator: number;\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport type InitializeMultisig2InstructionDataArgs = {\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport function getInitializeMultisig2InstructionDataEncoder(): Encoder<InitializeMultisig2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['m', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_MULTISIG2_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeMultisig2InstructionDataDecoder(): Decoder<InitializeMultisig2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['m', getU8Decoder()],\n  ]);\n}\n\nexport function getInitializeMultisig2InstructionDataCodec(): Codec<\n  InitializeMultisig2InstructionDataArgs,\n  InitializeMultisig2InstructionData\n> {\n  return combineCodec(\n    getInitializeMultisig2InstructionDataEncoder(),\n    getInitializeMultisig2InstructionDataDecoder()\n  );\n}\n\nexport type InitializeMultisig2Input<TAccountMultisig extends string = string> =\n  {\n    /** The multisignature account to initialize. */\n    multisig: Address<TAccountMultisig>;\n    m: InitializeMultisig2InstructionDataArgs['m'];\n    signers: Array<Address>;\n  };\n\nexport function getInitializeMultisig2Instruction<\n  TAccountMultisig extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMultisig2Input<TAccountMultisig>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMultisig2Instruction<TProgramAddress, TAccountMultisig> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    multisig: { value: input.multisig ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = args.signers.map((address) => ({\n    address,\n    role: AccountRole.READONLY,\n  }));\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.multisig), ...remainingAccounts],\n    programAddress,\n    data: getInitializeMultisig2InstructionDataEncoder().encode(\n      args as InitializeMultisig2InstructionDataArgs\n    ),\n  } as InitializeMultisig2Instruction<TProgramAddress, TAccountMultisig>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeMultisig2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The multisignature account to initialize. */\n    multisig: TAccountMetas[0];\n  };\n  data: InitializeMultisig2InstructionData;\n};\n\nexport function parseInitializeMultisig2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeMultisig2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      multisig: getNextAccount(),\n    },\n    data: getInitializeMultisig2InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_NON_TRANSFERABLE_MINT_DISCRIMINATOR = 32;\n\nexport function getInitializeNonTransferableMintDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_NON_TRANSFERABLE_MINT_DISCRIMINATOR);\n}\n\nexport type InitializeNonTransferableMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeNonTransferableMintInstructionData = {\n  discriminator: number;\n};\n\nexport type InitializeNonTransferableMintInstructionDataArgs = {};\n\nexport function getInitializeNonTransferableMintInstructionDataEncoder(): Encoder<InitializeNonTransferableMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_NON_TRANSFERABLE_MINT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeNonTransferableMintInstructionDataDecoder(): Decoder<InitializeNonTransferableMintInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getInitializeNonTransferableMintInstructionDataCodec(): Codec<\n  InitializeNonTransferableMintInstructionDataArgs,\n  InitializeNonTransferableMintInstructionData\n> {\n  return combineCodec(\n    getInitializeNonTransferableMintInstructionDataEncoder(),\n    getInitializeNonTransferableMintInstructionDataDecoder()\n  );\n}\n\nexport type InitializeNonTransferableMintInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint account to initialize. */\n  mint: Address<TAccountMint>;\n};\n\nexport function getInitializeNonTransferableMintInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeNonTransferableMintInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeNonTransferableMintInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeNonTransferableMintInstructionDataEncoder().encode({}),\n  } as InitializeNonTransferableMintInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeNonTransferableMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint account to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeNonTransferableMintInstructionData;\n};\n\nexport function parseInitializeNonTransferableMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeNonTransferableMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeNonTransferableMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_PERMANENT_DELEGATE_DISCRIMINATOR = 35;\n\nexport function getInitializePermanentDelegateDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_PERMANENT_DELEGATE_DISCRIMINATOR);\n}\n\nexport type InitializePermanentDelegateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializePermanentDelegateInstructionData = {\n  discriminator: number;\n  /** Authority that may sign for `Transfer`s and `Burn`s on any account */\n  delegate: Address;\n};\n\nexport type InitializePermanentDelegateInstructionDataArgs = {\n  /** Authority that may sign for `Transfer`s and `Burn`s on any account */\n  delegate: Address;\n};\n\nexport function getInitializePermanentDelegateInstructionDataEncoder(): Encoder<InitializePermanentDelegateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['delegate', getAddressEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_PERMANENT_DELEGATE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializePermanentDelegateInstructionDataDecoder(): Decoder<InitializePermanentDelegateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['delegate', getAddressDecoder()],\n  ]);\n}\n\nexport function getInitializePermanentDelegateInstructionDataCodec(): Codec<\n  InitializePermanentDelegateInstructionDataArgs,\n  InitializePermanentDelegateInstructionData\n> {\n  return combineCodec(\n    getInitializePermanentDelegateInstructionDataEncoder(),\n    getInitializePermanentDelegateInstructionDataDecoder()\n  );\n}\n\nexport type InitializePermanentDelegateInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  delegate: InitializePermanentDelegateInstructionDataArgs['delegate'];\n};\n\nexport function getInitializePermanentDelegateInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializePermanentDelegateInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializePermanentDelegateInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializePermanentDelegateInstructionDataEncoder().encode(\n      args as InitializePermanentDelegateInstructionDataArgs\n    ),\n  } as InitializePermanentDelegateInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializePermanentDelegateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializePermanentDelegateInstructionData;\n};\n\nexport function parseInitializePermanentDelegateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializePermanentDelegateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializePermanentDelegateInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_TOKEN_GROUP_DISCRIMINATOR = new Uint8Array([\n  121, 113, 108, 39, 54, 51, 0, 4,\n]);\n\nexport function getInitializeTokenGroupDiscriminatorBytes() {\n  return getBytesEncoder().encode(INITIALIZE_TOKEN_GROUP_DISCRIMINATOR);\n}\n\nexport type InitializeTokenGroupInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountGroup extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountMintAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountGroup extends string\n        ? WritableAccount<TAccountGroup>\n        : TAccountGroup,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountMintAuthority extends string\n        ? ReadonlySignerAccount<TAccountMintAuthority> &\n            IAccountSignerMeta<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeTokenGroupInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** Update authority for the group */\n  updateAuthority: Option<Address>;\n  /** The maximum number of group members */\n  maxSize: bigint;\n};\n\nexport type InitializeTokenGroupInstructionDataArgs = {\n  /** Update authority for the group */\n  updateAuthority: OptionOrNullable<Address>;\n  /** The maximum number of group members */\n  maxSize: number | bigint;\n};\n\nexport function getInitializeTokenGroupInstructionDataEncoder(): Encoder<InitializeTokenGroupInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      [\n        'updateAuthority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      ['maxSize', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TOKEN_GROUP_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeTokenGroupInstructionDataDecoder(): Decoder<InitializeTokenGroupInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    [\n      'updateAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['maxSize', getU64Decoder()],\n  ]);\n}\n\nexport function getInitializeTokenGroupInstructionDataCodec(): Codec<\n  InitializeTokenGroupInstructionDataArgs,\n  InitializeTokenGroupInstructionData\n> {\n  return combineCodec(\n    getInitializeTokenGroupInstructionDataEncoder(),\n    getInitializeTokenGroupInstructionDataDecoder()\n  );\n}\n\nexport type InitializeTokenGroupInput<\n  TAccountGroup extends string = string,\n  TAccountMint extends string = string,\n  TAccountMintAuthority extends string = string,\n> = {\n  group: Address<TAccountGroup>;\n  mint: Address<TAccountMint>;\n  mintAuthority: TransactionSigner<TAccountMintAuthority>;\n  updateAuthority: InitializeTokenGroupInstructionDataArgs['updateAuthority'];\n  maxSize: InitializeTokenGroupInstructionDataArgs['maxSize'];\n};\n\nexport function getInitializeTokenGroupInstruction<\n  TAccountGroup extends string,\n  TAccountMint extends string,\n  TAccountMintAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeTokenGroupInput<\n    TAccountGroup,\n    TAccountMint,\n    TAccountMintAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeTokenGroupInstruction<\n  TProgramAddress,\n  TAccountGroup,\n  TAccountMint,\n  TAccountMintAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    group: { value: input.group ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.group),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.mintAuthority),\n    ],\n    programAddress,\n    data: getInitializeTokenGroupInstructionDataEncoder().encode(\n      args as InitializeTokenGroupInstructionDataArgs\n    ),\n  } as InitializeTokenGroupInstruction<\n    TProgramAddress,\n    TAccountGroup,\n    TAccountMint,\n    TAccountMintAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeTokenGroupInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    group: TAccountMetas[0];\n    mint: TAccountMetas[1];\n    mintAuthority: TAccountMetas[2];\n  };\n  data: InitializeTokenGroupInstructionData;\n};\n\nexport function parseInitializeTokenGroupInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeTokenGroupInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      group: getNextAccount(),\n      mint: getNextAccount(),\n      mintAuthority: getNextAccount(),\n    },\n    data: getInitializeTokenGroupInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR = new Uint8Array([\n  152, 32, 222, 176, 223, 237, 116, 134,\n]);\n\nexport function getInitializeTokenGroupMemberDiscriminatorBytes() {\n  return getBytesEncoder().encode(INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR);\n}\n\nexport type InitializeTokenGroupMemberInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMember extends string | IAccountMeta<string> = string,\n  TAccountMemberMint extends string | IAccountMeta<string> = string,\n  TAccountMemberMintAuthority extends string | IAccountMeta<string> = string,\n  TAccountGroup extends string | IAccountMeta<string> = string,\n  TAccountGroupUpdateAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMember extends string\n        ? WritableAccount<TAccountMember>\n        : TAccountMember,\n      TAccountMemberMint extends string\n        ? ReadonlyAccount<TAccountMemberMint>\n        : TAccountMemberMint,\n      TAccountMemberMintAuthority extends string\n        ? ReadonlySignerAccount<TAccountMemberMintAuthority> &\n            IAccountSignerMeta<TAccountMemberMintAuthority>\n        : TAccountMemberMintAuthority,\n      TAccountGroup extends string\n        ? WritableAccount<TAccountGroup>\n        : TAccountGroup,\n      TAccountGroupUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountGroupUpdateAuthority> &\n            IAccountSignerMeta<TAccountGroupUpdateAuthority>\n        : TAccountGroupUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeTokenGroupMemberInstructionData = {\n  discriminator: ReadonlyUint8Array;\n};\n\nexport type InitializeTokenGroupMemberInstructionDataArgs = {};\n\nexport function getInitializeTokenGroupMemberInstructionDataEncoder(): Encoder<InitializeTokenGroupMemberInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getBytesEncoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeTokenGroupMemberInstructionDataDecoder(): Decoder<InitializeTokenGroupMemberInstructionData> {\n  return getStructDecoder([['discriminator', getBytesDecoder()]]);\n}\n\nexport function getInitializeTokenGroupMemberInstructionDataCodec(): Codec<\n  InitializeTokenGroupMemberInstructionDataArgs,\n  InitializeTokenGroupMemberInstructionData\n> {\n  return combineCodec(\n    getInitializeTokenGroupMemberInstructionDataEncoder(),\n    getInitializeTokenGroupMemberInstructionDataDecoder()\n  );\n}\n\nexport type InitializeTokenGroupMemberInput<\n  TAccountMember extends string = string,\n  TAccountMemberMint extends string = string,\n  TAccountMemberMintAuthority extends string = string,\n  TAccountGroup extends string = string,\n  TAccountGroupUpdateAuthority extends string = string,\n> = {\n  member: Address<TAccountMember>;\n  memberMint: Address<TAccountMemberMint>;\n  memberMintAuthority: TransactionSigner<TAccountMemberMintAuthority>;\n  group: Address<TAccountGroup>;\n  groupUpdateAuthority: TransactionSigner<TAccountGroupUpdateAuthority>;\n};\n\nexport function getInitializeTokenGroupMemberInstruction<\n  TAccountMember extends string,\n  TAccountMemberMint extends string,\n  TAccountMemberMintAuthority extends string,\n  TAccountGroup extends string,\n  TAccountGroupUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeTokenGroupMemberInput<\n    TAccountMember,\n    TAccountMemberMint,\n    TAccountMemberMintAuthority,\n    TAccountGroup,\n    TAccountGroupUpdateAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeTokenGroupMemberInstruction<\n  TProgramAddress,\n  TAccountMember,\n  TAccountMemberMint,\n  TAccountMemberMintAuthority,\n  TAccountGroup,\n  TAccountGroupUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    member: { value: input.member ?? null, isWritable: true },\n    memberMint: { value: input.memberMint ?? null, isWritable: false },\n    memberMintAuthority: {\n      value: input.memberMintAuthority ?? null,\n      isWritable: false,\n    },\n    group: { value: input.group ?? null, isWritable: true },\n    groupUpdateAuthority: {\n      value: input.groupUpdateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.member),\n      getAccountMeta(accounts.memberMint),\n      getAccountMeta(accounts.memberMintAuthority),\n      getAccountMeta(accounts.group),\n      getAccountMeta(accounts.groupUpdateAuthority),\n    ],\n    programAddress,\n    data: getInitializeTokenGroupMemberInstructionDataEncoder().encode({}),\n  } as InitializeTokenGroupMemberInstruction<\n    TProgramAddress,\n    TAccountMember,\n    TAccountMemberMint,\n    TAccountMemberMintAuthority,\n    TAccountGroup,\n    TAccountGroupUpdateAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeTokenGroupMemberInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    member: TAccountMetas[0];\n    memberMint: TAccountMetas[1];\n    memberMintAuthority: TAccountMetas[2];\n    group: TAccountMetas[3];\n    groupUpdateAuthority: TAccountMetas[4];\n  };\n  data: InitializeTokenGroupMemberInstructionData;\n};\n\nexport function parseInitializeTokenGroupMemberInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeTokenGroupMemberInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      member: getNextAccount(),\n      memberMint: getNextAccount(),\n      memberMintAuthority: getNextAccount(),\n      group: getNextAccount(),\n      groupUpdateAuthority: getNextAccount(),\n    },\n    data: getInitializeTokenGroupMemberInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_TOKEN_METADATA_DISCRIMINATOR = new Uint8Array([\n  210, 225, 30, 162, 88, 184, 77, 141,\n]);\n\nexport function getInitializeTokenMetadataDiscriminatorBytes() {\n  return getBytesEncoder().encode(INITIALIZE_TOKEN_METADATA_DISCRIMINATOR);\n}\n\nexport type InitializeTokenMetadataInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | IAccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountMintAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMetadata extends string\n        ? WritableAccount<TAccountMetadata>\n        : TAccountMetadata,\n      TAccountUpdateAuthority extends string\n        ? ReadonlyAccount<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountMintAuthority extends string\n        ? ReadonlySignerAccount<TAccountMintAuthority> &\n            IAccountSignerMeta<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeTokenMetadataInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** Longer name of the token. */\n  name: string;\n  /** Shortened symbol of the token. */\n  symbol: string;\n  /** URI pointing to more metadata (image, video, etc.). */\n  uri: string;\n};\n\nexport type InitializeTokenMetadataInstructionDataArgs = {\n  /** Longer name of the token. */\n  name: string;\n  /** Shortened symbol of the token. */\n  symbol: string;\n  /** URI pointing to more metadata (image, video, etc.). */\n  uri: string;\n};\n\nexport function getInitializeTokenMetadataInstructionDataEncoder(): Encoder<InitializeTokenMetadataInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n      ['symbol', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n      ['uri', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TOKEN_METADATA_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeTokenMetadataInstructionDataDecoder(): Decoder<InitializeTokenMetadataInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['symbol', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['uri', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n  ]);\n}\n\nexport function getInitializeTokenMetadataInstructionDataCodec(): Codec<\n  InitializeTokenMetadataInstructionDataArgs,\n  InitializeTokenMetadataInstructionData\n> {\n  return combineCodec(\n    getInitializeTokenMetadataInstructionDataEncoder(),\n    getInitializeTokenMetadataInstructionDataDecoder()\n  );\n}\n\nexport type InitializeTokenMetadataInput<\n  TAccountMetadata extends string = string,\n  TAccountUpdateAuthority extends string = string,\n  TAccountMint extends string = string,\n  TAccountMintAuthority extends string = string,\n> = {\n  metadata: Address<TAccountMetadata>;\n  updateAuthority: Address<TAccountUpdateAuthority>;\n  mint: Address<TAccountMint>;\n  mintAuthority: TransactionSigner<TAccountMintAuthority>;\n  name: InitializeTokenMetadataInstructionDataArgs['name'];\n  symbol: InitializeTokenMetadataInstructionDataArgs['symbol'];\n  uri: InitializeTokenMetadataInstructionDataArgs['uri'];\n};\n\nexport function getInitializeTokenMetadataInstruction<\n  TAccountMetadata extends string,\n  TAccountUpdateAuthority extends string,\n  TAccountMint extends string,\n  TAccountMintAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeTokenMetadataInput<\n    TAccountMetadata,\n    TAccountUpdateAuthority,\n    TAccountMint,\n    TAccountMintAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeTokenMetadataInstruction<\n  TProgramAddress,\n  TAccountMetadata,\n  TAccountUpdateAuthority,\n  TAccountMint,\n  TAccountMintAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n    mint: { value: input.mint ?? null, isWritable: false },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.updateAuthority),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.mintAuthority),\n    ],\n    programAddress,\n    data: getInitializeTokenMetadataInstructionDataEncoder().encode(\n      args as InitializeTokenMetadataInstructionDataArgs\n    ),\n  } as InitializeTokenMetadataInstruction<\n    TProgramAddress,\n    TAccountMetadata,\n    TAccountUpdateAuthority,\n    TAccountMint,\n    TAccountMintAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeTokenMetadataInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    metadata: TAccountMetas[0];\n    updateAuthority: TAccountMetas[1];\n    mint: TAccountMetas[2];\n    mintAuthority: TAccountMetas[3];\n  };\n  data: InitializeTokenMetadataInstructionData;\n};\n\nexport function parseInitializeTokenMetadataInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeTokenMetadataInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      metadata: getNextAccount(),\n      updateAuthority: getNextAccount(),\n      mint: getNextAccount(),\n      mintAuthority: getNextAccount(),\n    },\n    data: getInitializeTokenMetadataInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_TRANSFER_FEE_CONFIG_DISCRIMINATOR = 26;\n\nexport function getInitializeTransferFeeConfigDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_TRANSFER_FEE_CONFIG_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_TRANSFER_FEE_CONFIG_TRANSFER_FEE_DISCRIMINATOR = 0;\n\nexport function getInitializeTransferFeeConfigTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_TRANSFER_FEE_CONFIG_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type InitializeTransferFeeConfigInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeTransferFeeConfigInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n  /** Pubkey that may update the fees. */\n  transferFeeConfigAuthority: Option<Address>;\n  /** Withdraw instructions must be signed by this key. */\n  withdrawWithheldAuthority: Option<Address>;\n  /** Amount of transfer collected as fees, expressed as basis points of the transfer amount. */\n  transferFeeBasisPoints: number;\n  /** Maximum fee assessed on transfers. */\n  maximumFee: bigint;\n};\n\nexport type InitializeTransferFeeConfigInstructionDataArgs = {\n  /** Pubkey that may update the fees. */\n  transferFeeConfigAuthority: OptionOrNullable<Address>;\n  /** Withdraw instructions must be signed by this key. */\n  withdrawWithheldAuthority: OptionOrNullable<Address>;\n  /** Amount of transfer collected as fees, expressed as basis points of the transfer amount. */\n  transferFeeBasisPoints: number;\n  /** Maximum fee assessed on transfers. */\n  maximumFee: number | bigint;\n};\n\nexport function getInitializeTransferFeeConfigInstructionDataEncoder(): Encoder<InitializeTransferFeeConfigInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n      ['transferFeeConfigAuthority', getOptionEncoder(getAddressEncoder())],\n      ['withdrawWithheldAuthority', getOptionEncoder(getAddressEncoder())],\n      ['transferFeeBasisPoints', getU16Encoder()],\n      ['maximumFee', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TRANSFER_FEE_CONFIG_DISCRIMINATOR,\n      transferFeeDiscriminator:\n        INITIALIZE_TRANSFER_FEE_CONFIG_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeTransferFeeConfigInstructionDataDecoder(): Decoder<InitializeTransferFeeConfigInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n    ['transferFeeConfigAuthority', getOptionDecoder(getAddressDecoder())],\n    ['withdrawWithheldAuthority', getOptionDecoder(getAddressDecoder())],\n    ['transferFeeBasisPoints', getU16Decoder()],\n    ['maximumFee', getU64Decoder()],\n  ]);\n}\n\nexport function getInitializeTransferFeeConfigInstructionDataCodec(): Codec<\n  InitializeTransferFeeConfigInstructionDataArgs,\n  InitializeTransferFeeConfigInstructionData\n> {\n  return combineCodec(\n    getInitializeTransferFeeConfigInstructionDataEncoder(),\n    getInitializeTransferFeeConfigInstructionDataDecoder()\n  );\n}\n\nexport type InitializeTransferFeeConfigInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  transferFeeConfigAuthority: InitializeTransferFeeConfigInstructionDataArgs['transferFeeConfigAuthority'];\n  withdrawWithheldAuthority: InitializeTransferFeeConfigInstructionDataArgs['withdrawWithheldAuthority'];\n  transferFeeBasisPoints: InitializeTransferFeeConfigInstructionDataArgs['transferFeeBasisPoints'];\n  maximumFee: InitializeTransferFeeConfigInstructionDataArgs['maximumFee'];\n};\n\nexport function getInitializeTransferFeeConfigInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeTransferFeeConfigInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeTransferFeeConfigInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeTransferFeeConfigInstructionDataEncoder().encode(\n      args as InitializeTransferFeeConfigInstructionDataArgs\n    ),\n  } as InitializeTransferFeeConfigInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeTransferFeeConfigInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeTransferFeeConfigInstructionData;\n};\n\nexport function parseInitializeTransferFeeConfigInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeTransferFeeConfigInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeTransferFeeConfigInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_TRANSFER_HOOK_DISCRIMINATOR = 36;\n\nexport function getInitializeTransferHookDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_TRANSFER_HOOK_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR = 0;\n\nexport function getInitializeTransferHookTransferHookDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR\n  );\n}\n\nexport type InitializeTransferHookInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeTransferHookInstructionData = {\n  discriminator: number;\n  transferHookDiscriminator: number;\n  /** The public key for the account that can update the program id */\n  authority: Option<Address>;\n  /** The program id that performs logic during transfers */\n  programId: Option<Address>;\n};\n\nexport type InitializeTransferHookInstructionDataArgs = {\n  /** The public key for the account that can update the program id */\n  authority: OptionOrNullable<Address>;\n  /** The program id that performs logic during transfers */\n  programId: OptionOrNullable<Address>;\n};\n\nexport function getInitializeTransferHookInstructionDataEncoder(): Encoder<InitializeTransferHookInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferHookDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      [\n        'programId',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TRANSFER_HOOK_DISCRIMINATOR,\n      transferHookDiscriminator:\n        INITIALIZE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeTransferHookInstructionDataDecoder(): Decoder<InitializeTransferHookInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferHookDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'programId',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeTransferHookInstructionDataCodec(): Codec<\n  InitializeTransferHookInstructionDataArgs,\n  InitializeTransferHookInstructionData\n> {\n  return combineCodec(\n    getInitializeTransferHookInstructionDataEncoder(),\n    getInitializeTransferHookInstructionDataDecoder()\n  );\n}\n\nexport type InitializeTransferHookInput<TAccountMint extends string = string> =\n  {\n    /** The mint to initialize. */\n    mint: Address<TAccountMint>;\n    authority: InitializeTransferHookInstructionDataArgs['authority'];\n    programId: InitializeTransferHookInstructionDataArgs['programId'];\n  };\n\nexport function getInitializeTransferHookInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeTransferHookInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeTransferHookInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeTransferHookInstructionDataEncoder().encode(\n      args as InitializeTransferHookInstructionDataArgs\n    ),\n  } as InitializeTransferHookInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeTransferHookInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeTransferHookInstructionData;\n};\n\nexport function parseInitializeTransferHookInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeTransferHookInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeTransferHookInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const MINT_TO_DISCRIMINATOR = 7;\n\nexport function getMintToDiscriminatorBytes() {\n  return getU8Encoder().encode(MINT_TO_DISCRIMINATOR);\n}\n\nexport type MintToInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountMintAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMintAuthority extends string\n        ? ReadonlyAccount<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type MintToInstructionData = {\n  discriminator: number;\n  /** The amount of new tokens to mint. */\n  amount: bigint;\n};\n\nexport type MintToInstructionDataArgs = {\n  /** The amount of new tokens to mint. */\n  amount: number | bigint;\n};\n\nexport function getMintToInstructionDataEncoder(): Encoder<MintToInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: MINT_TO_DISCRIMINATOR })\n  );\n}\n\nexport function getMintToInstructionDataDecoder(): Decoder<MintToInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getMintToInstructionDataCodec(): Codec<\n  MintToInstructionDataArgs,\n  MintToInstructionData\n> {\n  return combineCodec(\n    getMintToInstructionDataEncoder(),\n    getMintToInstructionDataDecoder()\n  );\n}\n\nexport type MintToInput<\n  TAccountMint extends string = string,\n  TAccountToken extends string = string,\n  TAccountMintAuthority extends string = string,\n> = {\n  /** The mint account. */\n  mint: Address<TAccountMint>;\n  /** The account to mint tokens to. */\n  token: Address<TAccountToken>;\n  /** The mint's minting authority or its multisignature account. */\n  mintAuthority:\n    | Address<TAccountMintAuthority>\n    | TransactionSigner<TAccountMintAuthority>;\n  amount: MintToInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getMintToInstruction<\n  TAccountMint extends string,\n  TAccountToken extends string,\n  TAccountMintAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: MintToInput<TAccountMint, TAccountToken, TAccountMintAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): MintToInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountToken,\n  (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n    ? ReadonlySignerAccount<TAccountMintAuthority> &\n        IAccountSignerMeta<TAccountMintAuthority>\n    : TAccountMintAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    token: { value: input.token ?? null, isWritable: true },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mintAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getMintToInstructionDataEncoder().encode(\n      args as MintToInstructionDataArgs\n    ),\n  } as MintToInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountToken,\n    (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n      ? ReadonlySignerAccount<TAccountMintAuthority> &\n          IAccountSignerMeta<TAccountMintAuthority>\n      : TAccountMintAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedMintToInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint account. */\n    mint: TAccountMetas[0];\n    /** The account to mint tokens to. */\n    token: TAccountMetas[1];\n    /** The mint's minting authority or its multisignature account. */\n    mintAuthority: TAccountMetas[2];\n  };\n  data: MintToInstructionData;\n};\n\nexport function parseMintToInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedMintToInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      token: getNextAccount(),\n      mintAuthority: getNextAccount(),\n    },\n    data: getMintToInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const MINT_TO_CHECKED_DISCRIMINATOR = 14;\n\nexport function getMintToCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(MINT_TO_CHECKED_DISCRIMINATOR);\n}\n\nexport type MintToCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountMintAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMintAuthority extends string\n        ? ReadonlyAccount<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type MintToCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of new tokens to mint. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type MintToCheckedInstructionDataArgs = {\n  /** The amount of new tokens to mint. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getMintToCheckedInstructionDataEncoder(): Encoder<MintToCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: MINT_TO_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getMintToCheckedInstructionDataDecoder(): Decoder<MintToCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getMintToCheckedInstructionDataCodec(): Codec<\n  MintToCheckedInstructionDataArgs,\n  MintToCheckedInstructionData\n> {\n  return combineCodec(\n    getMintToCheckedInstructionDataEncoder(),\n    getMintToCheckedInstructionDataDecoder()\n  );\n}\n\nexport type MintToCheckedInput<\n  TAccountMint extends string = string,\n  TAccountToken extends string = string,\n  TAccountMintAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The account to mint tokens to. */\n  token: Address<TAccountToken>;\n  /** The mint's minting authority or its multisignature account. */\n  mintAuthority:\n    | Address<TAccountMintAuthority>\n    | TransactionSigner<TAccountMintAuthority>;\n  amount: MintToCheckedInstructionDataArgs['amount'];\n  decimals: MintToCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getMintToCheckedInstruction<\n  TAccountMint extends string,\n  TAccountToken extends string,\n  TAccountMintAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: MintToCheckedInput<TAccountMint, TAccountToken, TAccountMintAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): MintToCheckedInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountToken,\n  (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n    ? ReadonlySignerAccount<TAccountMintAuthority> &\n        IAccountSignerMeta<TAccountMintAuthority>\n    : TAccountMintAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    token: { value: input.token ?? null, isWritable: true },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mintAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getMintToCheckedInstructionDataEncoder().encode(\n      args as MintToCheckedInstructionDataArgs\n    ),\n  } as MintToCheckedInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountToken,\n    (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n      ? ReadonlySignerAccount<TAccountMintAuthority> &\n          IAccountSignerMeta<TAccountMintAuthority>\n      : TAccountMintAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedMintToCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The account to mint tokens to. */\n    token: TAccountMetas[1];\n    /** The mint's minting authority or its multisignature account. */\n    mintAuthority: TAccountMetas[2];\n  };\n  data: MintToCheckedInstructionData;\n};\n\nexport function parseMintToCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedMintToCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      token: getNextAccount(),\n      mintAuthority: getNextAccount(),\n    },\n    data: getMintToCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getArrayDecoder,\n  getArrayEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getExtensionTypeDecoder,\n  getExtensionTypeEncoder,\n  type ExtensionType,\n  type ExtensionTypeArgs,\n} from '../types';\n\nexport const REALLOCATE_DISCRIMINATOR = 29;\n\nexport function getReallocateDiscriminatorBytes() {\n  return getU8Encoder().encode(REALLOCATE_DISCRIMINATOR);\n}\n\nexport type ReallocateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ReallocateInstructionData = {\n  discriminator: number;\n  /** New extension types to include in the reallocated account. */\n  newExtensionTypes: Array<ExtensionType>;\n};\n\nexport type ReallocateInstructionDataArgs = {\n  /** New extension types to include in the reallocated account. */\n  newExtensionTypes: Array<ExtensionTypeArgs>;\n};\n\nexport function getReallocateInstructionDataEncoder(): Encoder<ReallocateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      [\n        'newExtensionTypes',\n        getArrayEncoder(getExtensionTypeEncoder(), { size: 'remainder' }),\n      ],\n    ]),\n    (value) => ({ ...value, discriminator: REALLOCATE_DISCRIMINATOR })\n  );\n}\n\nexport function getReallocateInstructionDataDecoder(): Decoder<ReallocateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    [\n      'newExtensionTypes',\n      getArrayDecoder(getExtensionTypeDecoder(), { size: 'remainder' }),\n    ],\n  ]);\n}\n\nexport function getReallocateInstructionDataCodec(): Codec<\n  ReallocateInstructionDataArgs,\n  ReallocateInstructionData\n> {\n  return combineCodec(\n    getReallocateInstructionDataEncoder(),\n    getReallocateInstructionDataDecoder()\n  );\n}\n\nexport type ReallocateInput<\n  TAccountToken extends string = string,\n  TAccountPayer extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The token account to reallocate. */\n  token: Address<TAccountToken>;\n  /** The payer account to fund reallocation. */\n  payer: TransactionSigner<TAccountPayer>;\n  /** System program for reallocation funding. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** The account's owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  newExtensionTypes: ReallocateInstructionDataArgs['newExtensionTypes'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getReallocateInstruction<\n  TAccountToken extends string,\n  TAccountPayer extends string,\n  TAccountSystemProgram extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ReallocateInput<\n    TAccountToken,\n    TAccountPayer,\n    TAccountSystemProgram,\n    TAccountOwner\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ReallocateInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountPayer,\n  TAccountSystemProgram,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    payer: { value: input.payer ?? null, isWritable: true },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getReallocateInstructionDataEncoder().encode(\n      args as ReallocateInstructionDataArgs\n    ),\n  } as ReallocateInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountPayer,\n    TAccountSystemProgram,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedReallocateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token account to reallocate. */\n    token: TAccountMetas[0];\n    /** The payer account to fund reallocation. */\n    payer: TAccountMetas[1];\n    /** System program for reallocation funding. */\n    systemProgram: TAccountMetas[2];\n    /** The account's owner or its multisignature account. */\n    owner: TAccountMetas[3];\n  };\n  data: ReallocateInstructionData;\n};\n\nexport function parseReallocateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedReallocateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      payer: getNextAccount(),\n      systemProgram: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getReallocateInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { findAssociatedTokenPda } from '../pdas';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport {\n  expectAddress,\n  getAccountMetaFactory,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR = 2;\n\nexport function getRecoverNestedAssociatedTokenDiscriminatorBytes() {\n  return getU8Encoder().encode(RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR);\n}\n\nexport type RecoverNestedAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountNestedAssociatedAccountAddress extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountNestedTokenMintAddress extends string | IAccountMeta<string> = string,\n  TAccountDestinationAssociatedAccountAddress extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountOwnerAssociatedAccountAddress extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountOwnerTokenMintAddress extends string | IAccountMeta<string> = string,\n  TAccountWalletAddress extends string | IAccountMeta<string> = string,\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountNestedAssociatedAccountAddress extends string\n        ? WritableAccount<TAccountNestedAssociatedAccountAddress>\n        : TAccountNestedAssociatedAccountAddress,\n      TAccountNestedTokenMintAddress extends string\n        ? ReadonlyAccount<TAccountNestedTokenMintAddress>\n        : TAccountNestedTokenMintAddress,\n      TAccountDestinationAssociatedAccountAddress extends string\n        ? WritableAccount<TAccountDestinationAssociatedAccountAddress>\n        : TAccountDestinationAssociatedAccountAddress,\n      TAccountOwnerAssociatedAccountAddress extends string\n        ? ReadonlyAccount<TAccountOwnerAssociatedAccountAddress>\n        : TAccountOwnerAssociatedAccountAddress,\n      TAccountOwnerTokenMintAddress extends string\n        ? ReadonlyAccount<TAccountOwnerTokenMintAddress>\n        : TAccountOwnerTokenMintAddress,\n      TAccountWalletAddress extends string\n        ? WritableSignerAccount<TAccountWalletAddress> &\n            IAccountSignerMeta<TAccountWalletAddress>\n        : TAccountWalletAddress,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type RecoverNestedAssociatedTokenInstructionData = {\n  discriminator: number;\n};\n\nexport type RecoverNestedAssociatedTokenInstructionDataArgs = {};\n\nexport function getRecoverNestedAssociatedTokenInstructionDataEncoder(): Encoder<RecoverNestedAssociatedTokenInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getRecoverNestedAssociatedTokenInstructionDataDecoder(): Decoder<RecoverNestedAssociatedTokenInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getRecoverNestedAssociatedTokenInstructionDataCodec(): Codec<\n  RecoverNestedAssociatedTokenInstructionDataArgs,\n  RecoverNestedAssociatedTokenInstructionData\n> {\n  return combineCodec(\n    getRecoverNestedAssociatedTokenInstructionDataEncoder(),\n    getRecoverNestedAssociatedTokenInstructionDataDecoder()\n  );\n}\n\nexport type RecoverNestedAssociatedTokenAsyncInput<\n  TAccountNestedAssociatedAccountAddress extends string = string,\n  TAccountNestedTokenMintAddress extends string = string,\n  TAccountDestinationAssociatedAccountAddress extends string = string,\n  TAccountOwnerAssociatedAccountAddress extends string = string,\n  TAccountOwnerTokenMintAddress extends string = string,\n  TAccountWalletAddress extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Nested associated token account, must be owned by `ownerAssociatedAccountAddress`. */\n  nestedAssociatedAccountAddress?: Address<TAccountNestedAssociatedAccountAddress>;\n  /** Token mint for the nested associated token account. */\n  nestedTokenMintAddress: Address<TAccountNestedTokenMintAddress>;\n  /** Wallet's associated token account. */\n  destinationAssociatedAccountAddress?: Address<TAccountDestinationAssociatedAccountAddress>;\n  /** Owner associated token account address, must be owned by `walletAddress`. */\n  ownerAssociatedAccountAddress?: Address<TAccountOwnerAssociatedAccountAddress>;\n  /** Token mint for the owner associated token account. */\n  ownerTokenMintAddress: Address<TAccountOwnerTokenMintAddress>;\n  /** Wallet address for the owner associated token account. */\n  walletAddress: TransactionSigner<TAccountWalletAddress>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport async function getRecoverNestedAssociatedTokenInstructionAsync<\n  TAccountNestedAssociatedAccountAddress extends string,\n  TAccountNestedTokenMintAddress extends string,\n  TAccountDestinationAssociatedAccountAddress extends string,\n  TAccountOwnerAssociatedAccountAddress extends string,\n  TAccountOwnerTokenMintAddress extends string,\n  TAccountWalletAddress extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: RecoverNestedAssociatedTokenAsyncInput<\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): Promise<\n  RecoverNestedAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nestedAssociatedAccountAddress: {\n      value: input.nestedAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    nestedTokenMintAddress: {\n      value: input.nestedTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    destinationAssociatedAccountAddress: {\n      value: input.destinationAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    ownerAssociatedAccountAddress: {\n      value: input.ownerAssociatedAccountAddress ?? null,\n      isWritable: false,\n    },\n    ownerTokenMintAddress: {\n      value: input.ownerTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    walletAddress: { value: input.walletAddress ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n  if (!accounts.ownerAssociatedAccountAddress.value) {\n    accounts.ownerAssociatedAccountAddress.value = await findAssociatedTokenPda(\n      {\n        owner: expectAddress(accounts.walletAddress.value),\n        tokenProgram: expectAddress(accounts.tokenProgram.value),\n        mint: expectAddress(accounts.ownerTokenMintAddress.value),\n      }\n    );\n  }\n  if (!accounts.nestedAssociatedAccountAddress.value) {\n    accounts.nestedAssociatedAccountAddress.value =\n      await findAssociatedTokenPda({\n        owner: expectAddress(accounts.ownerAssociatedAccountAddress.value),\n        tokenProgram: expectAddress(accounts.tokenProgram.value),\n        mint: expectAddress(accounts.nestedTokenMintAddress.value),\n      });\n  }\n  if (!accounts.destinationAssociatedAccountAddress.value) {\n    accounts.destinationAssociatedAccountAddress.value =\n      await findAssociatedTokenPda({\n        owner: expectAddress(accounts.walletAddress.value),\n        tokenProgram: expectAddress(accounts.tokenProgram.value),\n        mint: expectAddress(accounts.nestedTokenMintAddress.value),\n      });\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.nestedAssociatedAccountAddress),\n      getAccountMeta(accounts.nestedTokenMintAddress),\n      getAccountMeta(accounts.destinationAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerTokenMintAddress),\n      getAccountMeta(accounts.walletAddress),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getRecoverNestedAssociatedTokenInstructionDataEncoder().encode({}),\n  } as RecoverNestedAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type RecoverNestedAssociatedTokenInput<\n  TAccountNestedAssociatedAccountAddress extends string = string,\n  TAccountNestedTokenMintAddress extends string = string,\n  TAccountDestinationAssociatedAccountAddress extends string = string,\n  TAccountOwnerAssociatedAccountAddress extends string = string,\n  TAccountOwnerTokenMintAddress extends string = string,\n  TAccountWalletAddress extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Nested associated token account, must be owned by `ownerAssociatedAccountAddress`. */\n  nestedAssociatedAccountAddress: Address<TAccountNestedAssociatedAccountAddress>;\n  /** Token mint for the nested associated token account. */\n  nestedTokenMintAddress: Address<TAccountNestedTokenMintAddress>;\n  /** Wallet's associated token account. */\n  destinationAssociatedAccountAddress: Address<TAccountDestinationAssociatedAccountAddress>;\n  /** Owner associated token account address, must be owned by `walletAddress`. */\n  ownerAssociatedAccountAddress: Address<TAccountOwnerAssociatedAccountAddress>;\n  /** Token mint for the owner associated token account. */\n  ownerTokenMintAddress: Address<TAccountOwnerTokenMintAddress>;\n  /** Wallet address for the owner associated token account. */\n  walletAddress: TransactionSigner<TAccountWalletAddress>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getRecoverNestedAssociatedTokenInstruction<\n  TAccountNestedAssociatedAccountAddress extends string,\n  TAccountNestedTokenMintAddress extends string,\n  TAccountDestinationAssociatedAccountAddress extends string,\n  TAccountOwnerAssociatedAccountAddress extends string,\n  TAccountOwnerTokenMintAddress extends string,\n  TAccountWalletAddress extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: RecoverNestedAssociatedTokenInput<\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): RecoverNestedAssociatedTokenInstruction<\n  TProgramAddress,\n  TAccountNestedAssociatedAccountAddress,\n  TAccountNestedTokenMintAddress,\n  TAccountDestinationAssociatedAccountAddress,\n  TAccountOwnerAssociatedAccountAddress,\n  TAccountOwnerTokenMintAddress,\n  TAccountWalletAddress,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nestedAssociatedAccountAddress: {\n      value: input.nestedAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    nestedTokenMintAddress: {\n      value: input.nestedTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    destinationAssociatedAccountAddress: {\n      value: input.destinationAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    ownerAssociatedAccountAddress: {\n      value: input.ownerAssociatedAccountAddress ?? null,\n      isWritable: false,\n    },\n    ownerTokenMintAddress: {\n      value: input.ownerTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    walletAddress: { value: input.walletAddress ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.nestedAssociatedAccountAddress),\n      getAccountMeta(accounts.nestedTokenMintAddress),\n      getAccountMeta(accounts.destinationAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerTokenMintAddress),\n      getAccountMeta(accounts.walletAddress),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getRecoverNestedAssociatedTokenInstructionDataEncoder().encode({}),\n  } as RecoverNestedAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedRecoverNestedAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Nested associated token account, must be owned by `ownerAssociatedAccountAddress`. */\n    nestedAssociatedAccountAddress: TAccountMetas[0];\n    /** Token mint for the nested associated token account. */\n    nestedTokenMintAddress: TAccountMetas[1];\n    /** Wallet's associated token account. */\n    destinationAssociatedAccountAddress: TAccountMetas[2];\n    /** Owner associated token account address, must be owned by `walletAddress`. */\n    ownerAssociatedAccountAddress: TAccountMetas[3];\n    /** Token mint for the owner associated token account. */\n    ownerTokenMintAddress: TAccountMetas[4];\n    /** Wallet address for the owner associated token account. */\n    walletAddress: TAccountMetas[5];\n    /** SPL Token program. */\n    tokenProgram: TAccountMetas[6];\n  };\n  data: RecoverNestedAssociatedTokenInstructionData;\n};\n\nexport function parseRecoverNestedAssociatedTokenInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedRecoverNestedAssociatedTokenInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 7) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nestedAssociatedAccountAddress: getNextAccount(),\n      nestedTokenMintAddress: getNextAccount(),\n      destinationAssociatedAccountAddress: getNextAccount(),\n      ownerAssociatedAccountAddress: getNextAccount(),\n      ownerTokenMintAddress: getNextAccount(),\n      walletAddress: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getRecoverNestedAssociatedTokenInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR = new Uint8Array([\n  234, 18, 32, 56, 89, 141, 37, 181,\n]);\n\nexport function getRemoveTokenMetadataKeyDiscriminatorBytes() {\n  return getBytesEncoder().encode(REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR);\n}\n\nexport type RemoveTokenMetadataKeyInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | IAccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMetadata extends string\n        ? WritableAccount<TAccountMetadata>\n        : TAccountMetadata,\n      TAccountUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountUpdateAuthority> &\n            IAccountSignerMeta<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type RemoveTokenMetadataKeyInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /**\n   * If the idempotent flag is set to true, then the instruction will not\n   * error if the key does not exist\n   */\n  idempotent: boolean;\n  /** Key to remove in the additional metadata portion. */\n  key: string;\n};\n\nexport type RemoveTokenMetadataKeyInstructionDataArgs = {\n  /**\n   * If the idempotent flag is set to true, then the instruction will not\n   * error if the key does not exist\n   */\n  idempotent?: boolean;\n  /** Key to remove in the additional metadata portion. */\n  key: string;\n};\n\nexport function getRemoveTokenMetadataKeyInstructionDataEncoder(): Encoder<RemoveTokenMetadataKeyInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      ['idempotent', getBooleanEncoder()],\n      ['key', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR,\n      idempotent: value.idempotent ?? false,\n    })\n  );\n}\n\nexport function getRemoveTokenMetadataKeyInstructionDataDecoder(): Decoder<RemoveTokenMetadataKeyInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    ['idempotent', getBooleanDecoder()],\n    ['key', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n  ]);\n}\n\nexport function getRemoveTokenMetadataKeyInstructionDataCodec(): Codec<\n  RemoveTokenMetadataKeyInstructionDataArgs,\n  RemoveTokenMetadataKeyInstructionData\n> {\n  return combineCodec(\n    getRemoveTokenMetadataKeyInstructionDataEncoder(),\n    getRemoveTokenMetadataKeyInstructionDataDecoder()\n  );\n}\n\nexport type RemoveTokenMetadataKeyInput<\n  TAccountMetadata extends string = string,\n  TAccountUpdateAuthority extends string = string,\n> = {\n  metadata: Address<TAccountMetadata>;\n  updateAuthority: TransactionSigner<TAccountUpdateAuthority>;\n  idempotent?: RemoveTokenMetadataKeyInstructionDataArgs['idempotent'];\n  key: RemoveTokenMetadataKeyInstructionDataArgs['key'];\n};\n\nexport function getRemoveTokenMetadataKeyInstruction<\n  TAccountMetadata extends string,\n  TAccountUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: RemoveTokenMetadataKeyInput<TAccountMetadata, TAccountUpdateAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): RemoveTokenMetadataKeyInstruction<\n  TProgramAddress,\n  TAccountMetadata,\n  TAccountUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.updateAuthority),\n    ],\n    programAddress,\n    data: getRemoveTokenMetadataKeyInstructionDataEncoder().encode(\n      args as RemoveTokenMetadataKeyInstructionDataArgs\n    ),\n  } as RemoveTokenMetadataKeyInstruction<\n    TProgramAddress,\n    TAccountMetadata,\n    TAccountUpdateAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedRemoveTokenMetadataKeyInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    metadata: TAccountMetas[0];\n    updateAuthority: TAccountMetas[1];\n  };\n  data: RemoveTokenMetadataKeyInstructionData;\n};\n\nexport function parseRemoveTokenMetadataKeyInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedRemoveTokenMetadataKeyInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      metadata: getNextAccount(),\n      updateAuthority: getNextAccount(),\n    },\n    data: getRemoveTokenMetadataKeyInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const REVOKE_DISCRIMINATOR = 5;\n\nexport function getRevokeDiscriminatorBytes() {\n  return getU8Encoder().encode(REVOKE_DISCRIMINATOR);\n}\n\nexport type RevokeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type RevokeInstructionData = { discriminator: number };\n\nexport type RevokeInstructionDataArgs = {};\n\nexport function getRevokeInstructionDataEncoder(): Encoder<RevokeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: REVOKE_DISCRIMINATOR })\n  );\n}\n\nexport function getRevokeInstructionDataDecoder(): Decoder<RevokeInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getRevokeInstructionDataCodec(): Codec<\n  RevokeInstructionDataArgs,\n  RevokeInstructionData\n> {\n  return combineCodec(\n    getRevokeInstructionDataEncoder(),\n    getRevokeInstructionDataDecoder()\n  );\n}\n\nexport type RevokeInput<\n  TAccountSource extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The source account owner or its multisignature. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getRevokeInstruction<\n  TAccountSource extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: RevokeInput<TAccountSource, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): RevokeInstruction<\n  TProgramAddress,\n  TAccountSource,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getRevokeInstructionDataEncoder().encode({}),\n  } as RevokeInstruction<\n    TProgramAddress,\n    TAccountSource,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedRevokeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The source account owner or its multisignature. */\n    owner: TAccountMetas[1];\n  };\n  data: RevokeInstructionData;\n};\n\nexport function parseRevokeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedRevokeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getRevokeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getAuthorityTypeDecoder,\n  getAuthorityTypeEncoder,\n  type AuthorityType,\n  type AuthorityTypeArgs,\n} from '../types';\n\nexport const SET_AUTHORITY_DISCRIMINATOR = 6;\n\nexport function getSetAuthorityDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_AUTHORITY_DISCRIMINATOR);\n}\n\nexport type SetAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountOwned extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountOwned extends string\n        ? WritableAccount<TAccountOwned>\n        : TAccountOwned,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetAuthorityInstructionData = {\n  discriminator: number;\n  /** The type of authority to update. */\n  authorityType: AuthorityType;\n  /** The new authority */\n  newAuthority: Option<Address>;\n};\n\nexport type SetAuthorityInstructionDataArgs = {\n  /** The type of authority to update. */\n  authorityType: AuthorityTypeArgs;\n  /** The new authority */\n  newAuthority: OptionOrNullable<Address>;\n};\n\nexport function getSetAuthorityInstructionDataEncoder(): Encoder<SetAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['authorityType', getAuthorityTypeEncoder()],\n      ['newAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({ ...value, discriminator: SET_AUTHORITY_DISCRIMINATOR })\n  );\n}\n\nexport function getSetAuthorityInstructionDataDecoder(): Decoder<SetAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['authorityType', getAuthorityTypeDecoder()],\n    ['newAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getSetAuthorityInstructionDataCodec(): Codec<\n  SetAuthorityInstructionDataArgs,\n  SetAuthorityInstructionData\n> {\n  return combineCodec(\n    getSetAuthorityInstructionDataEncoder(),\n    getSetAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type SetAuthorityInput<\n  TAccountOwned extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The mint or account to change the authority of. */\n  owned: Address<TAccountOwned>;\n  /** The current authority or the multisignature account of the mint or account to update. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  authorityType: SetAuthorityInstructionDataArgs['authorityType'];\n  newAuthority: SetAuthorityInstructionDataArgs['newAuthority'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getSetAuthorityInstruction<\n  TAccountOwned extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: SetAuthorityInput<TAccountOwned, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): SetAuthorityInstruction<\n  TProgramAddress,\n  TAccountOwned,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    owned: { value: input.owned ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.owned),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getSetAuthorityInstructionDataEncoder().encode(\n      args as SetAuthorityInstructionDataArgs\n    ),\n  } as SetAuthorityInstruction<\n    TProgramAddress,\n    TAccountOwned,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint or account to change the authority of. */\n    owned: TAccountMetas[0];\n    /** The current authority or the multisignature account of the mint or account to update. */\n    owner: TAccountMetas[1];\n  };\n  data: SetAuthorityInstructionData;\n};\n\nexport function parseSetAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      owned: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getSetAuthorityInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_TRANSFER_FEE_DISCRIMINATOR = 26;\n\nexport function getSetTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_TRANSFER_FEE_DISCRIMINATOR);\n}\n\nexport const SET_TRANSFER_FEE_TRANSFER_FEE_DISCRIMINATOR = 5;\n\nexport function getSetTransferFeeTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_TRANSFER_FEE_TRANSFER_FEE_DISCRIMINATOR);\n}\n\nexport type SetTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountTransferFeeConfigAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountTransferFeeConfigAuthority extends string\n        ? ReadonlyAccount<TAccountTransferFeeConfigAuthority>\n        : TAccountTransferFeeConfigAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetTransferFeeInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n  /** Amount of transfer collected as fees, expressed as basis points of the transfer amount. */\n  transferFeeBasisPoints: number;\n  /** Maximum fee assessed on transfers. */\n  maximumFee: bigint;\n};\n\nexport type SetTransferFeeInstructionDataArgs = {\n  /** Amount of transfer collected as fees, expressed as basis points of the transfer amount. */\n  transferFeeBasisPoints: number;\n  /** Maximum fee assessed on transfers. */\n  maximumFee: number | bigint;\n};\n\nexport function getSetTransferFeeInstructionDataEncoder(): Encoder<SetTransferFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n      ['transferFeeBasisPoints', getU16Encoder()],\n      ['maximumFee', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_TRANSFER_FEE_DISCRIMINATOR,\n      transferFeeDiscriminator: SET_TRANSFER_FEE_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetTransferFeeInstructionDataDecoder(): Decoder<SetTransferFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n    ['transferFeeBasisPoints', getU16Decoder()],\n    ['maximumFee', getU64Decoder()],\n  ]);\n}\n\nexport function getSetTransferFeeInstructionDataCodec(): Codec<\n  SetTransferFeeInstructionDataArgs,\n  SetTransferFeeInstructionData\n> {\n  return combineCodec(\n    getSetTransferFeeInstructionDataEncoder(),\n    getSetTransferFeeInstructionDataDecoder()\n  );\n}\n\nexport type SetTransferFeeInput<\n  TAccountMint extends string = string,\n  TAccountTransferFeeConfigAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The mint's fee account owner or its multisignature account. */\n  transferFeeConfigAuthority:\n    | Address<TAccountTransferFeeConfigAuthority>\n    | TransactionSigner<TAccountTransferFeeConfigAuthority>;\n  transferFeeBasisPoints: SetTransferFeeInstructionDataArgs['transferFeeBasisPoints'];\n  maximumFee: SetTransferFeeInstructionDataArgs['maximumFee'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getSetTransferFeeInstruction<\n  TAccountMint extends string,\n  TAccountTransferFeeConfigAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: SetTransferFeeInput<TAccountMint, TAccountTransferFeeConfigAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): SetTransferFeeInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['transferFeeConfigAuthority'] extends TransactionSigner<TAccountTransferFeeConfigAuthority>\n    ? ReadonlySignerAccount<TAccountTransferFeeConfigAuthority> &\n        IAccountSignerMeta<TAccountTransferFeeConfigAuthority>\n    : TAccountTransferFeeConfigAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    transferFeeConfigAuthority: {\n      value: input.transferFeeConfigAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.transferFeeConfigAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getSetTransferFeeInstructionDataEncoder().encode(\n      args as SetTransferFeeInstructionDataArgs\n    ),\n  } as SetTransferFeeInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['transferFeeConfigAuthority'] extends TransactionSigner<TAccountTransferFeeConfigAuthority>\n      ? ReadonlySignerAccount<TAccountTransferFeeConfigAuthority> &\n          IAccountSignerMeta<TAccountTransferFeeConfigAuthority>\n      : TAccountTransferFeeConfigAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The mint's fee account owner or its multisignature account. */\n    transferFeeConfigAuthority: TAccountMetas[1];\n  };\n  data: SetTransferFeeInstructionData;\n};\n\nexport function parseSetTransferFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetTransferFeeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      transferFeeConfigAuthority: getNextAccount(),\n    },\n    data: getSetTransferFeeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SYNC_NATIVE_DISCRIMINATOR = 17;\n\nexport function getSyncNativeDiscriminatorBytes() {\n  return getU8Encoder().encode(SYNC_NATIVE_DISCRIMINATOR);\n}\n\nexport type SyncNativeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SyncNativeInstructionData = { discriminator: number };\n\nexport type SyncNativeInstructionDataArgs = {};\n\nexport function getSyncNativeInstructionDataEncoder(): Encoder<SyncNativeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: SYNC_NATIVE_DISCRIMINATOR })\n  );\n}\n\nexport function getSyncNativeInstructionDataDecoder(): Decoder<SyncNativeInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getSyncNativeInstructionDataCodec(): Codec<\n  SyncNativeInstructionDataArgs,\n  SyncNativeInstructionData\n> {\n  return combineCodec(\n    getSyncNativeInstructionDataEncoder(),\n    getSyncNativeInstructionDataDecoder()\n  );\n}\n\nexport type SyncNativeInput<TAccountAccount extends string = string> = {\n  /** The native token account to sync with its underlying lamports. */\n  account: Address<TAccountAccount>;\n};\n\nexport function getSyncNativeInstruction<\n  TAccountAccount extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: SyncNativeInput<TAccountAccount>,\n  config?: { programAddress?: TProgramAddress }\n): SyncNativeInstruction<TProgramAddress, TAccountAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.account)],\n    programAddress,\n    data: getSyncNativeInstructionDataEncoder().encode({}),\n  } as SyncNativeInstruction<TProgramAddress, TAccountAccount>;\n\n  return instruction;\n}\n\nexport type ParsedSyncNativeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The native token account to sync with its underlying lamports. */\n    account: TAccountMetas[0];\n  };\n  data: SyncNativeInstructionData;\n};\n\nexport function parseSyncNativeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSyncNativeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n    },\n    data: getSyncNativeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const THAW_ACCOUNT_DISCRIMINATOR = 11;\n\nexport function getThawAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(THAW_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type ThawAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ThawAccountInstructionData = { discriminator: number };\n\nexport type ThawAccountInstructionDataArgs = {};\n\nexport function getThawAccountInstructionDataEncoder(): Encoder<ThawAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: THAW_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getThawAccountInstructionDataDecoder(): Decoder<ThawAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getThawAccountInstructionDataCodec(): Codec<\n  ThawAccountInstructionDataArgs,\n  ThawAccountInstructionData\n> {\n  return combineCodec(\n    getThawAccountInstructionDataEncoder(),\n    getThawAccountInstructionDataDecoder()\n  );\n}\n\nexport type ThawAccountInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The account to thaw. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The mint freeze authority or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getThawAccountInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ThawAccountInput<TAccountAccount, TAccountMint, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): ThawAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getThawAccountInstructionDataEncoder().encode({}),\n  } as ThawAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedThawAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to thaw. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The mint freeze authority or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: ThawAccountInstructionData;\n};\n\nexport function parseThawAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedThawAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getThawAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_DISCRIMINATOR = 3;\n\nexport function getTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(TRANSFER_DISCRIMINATOR);\n}\n\nexport type TransferInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | IAccountMeta<string> = string,\n  TAccountDestination extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to transfer. */\n  amount: bigint;\n};\n\nexport type TransferInstructionDataArgs = {\n  /** The amount of tokens to transfer. */\n  amount: number | bigint;\n};\n\nexport function getTransferInstructionDataEncoder(): Encoder<TransferInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: TRANSFER_DISCRIMINATOR })\n  );\n}\n\nexport function getTransferInstructionDataDecoder(): Decoder<TransferInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getTransferInstructionDataCodec(): Codec<\n  TransferInstructionDataArgs,\n  TransferInstructionData\n> {\n  return combineCodec(\n    getTransferInstructionDataEncoder(),\n    getTransferInstructionDataDecoder()\n  );\n}\n\nexport type TransferInput<\n  TAccountSource extends string = string,\n  TAccountDestination extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The destination account. */\n  destination: Address<TAccountDestination>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: TransferInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getTransferInstruction<\n  TAccountSource extends string,\n  TAccountDestination extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: TransferInput<TAccountSource, TAccountDestination, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): TransferInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountDestination,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getTransferInstructionDataEncoder().encode(\n      args as TransferInstructionDataArgs\n    ),\n  } as TransferInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountDestination,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedTransferInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The destination account. */\n    destination: TAccountMetas[1];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: TransferInstructionData;\n};\n\nexport function parseTransferInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedTransferInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      destination: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getTransferInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_CHECKED_DISCRIMINATOR = 12;\n\nexport function getTransferCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(TRANSFER_CHECKED_DISCRIMINATOR);\n}\n\nexport type TransferCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountDestination extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to transfer. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type TransferCheckedInstructionDataArgs = {\n  /** The amount of tokens to transfer. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getTransferCheckedInstructionDataEncoder(): Encoder<TransferCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: TRANSFER_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getTransferCheckedInstructionDataDecoder(): Decoder<TransferCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getTransferCheckedInstructionDataCodec(): Codec<\n  TransferCheckedInstructionDataArgs,\n  TransferCheckedInstructionData\n> {\n  return combineCodec(\n    getTransferCheckedInstructionDataEncoder(),\n    getTransferCheckedInstructionDataDecoder()\n  );\n}\n\nexport type TransferCheckedInput<\n  TAccountSource extends string = string,\n  TAccountMint extends string = string,\n  TAccountDestination extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The destination account. */\n  destination: Address<TAccountDestination>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: TransferCheckedInstructionDataArgs['amount'];\n  decimals: TransferCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getTransferCheckedInstruction<\n  TAccountSource extends string,\n  TAccountMint extends string,\n  TAccountDestination extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: TransferCheckedInput<\n    TAccountSource,\n    TAccountMint,\n    TAccountDestination,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): TransferCheckedInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountMint,\n  TAccountDestination,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destination: { value: input.destination ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getTransferCheckedInstructionDataEncoder().encode(\n      args as TransferCheckedInstructionDataArgs\n    ),\n  } as TransferCheckedInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountMint,\n    TAccountDestination,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedTransferCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The destination account. */\n    destination: TAccountMetas[2];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[3];\n  };\n  data: TransferCheckedInstructionData;\n};\n\nexport function parseTransferCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedTransferCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getTransferCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_CHECKED_WITH_FEE_DISCRIMINATOR = 26;\n\nexport function getTransferCheckedWithFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(TRANSFER_CHECKED_WITH_FEE_DISCRIMINATOR);\n}\n\nexport const TRANSFER_CHECKED_WITH_FEE_TRANSFER_FEE_DISCRIMINATOR = 1;\n\nexport function getTransferCheckedWithFeeTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    TRANSFER_CHECKED_WITH_FEE_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type TransferCheckedWithFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountDestination extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferCheckedWithFeeInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n  /** The amount of tokens to transfer. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /**\n   * Expected fee assessed on this transfer, calculated off-chain based\n   * on the transfer_fee_basis_points and maximum_fee of the mint. May\n   * be 0 for a mint without a configured transfer fee.\n   */\n  fee: bigint;\n};\n\nexport type TransferCheckedWithFeeInstructionDataArgs = {\n  /** The amount of tokens to transfer. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /**\n   * Expected fee assessed on this transfer, calculated off-chain based\n   * on the transfer_fee_basis_points and maximum_fee of the mint. May\n   * be 0 for a mint without a configured transfer fee.\n   */\n  fee: number | bigint;\n};\n\nexport function getTransferCheckedWithFeeInstructionDataEncoder(): Encoder<TransferCheckedWithFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n      ['fee', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: TRANSFER_CHECKED_WITH_FEE_DISCRIMINATOR,\n      transferFeeDiscriminator:\n        TRANSFER_CHECKED_WITH_FEE_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getTransferCheckedWithFeeInstructionDataDecoder(): Decoder<TransferCheckedWithFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n    ['fee', getU64Decoder()],\n  ]);\n}\n\nexport function getTransferCheckedWithFeeInstructionDataCodec(): Codec<\n  TransferCheckedWithFeeInstructionDataArgs,\n  TransferCheckedWithFeeInstructionData\n> {\n  return combineCodec(\n    getTransferCheckedWithFeeInstructionDataEncoder(),\n    getTransferCheckedWithFeeInstructionDataDecoder()\n  );\n}\n\nexport type TransferCheckedWithFeeInput<\n  TAccountSource extends string = string,\n  TAccountMint extends string = string,\n  TAccountDestination extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source account. May include the `TransferFeeAmount` extension. */\n  source: Address<TAccountSource>;\n  /** The token mint. May include the `TransferFeeConfig` extension. */\n  mint: Address<TAccountMint>;\n  /** The destination account. May include the `TransferFeeAmount` extension. */\n  destination: Address<TAccountDestination>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: TransferCheckedWithFeeInstructionDataArgs['amount'];\n  decimals: TransferCheckedWithFeeInstructionDataArgs['decimals'];\n  fee: TransferCheckedWithFeeInstructionDataArgs['fee'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getTransferCheckedWithFeeInstruction<\n  TAccountSource extends string,\n  TAccountMint extends string,\n  TAccountDestination extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: TransferCheckedWithFeeInput<\n    TAccountSource,\n    TAccountMint,\n    TAccountDestination,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): TransferCheckedWithFeeInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountMint,\n  TAccountDestination,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destination: { value: input.destination ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getTransferCheckedWithFeeInstructionDataEncoder().encode(\n      args as TransferCheckedWithFeeInstructionDataArgs\n    ),\n  } as TransferCheckedWithFeeInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountMint,\n    TAccountDestination,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedTransferCheckedWithFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. May include the `TransferFeeAmount` extension. */\n    source: TAccountMetas[0];\n    /** The token mint. May include the `TransferFeeConfig` extension. */\n    mint: TAccountMetas[1];\n    /** The destination account. May include the `TransferFeeAmount` extension. */\n    destination: TAccountMetas[2];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[3];\n  };\n  data: TransferCheckedWithFeeInstructionData;\n};\n\nexport function parseTransferCheckedWithFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedTransferCheckedWithFeeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getTransferCheckedWithFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR = 24;\n\nexport function getUiAmountToAmountDiscriminatorBytes() {\n  return getU8Encoder().encode(UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR);\n}\n\nexport type UiAmountToAmountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UiAmountToAmountInstructionData = {\n  discriminator: number;\n  /** The ui_amount of tokens to reformat. */\n  uiAmount: string;\n};\n\nexport type UiAmountToAmountInstructionDataArgs = {\n  /** The ui_amount of tokens to reformat. */\n  uiAmount: string;\n};\n\nexport function getUiAmountToAmountInstructionDataEncoder(): Encoder<UiAmountToAmountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['uiAmount', getUtf8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getUiAmountToAmountInstructionDataDecoder(): Decoder<UiAmountToAmountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['uiAmount', getUtf8Decoder()],\n  ]);\n}\n\nexport function getUiAmountToAmountInstructionDataCodec(): Codec<\n  UiAmountToAmountInstructionDataArgs,\n  UiAmountToAmountInstructionData\n> {\n  return combineCodec(\n    getUiAmountToAmountInstructionDataEncoder(),\n    getUiAmountToAmountInstructionDataDecoder()\n  );\n}\n\nexport type UiAmountToAmountInput<TAccountMint extends string = string> = {\n  /** The mint to calculate for. */\n  mint: Address<TAccountMint>;\n  uiAmount: UiAmountToAmountInstructionDataArgs['uiAmount'];\n};\n\nexport function getUiAmountToAmountInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UiAmountToAmountInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): UiAmountToAmountInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getUiAmountToAmountInstructionDataEncoder().encode(\n      args as UiAmountToAmountInstructionDataArgs\n    ),\n  } as UiAmountToAmountInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedUiAmountToAmountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to calculate for. */\n    mint: TAccountMetas[0];\n  };\n  data: UiAmountToAmountInstructionData;\n};\n\nexport function parseUiAmountToAmountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUiAmountToAmountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getUiAmountToAmountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR = 27;\n\nexport function getUpdateConfidentialTransferMintDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR);\n}\n\nexport const UPDATE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 1;\n\nexport function getUpdateConfidentialTransferMintConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type UpdateConfidentialTransferMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlySignerAccount<TAccountAuthority> &\n            IAccountSignerMeta<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateConfidentialTransferMintInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /**\n   * Determines if newly configured accounts must be approved by the\n   * `authority` before they may be used by the user.\n   */\n  autoApproveNewAccounts: boolean;\n  /** New authority to decode any transfer amount in a confidential transfer. */\n  auditorElgamalPubkey: Option<Address>;\n};\n\nexport type UpdateConfidentialTransferMintInstructionDataArgs = {\n  /**\n   * Determines if newly configured accounts must be approved by the\n   * `authority` before they may be used by the user.\n   */\n  autoApproveNewAccounts: boolean;\n  /** New authority to decode any transfer amount in a confidential transfer. */\n  auditorElgamalPubkey: OptionOrNullable<Address>;\n};\n\nexport function getUpdateConfidentialTransferMintInstructionDataEncoder(): Encoder<UpdateConfidentialTransferMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['autoApproveNewAccounts', getBooleanEncoder()],\n      [\n        'auditorElgamalPubkey',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        UPDATE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateConfidentialTransferMintInstructionDataDecoder(): Decoder<UpdateConfidentialTransferMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['autoApproveNewAccounts', getBooleanDecoder()],\n    [\n      'auditorElgamalPubkey',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateConfidentialTransferMintInstructionDataCodec(): Codec<\n  UpdateConfidentialTransferMintInstructionDataArgs,\n  UpdateConfidentialTransferMintInstructionData\n> {\n  return combineCodec(\n    getUpdateConfidentialTransferMintInstructionDataEncoder(),\n    getUpdateConfidentialTransferMintInstructionDataDecoder()\n  );\n}\n\nexport type UpdateConfidentialTransferMintInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /** Confidential transfer mint authority. */\n  authority: TransactionSigner<TAccountAuthority>;\n  autoApproveNewAccounts: UpdateConfidentialTransferMintInstructionDataArgs['autoApproveNewAccounts'];\n  auditorElgamalPubkey: UpdateConfidentialTransferMintInstructionDataArgs['auditorElgamalPubkey'];\n};\n\nexport function getUpdateConfidentialTransferMintInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateConfidentialTransferMintInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateConfidentialTransferMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n    ],\n    programAddress,\n    data: getUpdateConfidentialTransferMintInstructionDataEncoder().encode(\n      args as UpdateConfidentialTransferMintInstructionDataArgs\n    ),\n  } as UpdateConfidentialTransferMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateConfidentialTransferMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token mint. */\n    mint: TAccountMetas[0];\n    /** Confidential transfer mint authority. */\n    authority: TAccountMetas[1];\n  };\n  data: UpdateConfidentialTransferMintInstructionData;\n};\n\nexport function parseUpdateConfidentialTransferMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateConfidentialTransferMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getUpdateConfidentialTransferMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getAccountStateDecoder,\n  getAccountStateEncoder,\n  type AccountState,\n  type AccountStateArgs,\n} from '../types';\n\nexport const UPDATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 28;\n\nexport function getUpdateDefaultAccountStateDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR);\n}\n\nexport const UPDATE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 1;\n\nexport function getUpdateDefaultAccountStateDefaultAccountStateDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR\n  );\n}\n\nexport type UpdateDefaultAccountStateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountFreezeAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountFreezeAuthority extends string\n        ? ReadonlyAccount<TAccountFreezeAuthority>\n        : TAccountFreezeAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateDefaultAccountStateInstructionData = {\n  discriminator: number;\n  defaultAccountStateDiscriminator: number;\n  /** The state each new token account should start with. */\n  state: AccountState;\n};\n\nexport type UpdateDefaultAccountStateInstructionDataArgs = {\n  /** The state each new token account should start with. */\n  state: AccountStateArgs;\n};\n\nexport function getUpdateDefaultAccountStateInstructionDataEncoder(): Encoder<UpdateDefaultAccountStateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['defaultAccountStateDiscriminator', getU8Encoder()],\n      ['state', getAccountStateEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR,\n      defaultAccountStateDiscriminator:\n        UPDATE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateDefaultAccountStateInstructionDataDecoder(): Decoder<UpdateDefaultAccountStateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['defaultAccountStateDiscriminator', getU8Decoder()],\n    ['state', getAccountStateDecoder()],\n  ]);\n}\n\nexport function getUpdateDefaultAccountStateInstructionDataCodec(): Codec<\n  UpdateDefaultAccountStateInstructionDataArgs,\n  UpdateDefaultAccountStateInstructionData\n> {\n  return combineCodec(\n    getUpdateDefaultAccountStateInstructionDataEncoder(),\n    getUpdateDefaultAccountStateInstructionDataDecoder()\n  );\n}\n\nexport type UpdateDefaultAccountStateInput<\n  TAccountMint extends string = string,\n  TAccountFreezeAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The mint freeze authority or its multisignature account. */\n  freezeAuthority:\n    | Address<TAccountFreezeAuthority>\n    | TransactionSigner<TAccountFreezeAuthority>;\n  state: UpdateDefaultAccountStateInstructionDataArgs['state'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateDefaultAccountStateInstruction<\n  TAccountMint extends string,\n  TAccountFreezeAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateDefaultAccountStateInput<TAccountMint, TAccountFreezeAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateDefaultAccountStateInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['freezeAuthority'] extends TransactionSigner<TAccountFreezeAuthority>\n    ? ReadonlySignerAccount<TAccountFreezeAuthority> &\n        IAccountSignerMeta<TAccountFreezeAuthority>\n    : TAccountFreezeAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    freezeAuthority: {\n      value: input.freezeAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.freezeAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getUpdateDefaultAccountStateInstructionDataEncoder().encode(\n      args as UpdateDefaultAccountStateInstructionDataArgs\n    ),\n  } as UpdateDefaultAccountStateInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['freezeAuthority'] extends TransactionSigner<TAccountFreezeAuthority>\n      ? ReadonlySignerAccount<TAccountFreezeAuthority> &\n          IAccountSignerMeta<TAccountFreezeAuthority>\n      : TAccountFreezeAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateDefaultAccountStateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The mint freeze authority or its multisignature account. */\n    freezeAuthority: TAccountMetas[1];\n  };\n  data: UpdateDefaultAccountStateInstructionData;\n};\n\nexport function parseUpdateDefaultAccountStateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateDefaultAccountStateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      freezeAuthority: getNextAccount(),\n    },\n    data: getUpdateDefaultAccountStateInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_GROUP_MEMBER_POINTER_DISCRIMINATOR = 41;\n\nexport function getUpdateGroupMemberPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_GROUP_MEMBER_POINTER_DISCRIMINATOR);\n}\n\nexport const UPDATE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR = 1;\n\nexport function getUpdateGroupMemberPointerGroupMemberPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type UpdateGroupMemberPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountGroupMemberPointerAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountGroupMemberPointerAuthority extends string\n        ? ReadonlyAccount<TAccountGroupMemberPointerAuthority>\n        : TAccountGroupMemberPointerAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateGroupMemberPointerInstructionData = {\n  discriminator: number;\n  groupMemberPointerDiscriminator: number;\n  /** The new account address that holds the member. */\n  memberAddress: Option<Address>;\n};\n\nexport type UpdateGroupMemberPointerInstructionDataArgs = {\n  /** The new account address that holds the member. */\n  memberAddress: OptionOrNullable<Address>;\n};\n\nexport function getUpdateGroupMemberPointerInstructionDataEncoder(): Encoder<UpdateGroupMemberPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['groupMemberPointerDiscriminator', getU8Encoder()],\n      [\n        'memberAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_GROUP_MEMBER_POINTER_DISCRIMINATOR,\n      groupMemberPointerDiscriminator:\n        UPDATE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateGroupMemberPointerInstructionDataDecoder(): Decoder<UpdateGroupMemberPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['groupMemberPointerDiscriminator', getU8Decoder()],\n    [\n      'memberAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateGroupMemberPointerInstructionDataCodec(): Codec<\n  UpdateGroupMemberPointerInstructionDataArgs,\n  UpdateGroupMemberPointerInstructionData\n> {\n  return combineCodec(\n    getUpdateGroupMemberPointerInstructionDataEncoder(),\n    getUpdateGroupMemberPointerInstructionDataDecoder()\n  );\n}\n\nexport type UpdateGroupMemberPointerInput<\n  TAccountMint extends string = string,\n  TAccountGroupMemberPointerAuthority extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  /** The group member pointer authority or its multisignature account. */\n  groupMemberPointerAuthority:\n    | Address<TAccountGroupMemberPointerAuthority>\n    | TransactionSigner<TAccountGroupMemberPointerAuthority>;\n  memberAddress: UpdateGroupMemberPointerInstructionDataArgs['memberAddress'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateGroupMemberPointerInstruction<\n  TAccountMint extends string,\n  TAccountGroupMemberPointerAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateGroupMemberPointerInput<\n    TAccountMint,\n    TAccountGroupMemberPointerAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateGroupMemberPointerInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['groupMemberPointerAuthority'] extends TransactionSigner<TAccountGroupMemberPointerAuthority>\n    ? ReadonlySignerAccount<TAccountGroupMemberPointerAuthority> &\n        IAccountSignerMeta<TAccountGroupMemberPointerAuthority>\n    : TAccountGroupMemberPointerAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    groupMemberPointerAuthority: {\n      value: input.groupMemberPointerAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.groupMemberPointerAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getUpdateGroupMemberPointerInstructionDataEncoder().encode(\n      args as UpdateGroupMemberPointerInstructionDataArgs\n    ),\n  } as UpdateGroupMemberPointerInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['groupMemberPointerAuthority'] extends TransactionSigner<TAccountGroupMemberPointerAuthority>\n      ? ReadonlySignerAccount<TAccountGroupMemberPointerAuthority> &\n          IAccountSignerMeta<TAccountGroupMemberPointerAuthority>\n      : TAccountGroupMemberPointerAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateGroupMemberPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n    /** The group member pointer authority or its multisignature account. */\n    groupMemberPointerAuthority: TAccountMetas[1];\n  };\n  data: UpdateGroupMemberPointerInstructionData;\n};\n\nexport function parseUpdateGroupMemberPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateGroupMemberPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      groupMemberPointerAuthority: getNextAccount(),\n    },\n    data: getUpdateGroupMemberPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_GROUP_POINTER_DISCRIMINATOR = 40;\n\nexport function getUpdateGroupPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_GROUP_POINTER_DISCRIMINATOR);\n}\n\nexport const UPDATE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR = 1;\n\nexport function getUpdateGroupPointerGroupPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type UpdateGroupPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountGroupPointerAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountGroupPointerAuthority extends string\n        ? ReadonlyAccount<TAccountGroupPointerAuthority>\n        : TAccountGroupPointerAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateGroupPointerInstructionData = {\n  discriminator: number;\n  groupPointerDiscriminator: number;\n  /** The new account address that holds the group configurations. */\n  groupAddress: Option<Address>;\n};\n\nexport type UpdateGroupPointerInstructionDataArgs = {\n  /** The new account address that holds the group configurations. */\n  groupAddress: OptionOrNullable<Address>;\n};\n\nexport function getUpdateGroupPointerInstructionDataEncoder(): Encoder<UpdateGroupPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['groupPointerDiscriminator', getU8Encoder()],\n      [\n        'groupAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_GROUP_POINTER_DISCRIMINATOR,\n      groupPointerDiscriminator:\n        UPDATE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateGroupPointerInstructionDataDecoder(): Decoder<UpdateGroupPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['groupPointerDiscriminator', getU8Decoder()],\n    [\n      'groupAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateGroupPointerInstructionDataCodec(): Codec<\n  UpdateGroupPointerInstructionDataArgs,\n  UpdateGroupPointerInstructionData\n> {\n  return combineCodec(\n    getUpdateGroupPointerInstructionDataEncoder(),\n    getUpdateGroupPointerInstructionDataDecoder()\n  );\n}\n\nexport type UpdateGroupPointerInput<\n  TAccountMint extends string = string,\n  TAccountGroupPointerAuthority extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  /** The group pointer authority or its multisignature account. */\n  groupPointerAuthority:\n    | Address<TAccountGroupPointerAuthority>\n    | TransactionSigner<TAccountGroupPointerAuthority>;\n  groupAddress: UpdateGroupPointerInstructionDataArgs['groupAddress'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateGroupPointerInstruction<\n  TAccountMint extends string,\n  TAccountGroupPointerAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateGroupPointerInput<TAccountMint, TAccountGroupPointerAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateGroupPointerInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['groupPointerAuthority'] extends TransactionSigner<TAccountGroupPointerAuthority>\n    ? ReadonlySignerAccount<TAccountGroupPointerAuthority> &\n        IAccountSignerMeta<TAccountGroupPointerAuthority>\n    : TAccountGroupPointerAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    groupPointerAuthority: {\n      value: input.groupPointerAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.groupPointerAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getUpdateGroupPointerInstructionDataEncoder().encode(\n      args as UpdateGroupPointerInstructionDataArgs\n    ),\n  } as UpdateGroupPointerInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['groupPointerAuthority'] extends TransactionSigner<TAccountGroupPointerAuthority>\n      ? ReadonlySignerAccount<TAccountGroupPointerAuthority> &\n          IAccountSignerMeta<TAccountGroupPointerAuthority>\n      : TAccountGroupPointerAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateGroupPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n    /** The group pointer authority or its multisignature account. */\n    groupPointerAuthority: TAccountMetas[1];\n  };\n  data: UpdateGroupPointerInstructionData;\n};\n\nexport function parseUpdateGroupPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateGroupPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      groupPointerAuthority: getNextAccount(),\n    },\n    data: getUpdateGroupPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_METADATA_POINTER_DISCRIMINATOR = 39;\n\nexport function getUpdateMetadataPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_METADATA_POINTER_DISCRIMINATOR);\n}\n\nexport const UPDATE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR = 1;\n\nexport function getUpdateMetadataPointerMetadataPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type UpdateMetadataPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountMetadataPointerAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountMetadataPointerAuthority extends string\n        ? ReadonlyAccount<TAccountMetadataPointerAuthority>\n        : TAccountMetadataPointerAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateMetadataPointerInstructionData = {\n  discriminator: number;\n  metadataPointerDiscriminator: number;\n  /** The new account address that holds the metadata. */\n  metadataAddress: Option<Address>;\n};\n\nexport type UpdateMetadataPointerInstructionDataArgs = {\n  /** The new account address that holds the metadata. */\n  metadataAddress: OptionOrNullable<Address>;\n};\n\nexport function getUpdateMetadataPointerInstructionDataEncoder(): Encoder<UpdateMetadataPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['metadataPointerDiscriminator', getU8Encoder()],\n      [\n        'metadataAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_METADATA_POINTER_DISCRIMINATOR,\n      metadataPointerDiscriminator:\n        UPDATE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateMetadataPointerInstructionDataDecoder(): Decoder<UpdateMetadataPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['metadataPointerDiscriminator', getU8Decoder()],\n    [\n      'metadataAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateMetadataPointerInstructionDataCodec(): Codec<\n  UpdateMetadataPointerInstructionDataArgs,\n  UpdateMetadataPointerInstructionData\n> {\n  return combineCodec(\n    getUpdateMetadataPointerInstructionDataEncoder(),\n    getUpdateMetadataPointerInstructionDataDecoder()\n  );\n}\n\nexport type UpdateMetadataPointerInput<\n  TAccountMint extends string = string,\n  TAccountMetadataPointerAuthority extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  /** The metadata pointer authority or its multisignature account. */\n  metadataPointerAuthority:\n    | Address<TAccountMetadataPointerAuthority>\n    | TransactionSigner<TAccountMetadataPointerAuthority>;\n  metadataAddress: UpdateMetadataPointerInstructionDataArgs['metadataAddress'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateMetadataPointerInstruction<\n  TAccountMint extends string,\n  TAccountMetadataPointerAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateMetadataPointerInput<\n    TAccountMint,\n    TAccountMetadataPointerAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateMetadataPointerInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['metadataPointerAuthority'] extends TransactionSigner<TAccountMetadataPointerAuthority>\n    ? ReadonlySignerAccount<TAccountMetadataPointerAuthority> &\n        IAccountSignerMeta<TAccountMetadataPointerAuthority>\n    : TAccountMetadataPointerAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    metadataPointerAuthority: {\n      value: input.metadataPointerAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.metadataPointerAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getUpdateMetadataPointerInstructionDataEncoder().encode(\n      args as UpdateMetadataPointerInstructionDataArgs\n    ),\n  } as UpdateMetadataPointerInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['metadataPointerAuthority'] extends TransactionSigner<TAccountMetadataPointerAuthority>\n      ? ReadonlySignerAccount<TAccountMetadataPointerAuthority> &\n          IAccountSignerMeta<TAccountMetadataPointerAuthority>\n      : TAccountMetadataPointerAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateMetadataPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n    /** The metadata pointer authority or its multisignature account. */\n    metadataPointerAuthority: TAccountMetas[1];\n  };\n  data: UpdateMetadataPointerInstructionData;\n};\n\nexport function parseUpdateMetadataPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateMetadataPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      metadataPointerAuthority: getNextAccount(),\n    },\n    data: getUpdateMetadataPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI16Decoder,\n  getI16Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_RATE_INTEREST_BEARING_MINT_DISCRIMINATOR = 33;\n\nexport function getUpdateRateInterestBearingMintDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_RATE_INTEREST_BEARING_MINT_DISCRIMINATOR);\n}\n\nexport const UPDATE_RATE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR = 1;\n\nexport function getUpdateRateInterestBearingMintInterestBearingMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_RATE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR\n  );\n}\n\nexport type UpdateRateInterestBearingMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountRateAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountRateAuthority extends string\n        ? WritableAccount<TAccountRateAuthority>\n        : TAccountRateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateRateInterestBearingMintInstructionData = {\n  discriminator: number;\n  interestBearingMintDiscriminator: number;\n  /** The interest rate to update. */\n  rate: number;\n};\n\nexport type UpdateRateInterestBearingMintInstructionDataArgs = {\n  /** The interest rate to update. */\n  rate: number;\n};\n\nexport function getUpdateRateInterestBearingMintInstructionDataEncoder(): Encoder<UpdateRateInterestBearingMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['interestBearingMintDiscriminator', getU8Encoder()],\n      ['rate', getI16Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_RATE_INTEREST_BEARING_MINT_DISCRIMINATOR,\n      interestBearingMintDiscriminator:\n        UPDATE_RATE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateRateInterestBearingMintInstructionDataDecoder(): Decoder<UpdateRateInterestBearingMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['interestBearingMintDiscriminator', getU8Decoder()],\n    ['rate', getI16Decoder()],\n  ]);\n}\n\nexport function getUpdateRateInterestBearingMintInstructionDataCodec(): Codec<\n  UpdateRateInterestBearingMintInstructionDataArgs,\n  UpdateRateInterestBearingMintInstructionData\n> {\n  return combineCodec(\n    getUpdateRateInterestBearingMintInstructionDataEncoder(),\n    getUpdateRateInterestBearingMintInstructionDataDecoder()\n  );\n}\n\nexport type UpdateRateInterestBearingMintInput<\n  TAccountMint extends string = string,\n  TAccountRateAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The mint rate authority. */\n  rateAuthority:\n    | Address<TAccountRateAuthority>\n    | TransactionSigner<TAccountRateAuthority>;\n  rate: UpdateRateInterestBearingMintInstructionDataArgs['rate'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateRateInterestBearingMintInstruction<\n  TAccountMint extends string,\n  TAccountRateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateRateInterestBearingMintInput<\n    TAccountMint,\n    TAccountRateAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateRateInterestBearingMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['rateAuthority'] extends TransactionSigner<TAccountRateAuthority>\n    ? WritableSignerAccount<TAccountRateAuthority> &\n        IAccountSignerMeta<TAccountRateAuthority>\n    : TAccountRateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    rateAuthority: { value: input.rateAuthority ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.rateAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getUpdateRateInterestBearingMintInstructionDataEncoder().encode(\n      args as UpdateRateInterestBearingMintInstructionDataArgs\n    ),\n  } as UpdateRateInterestBearingMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['rateAuthority'] extends TransactionSigner<TAccountRateAuthority>\n      ? WritableSignerAccount<TAccountRateAuthority> &\n          IAccountSignerMeta<TAccountRateAuthority>\n      : TAccountRateAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateRateInterestBearingMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The mint rate authority. */\n    rateAuthority: TAccountMetas[1];\n  };\n  data: UpdateRateInterestBearingMintInstructionData;\n};\n\nexport function parseUpdateRateInterestBearingMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateRateInterestBearingMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      rateAuthority: getNextAccount(),\n    },\n    data: getUpdateRateInterestBearingMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR = new Uint8Array([\n  108, 37, 171, 143, 248, 30, 18, 110,\n]);\n\nexport function getUpdateTokenGroupMaxSizeDiscriminatorBytes() {\n  return getBytesEncoder().encode(UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR);\n}\n\nexport type UpdateTokenGroupMaxSizeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountGroup extends string | IAccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountGroup extends string\n        ? WritableAccount<TAccountGroup>\n        : TAccountGroup,\n      TAccountUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountUpdateAuthority> &\n            IAccountSignerMeta<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateTokenGroupMaxSizeInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** New max size for the group */\n  maxSize: bigint;\n};\n\nexport type UpdateTokenGroupMaxSizeInstructionDataArgs = {\n  /** New max size for the group */\n  maxSize: number | bigint;\n};\n\nexport function getUpdateTokenGroupMaxSizeInstructionDataEncoder(): Encoder<UpdateTokenGroupMaxSizeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      ['maxSize', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateTokenGroupMaxSizeInstructionDataDecoder(): Decoder<UpdateTokenGroupMaxSizeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    ['maxSize', getU64Decoder()],\n  ]);\n}\n\nexport function getUpdateTokenGroupMaxSizeInstructionDataCodec(): Codec<\n  UpdateTokenGroupMaxSizeInstructionDataArgs,\n  UpdateTokenGroupMaxSizeInstructionData\n> {\n  return combineCodec(\n    getUpdateTokenGroupMaxSizeInstructionDataEncoder(),\n    getUpdateTokenGroupMaxSizeInstructionDataDecoder()\n  );\n}\n\nexport type UpdateTokenGroupMaxSizeInput<\n  TAccountGroup extends string = string,\n  TAccountUpdateAuthority extends string = string,\n> = {\n  group: Address<TAccountGroup>;\n  updateAuthority: TransactionSigner<TAccountUpdateAuthority>;\n  maxSize: UpdateTokenGroupMaxSizeInstructionDataArgs['maxSize'];\n};\n\nexport function getUpdateTokenGroupMaxSizeInstruction<\n  TAccountGroup extends string,\n  TAccountUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateTokenGroupMaxSizeInput<TAccountGroup, TAccountUpdateAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateTokenGroupMaxSizeInstruction<\n  TProgramAddress,\n  TAccountGroup,\n  TAccountUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    group: { value: input.group ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.group),\n      getAccountMeta(accounts.updateAuthority),\n    ],\n    programAddress,\n    data: getUpdateTokenGroupMaxSizeInstructionDataEncoder().encode(\n      args as UpdateTokenGroupMaxSizeInstructionDataArgs\n    ),\n  } as UpdateTokenGroupMaxSizeInstruction<\n    TProgramAddress,\n    TAccountGroup,\n    TAccountUpdateAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateTokenGroupMaxSizeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    group: TAccountMetas[0];\n    updateAuthority: TAccountMetas[1];\n  };\n  data: UpdateTokenGroupMaxSizeInstructionData;\n};\n\nexport function parseUpdateTokenGroupMaxSizeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateTokenGroupMaxSizeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      group: getNextAccount(),\n      updateAuthority: getNextAccount(),\n    },\n    data: getUpdateTokenGroupMaxSizeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR = new Uint8Array(\n  [161, 105, 88, 1, 237, 221, 216, 203]\n);\n\nexport function getUpdateTokenGroupUpdateAuthorityDiscriminatorBytes() {\n  return getBytesEncoder().encode(\n    UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR\n  );\n}\n\nexport type UpdateTokenGroupUpdateAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountGroup extends string | IAccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountGroup extends string\n        ? WritableAccount<TAccountGroup>\n        : TAccountGroup,\n      TAccountUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountUpdateAuthority> &\n            IAccountSignerMeta<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateTokenGroupUpdateAuthorityInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** New authority for the group, or unset if `None` */\n  newUpdateAuthority: Option<Address>;\n};\n\nexport type UpdateTokenGroupUpdateAuthorityInstructionDataArgs = {\n  /** New authority for the group, or unset if `None` */\n  newUpdateAuthority: OptionOrNullable<Address>;\n};\n\nexport function getUpdateTokenGroupUpdateAuthorityInstructionDataEncoder(): Encoder<UpdateTokenGroupUpdateAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      [\n        'newUpdateAuthority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateTokenGroupUpdateAuthorityInstructionDataDecoder(): Decoder<UpdateTokenGroupUpdateAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    [\n      'newUpdateAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateTokenGroupUpdateAuthorityInstructionDataCodec(): Codec<\n  UpdateTokenGroupUpdateAuthorityInstructionDataArgs,\n  UpdateTokenGroupUpdateAuthorityInstructionData\n> {\n  return combineCodec(\n    getUpdateTokenGroupUpdateAuthorityInstructionDataEncoder(),\n    getUpdateTokenGroupUpdateAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type UpdateTokenGroupUpdateAuthorityInput<\n  TAccountGroup extends string = string,\n  TAccountUpdateAuthority extends string = string,\n> = {\n  group: Address<TAccountGroup>;\n  /** Current update authority */\n  updateAuthority: TransactionSigner<TAccountUpdateAuthority>;\n  newUpdateAuthority: UpdateTokenGroupUpdateAuthorityInstructionDataArgs['newUpdateAuthority'];\n};\n\nexport function getUpdateTokenGroupUpdateAuthorityInstruction<\n  TAccountGroup extends string,\n  TAccountUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateTokenGroupUpdateAuthorityInput<\n    TAccountGroup,\n    TAccountUpdateAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateTokenGroupUpdateAuthorityInstruction<\n  TProgramAddress,\n  TAccountGroup,\n  TAccountUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    group: { value: input.group ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.group),\n      getAccountMeta(accounts.updateAuthority),\n    ],\n    programAddress,\n    data: getUpdateTokenGroupUpdateAuthorityInstructionDataEncoder().encode(\n      args as UpdateTokenGroupUpdateAuthorityInstructionDataArgs\n    ),\n  } as UpdateTokenGroupUpdateAuthorityInstruction<\n    TProgramAddress,\n    TAccountGroup,\n    TAccountUpdateAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateTokenGroupUpdateAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    group: TAccountMetas[0];\n    /** Current update authority */\n    updateAuthority: TAccountMetas[1];\n  };\n  data: UpdateTokenGroupUpdateAuthorityInstructionData;\n};\n\nexport function parseUpdateTokenGroupUpdateAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateTokenGroupUpdateAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      group: getNextAccount(),\n      updateAuthority: getNextAccount(),\n    },\n    data: getUpdateTokenGroupUpdateAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getTokenMetadataFieldDecoder,\n  getTokenMetadataFieldEncoder,\n  type TokenMetadataField,\n  type TokenMetadataFieldArgs,\n} from '../types';\n\nexport const UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR = new Uint8Array([\n  221, 233, 49, 45, 181, 202, 220, 200,\n]);\n\nexport function getUpdateTokenMetadataFieldDiscriminatorBytes() {\n  return getBytesEncoder().encode(UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR);\n}\n\nexport type UpdateTokenMetadataFieldInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | IAccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMetadata extends string\n        ? WritableAccount<TAccountMetadata>\n        : TAccountMetadata,\n      TAccountUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountUpdateAuthority> &\n            IAccountSignerMeta<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateTokenMetadataFieldInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** Field to update in the metadata. */\n  field: TokenMetadataField;\n  /** Value to write for the field. */\n  value: string;\n};\n\nexport type UpdateTokenMetadataFieldInstructionDataArgs = {\n  /** Field to update in the metadata. */\n  field: TokenMetadataFieldArgs;\n  /** Value to write for the field. */\n  value: string;\n};\n\nexport function getUpdateTokenMetadataFieldInstructionDataEncoder(): Encoder<UpdateTokenMetadataFieldInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      ['field', getTokenMetadataFieldEncoder()],\n      ['value', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateTokenMetadataFieldInstructionDataDecoder(): Decoder<UpdateTokenMetadataFieldInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    ['field', getTokenMetadataFieldDecoder()],\n    ['value', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n  ]);\n}\n\nexport function getUpdateTokenMetadataFieldInstructionDataCodec(): Codec<\n  UpdateTokenMetadataFieldInstructionDataArgs,\n  UpdateTokenMetadataFieldInstructionData\n> {\n  return combineCodec(\n    getUpdateTokenMetadataFieldInstructionDataEncoder(),\n    getUpdateTokenMetadataFieldInstructionDataDecoder()\n  );\n}\n\nexport type UpdateTokenMetadataFieldInput<\n  TAccountMetadata extends string = string,\n  TAccountUpdateAuthority extends string = string,\n> = {\n  metadata: Address<TAccountMetadata>;\n  updateAuthority: TransactionSigner<TAccountUpdateAuthority>;\n  field: UpdateTokenMetadataFieldInstructionDataArgs['field'];\n  value: UpdateTokenMetadataFieldInstructionDataArgs['value'];\n};\n\nexport function getUpdateTokenMetadataFieldInstruction<\n  TAccountMetadata extends string,\n  TAccountUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateTokenMetadataFieldInput<\n    TAccountMetadata,\n    TAccountUpdateAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateTokenMetadataFieldInstruction<\n  TProgramAddress,\n  TAccountMetadata,\n  TAccountUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.updateAuthority),\n    ],\n    programAddress,\n    data: getUpdateTokenMetadataFieldInstructionDataEncoder().encode(\n      args as UpdateTokenMetadataFieldInstructionDataArgs\n    ),\n  } as UpdateTokenMetadataFieldInstruction<\n    TProgramAddress,\n    TAccountMetadata,\n    TAccountUpdateAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateTokenMetadataFieldInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    metadata: TAccountMetas[0];\n    updateAuthority: TAccountMetas[1];\n  };\n  data: UpdateTokenMetadataFieldInstructionData;\n};\n\nexport function parseUpdateTokenMetadataFieldInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateTokenMetadataFieldInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      metadata: getNextAccount(),\n      updateAuthority: getNextAccount(),\n    },\n    data: getUpdateTokenMetadataFieldInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR =\n  new Uint8Array([215, 228, 166, 228, 84, 100, 86, 123]);\n\nexport function getUpdateTokenMetadataUpdateAuthorityDiscriminatorBytes() {\n  return getBytesEncoder().encode(\n    UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR\n  );\n}\n\nexport type UpdateTokenMetadataUpdateAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | IAccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMetadata extends string\n        ? WritableAccount<TAccountMetadata>\n        : TAccountMetadata,\n      TAccountUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountUpdateAuthority> &\n            IAccountSignerMeta<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateTokenMetadataUpdateAuthorityInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** New authority for the token metadata, or unset if `None` */\n  newUpdateAuthority: Option<Address>;\n};\n\nexport type UpdateTokenMetadataUpdateAuthorityInstructionDataArgs = {\n  /** New authority for the token metadata, or unset if `None` */\n  newUpdateAuthority: OptionOrNullable<Address>;\n};\n\nexport function getUpdateTokenMetadataUpdateAuthorityInstructionDataEncoder(): Encoder<UpdateTokenMetadataUpdateAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      [\n        'newUpdateAuthority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateTokenMetadataUpdateAuthorityInstructionDataDecoder(): Decoder<UpdateTokenMetadataUpdateAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    [\n      'newUpdateAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateTokenMetadataUpdateAuthorityInstructionDataCodec(): Codec<\n  UpdateTokenMetadataUpdateAuthorityInstructionDataArgs,\n  UpdateTokenMetadataUpdateAuthorityInstructionData\n> {\n  return combineCodec(\n    getUpdateTokenMetadataUpdateAuthorityInstructionDataEncoder(),\n    getUpdateTokenMetadataUpdateAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type UpdateTokenMetadataUpdateAuthorityInput<\n  TAccountMetadata extends string = string,\n  TAccountUpdateAuthority extends string = string,\n> = {\n  metadata: Address<TAccountMetadata>;\n  updateAuthority: TransactionSigner<TAccountUpdateAuthority>;\n  newUpdateAuthority: UpdateTokenMetadataUpdateAuthorityInstructionDataArgs['newUpdateAuthority'];\n};\n\nexport function getUpdateTokenMetadataUpdateAuthorityInstruction<\n  TAccountMetadata extends string,\n  TAccountUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateTokenMetadataUpdateAuthorityInput<\n    TAccountMetadata,\n    TAccountUpdateAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateTokenMetadataUpdateAuthorityInstruction<\n  TProgramAddress,\n  TAccountMetadata,\n  TAccountUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.updateAuthority),\n    ],\n    programAddress,\n    data: getUpdateTokenMetadataUpdateAuthorityInstructionDataEncoder().encode(\n      args as UpdateTokenMetadataUpdateAuthorityInstructionDataArgs\n    ),\n  } as UpdateTokenMetadataUpdateAuthorityInstruction<\n    TProgramAddress,\n    TAccountMetadata,\n    TAccountUpdateAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateTokenMetadataUpdateAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    metadata: TAccountMetas[0];\n    updateAuthority: TAccountMetas[1];\n  };\n  data: UpdateTokenMetadataUpdateAuthorityInstructionData;\n};\n\nexport function parseUpdateTokenMetadataUpdateAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateTokenMetadataUpdateAuthorityInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      metadata: getNextAccount(),\n      updateAuthority: getNextAccount(),\n    },\n    data: getUpdateTokenMetadataUpdateAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_TRANSFER_HOOK_DISCRIMINATOR = 36;\n\nexport function getUpdateTransferHookDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_TRANSFER_HOOK_DISCRIMINATOR);\n}\n\nexport const UPDATE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR = 1;\n\nexport function getUpdateTransferHookTransferHookDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR\n  );\n}\n\nexport type UpdateTransferHookInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateTransferHookInstructionData = {\n  discriminator: number;\n  transferHookDiscriminator: number;\n  /** The program id that performs logic during transfers */\n  programId: Option<Address>;\n};\n\nexport type UpdateTransferHookInstructionDataArgs = {\n  /** The program id that performs logic during transfers */\n  programId: OptionOrNullable<Address>;\n};\n\nexport function getUpdateTransferHookInstructionDataEncoder(): Encoder<UpdateTransferHookInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferHookDiscriminator', getU8Encoder()],\n      [\n        'programId',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TRANSFER_HOOK_DISCRIMINATOR,\n      transferHookDiscriminator:\n        UPDATE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateTransferHookInstructionDataDecoder(): Decoder<UpdateTransferHookInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferHookDiscriminator', getU8Decoder()],\n    [\n      'programId',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateTransferHookInstructionDataCodec(): Codec<\n  UpdateTransferHookInstructionDataArgs,\n  UpdateTransferHookInstructionData\n> {\n  return combineCodec(\n    getUpdateTransferHookInstructionDataEncoder(),\n    getUpdateTransferHookInstructionDataDecoder()\n  );\n}\n\nexport type UpdateTransferHookInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The transfer hook authority. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  programId: UpdateTransferHookInstructionDataArgs['programId'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateTransferHookInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateTransferHookInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateTransferHookInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getUpdateTransferHookInstructionDataEncoder().encode(\n      args as UpdateTransferHookInstructionDataArgs\n    ),\n  } as UpdateTransferHookInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateTransferHookInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The transfer hook authority. */\n    authority: TAccountMetas[1];\n  };\n  data: UpdateTransferHookInstructionData;\n};\n\nexport function parseUpdateTransferHookInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateTransferHookInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getUpdateTransferHookInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const WITHDRAW_EXCESS_LAMPORTS_DISCRIMINATOR = 38;\n\nexport function getWithdrawExcessLamportsDiscriminatorBytes() {\n  return getU8Encoder().encode(WITHDRAW_EXCESS_LAMPORTS_DISCRIMINATOR);\n}\n\nexport type WithdrawExcessLamportsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSourceAccount extends string | IAccountMeta<string> = string,\n  TAccountDestinationAccount extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSourceAccount extends string\n        ? WritableAccount<TAccountSourceAccount>\n        : TAccountSourceAccount,\n      TAccountDestinationAccount extends string\n        ? WritableAccount<TAccountDestinationAccount>\n        : TAccountDestinationAccount,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawExcessLamportsInstructionData = { discriminator: number };\n\nexport type WithdrawExcessLamportsInstructionDataArgs = {};\n\nexport function getWithdrawExcessLamportsInstructionDataEncoder(): Encoder<WithdrawExcessLamportsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: WITHDRAW_EXCESS_LAMPORTS_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawExcessLamportsInstructionDataDecoder(): Decoder<WithdrawExcessLamportsInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getWithdrawExcessLamportsInstructionDataCodec(): Codec<\n  WithdrawExcessLamportsInstructionDataArgs,\n  WithdrawExcessLamportsInstructionData\n> {\n  return combineCodec(\n    getWithdrawExcessLamportsInstructionDataEncoder(),\n    getWithdrawExcessLamportsInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawExcessLamportsInput<\n  TAccountSourceAccount extends string = string,\n  TAccountDestinationAccount extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** Account holding excess lamports. */\n  sourceAccount: Address<TAccountSourceAccount>;\n  /** Destination account for withdrawn lamports. */\n  destinationAccount: Address<TAccountDestinationAccount>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getWithdrawExcessLamportsInstruction<\n  TAccountSourceAccount extends string,\n  TAccountDestinationAccount extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: WithdrawExcessLamportsInput<\n    TAccountSourceAccount,\n    TAccountDestinationAccount,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawExcessLamportsInstruction<\n  TProgramAddress,\n  TAccountSourceAccount,\n  TAccountDestinationAccount,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    sourceAccount: { value: input.sourceAccount ?? null, isWritable: true },\n    destinationAccount: {\n      value: input.destinationAccount ?? null,\n      isWritable: true,\n    },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.sourceAccount),\n      getAccountMeta(accounts.destinationAccount),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getWithdrawExcessLamportsInstructionDataEncoder().encode({}),\n  } as WithdrawExcessLamportsInstruction<\n    TProgramAddress,\n    TAccountSourceAccount,\n    TAccountDestinationAccount,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedWithdrawExcessLamportsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Account holding excess lamports. */\n    sourceAccount: TAccountMetas[0];\n    /** Destination account for withdrawn lamports. */\n    destinationAccount: TAccountMetas[1];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: WithdrawExcessLamportsInstructionData;\n};\n\nexport function parseWithdrawExcessLamportsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedWithdrawExcessLamportsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      sourceAccount: getNextAccount(),\n      destinationAccount: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getWithdrawExcessLamportsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_DISCRIMINATOR = 26;\n\nexport function getWithdrawWithheldTokensFromAccountsDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_DISCRIMINATOR\n  );\n}\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_TRANSFER_FEE_DISCRIMINATOR = 3;\n\nexport function getWithdrawWithheldTokensFromAccountsTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type WithdrawWithheldTokensFromAccountsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountFeeReceiver extends string | IAccountMeta<string> = string,\n  TAccountWithdrawWithheldAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountFeeReceiver extends string\n        ? WritableAccount<TAccountFeeReceiver>\n        : TAccountFeeReceiver,\n      TAccountWithdrawWithheldAuthority extends string\n        ? ReadonlyAccount<TAccountWithdrawWithheldAuthority>\n        : TAccountWithdrawWithheldAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawWithheldTokensFromAccountsInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n  /** Number of token accounts harvested. */\n  numTokenAccounts: number;\n};\n\nexport type WithdrawWithheldTokensFromAccountsInstructionDataArgs = {\n  /** Number of token accounts harvested. */\n  numTokenAccounts: number;\n};\n\nexport function getWithdrawWithheldTokensFromAccountsInstructionDataEncoder(): Encoder<WithdrawWithheldTokensFromAccountsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n      ['numTokenAccounts', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_DISCRIMINATOR,\n      transferFeeDiscriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawWithheldTokensFromAccountsInstructionDataDecoder(): Decoder<WithdrawWithheldTokensFromAccountsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n    ['numTokenAccounts', getU8Decoder()],\n  ]);\n}\n\nexport function getWithdrawWithheldTokensFromAccountsInstructionDataCodec(): Codec<\n  WithdrawWithheldTokensFromAccountsInstructionDataArgs,\n  WithdrawWithheldTokensFromAccountsInstructionData\n> {\n  return combineCodec(\n    getWithdrawWithheldTokensFromAccountsInstructionDataEncoder(),\n    getWithdrawWithheldTokensFromAccountsInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawWithheldTokensFromAccountsInput<\n  TAccountMint extends string = string,\n  TAccountFeeReceiver extends string = string,\n  TAccountWithdrawWithheldAuthority extends string = string,\n> = {\n  /** The token mint. Must include the `TransferFeeConfig` extension. */\n  mint: Address<TAccountMint>;\n  /**\n   * The fee receiver account. Must include the `TransferFeeAmount`\n   * extension associated with the provided mint.\n   */\n  feeReceiver: Address<TAccountFeeReceiver>;\n  /** The mint's `withdraw_withheld_authority` or its multisignature account. */\n  withdrawWithheldAuthority:\n    | Address<TAccountWithdrawWithheldAuthority>\n    | TransactionSigner<TAccountWithdrawWithheldAuthority>;\n  numTokenAccounts: WithdrawWithheldTokensFromAccountsInstructionDataArgs['numTokenAccounts'];\n  multiSigners?: Array<TransactionSigner>;\n  sources: Array<Address>;\n};\n\nexport function getWithdrawWithheldTokensFromAccountsInstruction<\n  TAccountMint extends string,\n  TAccountFeeReceiver extends string,\n  TAccountWithdrawWithheldAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: WithdrawWithheldTokensFromAccountsInput<\n    TAccountMint,\n    TAccountFeeReceiver,\n    TAccountWithdrawWithheldAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawWithheldTokensFromAccountsInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountFeeReceiver,\n  (typeof input)['withdrawWithheldAuthority'] extends TransactionSigner<TAccountWithdrawWithheldAuthority>\n    ? ReadonlySignerAccount<TAccountWithdrawWithheldAuthority> &\n        IAccountSignerMeta<TAccountWithdrawWithheldAuthority>\n    : TAccountWithdrawWithheldAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n    feeReceiver: { value: input.feeReceiver ?? null, isWritable: true },\n    withdrawWithheldAuthority: {\n      value: input.withdrawWithheldAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = [\n    ...(args.multiSigners ?? []).map((signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })),\n    ...args.sources.map((address) => ({ address, role: AccountRole.WRITABLE })),\n  ];\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.feeReceiver),\n      getAccountMeta(accounts.withdrawWithheldAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getWithdrawWithheldTokensFromAccountsInstructionDataEncoder().encode(\n      args as WithdrawWithheldTokensFromAccountsInstructionDataArgs\n    ),\n  } as WithdrawWithheldTokensFromAccountsInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountFeeReceiver,\n    (typeof input)['withdrawWithheldAuthority'] extends TransactionSigner<TAccountWithdrawWithheldAuthority>\n      ? ReadonlySignerAccount<TAccountWithdrawWithheldAuthority> &\n          IAccountSignerMeta<TAccountWithdrawWithheldAuthority>\n      : TAccountWithdrawWithheldAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedWithdrawWithheldTokensFromAccountsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. Must include the `TransferFeeConfig` extension. */\n    mint: TAccountMetas[0];\n    /**\n     * The fee receiver account. Must include the `TransferFeeAmount`\n     * extension associated with the provided mint.\n     */\n\n    feeReceiver: TAccountMetas[1];\n    /** The mint's `withdraw_withheld_authority` or its multisignature account. */\n    withdrawWithheldAuthority: TAccountMetas[2];\n  };\n  data: WithdrawWithheldTokensFromAccountsInstructionData;\n};\n\nexport function parseWithdrawWithheldTokensFromAccountsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedWithdrawWithheldTokensFromAccountsInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      feeReceiver: getNextAccount(),\n      withdrawWithheldAuthority: getNextAccount(),\n    },\n    data: getWithdrawWithheldTokensFromAccountsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 2;\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountDestination extends string | IAccountMeta<string> = string,\n  TAccountInstructionsSysvarOrContextState extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountRecord extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountInstructionsSysvarOrContextState extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvarOrContextState>\n        : TAccountInstructionsSysvarOrContextState,\n      TAccountRecord extends string\n        ? ReadonlyAccount<TAccountRecord>\n        : TAccountRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionData =\n  {\n    discriminator: number;\n    confidentialTransferFeeDiscriminator: number;\n    /** Number of token accounts harvested */\n    numTokenAccounts: number;\n    /** Proof instruction offset */\n    proofInstructionOffset: number;\n    /** The new decryptable balance in the destination token account */\n    newDecryptableAvailableBalance: DecryptableBalance;\n  };\n\nexport type WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs =\n  {\n    /** Number of token accounts harvested */\n    numTokenAccounts: number;\n    /** Proof instruction offset */\n    proofInstructionOffset: number;\n    /** The new decryptable balance in the destination token account */\n    newDecryptableAvailableBalance: DecryptableBalanceArgs;\n  };\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataEncoder(): Encoder<WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n      ['numTokenAccounts', getU8Encoder()],\n      ['proofInstructionOffset', getI8Encoder()],\n      ['newDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataDecoder(): Decoder<WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n    ['numTokenAccounts', getU8Decoder()],\n    ['proofInstructionOffset', getI8Decoder()],\n    ['newDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n  ]);\n}\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataCodec(): Codec<\n  WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs,\n  WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionData\n> {\n  return combineCodec(\n    getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataEncoder(),\n    getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInput<\n  TAccountMint extends string = string,\n  TAccountDestination extends string = string,\n  TAccountInstructionsSysvarOrContextState extends string = string,\n  TAccountRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The fee receiver account. */\n  destination: Address<TAccountDestination>;\n  /** Instructions sysvar or context state account */\n  instructionsSysvarOrContextState: Address<TAccountInstructionsSysvarOrContextState>;\n  /** Optional record account */\n  record?: Address<TAccountRecord>;\n  /** The mint's withdraw_withheld_authority */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  numTokenAccounts: WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs['numTokenAccounts'];\n  proofInstructionOffset: WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs['proofInstructionOffset'];\n  newDecryptableAvailableBalance: WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs['newDecryptableAvailableBalance'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TAccountMint extends string,\n  TAccountDestination extends string,\n  TAccountInstructionsSysvarOrContextState extends string,\n  TAccountRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInput<\n    TAccountMint,\n    TAccountDestination,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountDestination,\n  TAccountInstructionsSysvarOrContextState,\n  TAccountRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n    destination: { value: input.destination ?? null, isWritable: true },\n    instructionsSysvarOrContextState: {\n      value: input.instructionsSysvarOrContextState ?? null,\n      isWritable: false,\n    },\n    record: { value: input.record ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.instructionsSysvarOrContextState),\n      getAccountMeta(accounts.record),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataEncoder().encode(\n      args as WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs\n    ),\n  } as WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountDestination,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. */\n    mint: TAccountMetas[0];\n    /** The fee receiver account. */\n    destination: TAccountMetas[1];\n    /** Instructions sysvar or context state account */\n    instructionsSysvarOrContextState: TAccountMetas[2];\n    /** Optional record account */\n    record?: TAccountMetas[3] | undefined;\n    /** The mint's withdraw_withheld_authority */\n    authority: TAccountMetas[4];\n  };\n  data: WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionData;\n};\n\nexport function parseWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      instructionsSysvarOrContextState: getNextAccount(),\n      record: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_MINT_DISCRIMINATOR = 26;\n\nexport function getWithdrawWithheldTokensFromMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_DISCRIMINATOR\n  );\n}\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_MINT_TRANSFER_FEE_DISCRIMINATOR = 2;\n\nexport function getWithdrawWithheldTokensFromMintTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type WithdrawWithheldTokensFromMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountFeeReceiver extends string | IAccountMeta<string> = string,\n  TAccountWithdrawWithheldAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountFeeReceiver extends string\n        ? WritableAccount<TAccountFeeReceiver>\n        : TAccountFeeReceiver,\n      TAccountWithdrawWithheldAuthority extends string\n        ? ReadonlyAccount<TAccountWithdrawWithheldAuthority>\n        : TAccountWithdrawWithheldAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawWithheldTokensFromMintInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n};\n\nexport type WithdrawWithheldTokensFromMintInstructionDataArgs = {};\n\nexport function getWithdrawWithheldTokensFromMintInstructionDataEncoder(): Encoder<WithdrawWithheldTokensFromMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: WITHDRAW_WITHHELD_TOKENS_FROM_MINT_DISCRIMINATOR,\n      transferFeeDiscriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_MINT_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawWithheldTokensFromMintInstructionDataDecoder(): Decoder<WithdrawWithheldTokensFromMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getWithdrawWithheldTokensFromMintInstructionDataCodec(): Codec<\n  WithdrawWithheldTokensFromMintInstructionDataArgs,\n  WithdrawWithheldTokensFromMintInstructionData\n> {\n  return combineCodec(\n    getWithdrawWithheldTokensFromMintInstructionDataEncoder(),\n    getWithdrawWithheldTokensFromMintInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawWithheldTokensFromMintInput<\n  TAccountMint extends string = string,\n  TAccountFeeReceiver extends string = string,\n  TAccountWithdrawWithheldAuthority extends string = string,\n> = {\n  /** The token mint. Must include the `TransferFeeConfig` extension. */\n  mint: Address<TAccountMint>;\n  /**\n   * The fee receiver account. Must include the `TransferFeeAmount`\n   * extension associated with the provided mint.\n   */\n  feeReceiver: Address<TAccountFeeReceiver>;\n  /** The mint's `withdraw_withheld_authority` or its multisignature account. */\n  withdrawWithheldAuthority:\n    | Address<TAccountWithdrawWithheldAuthority>\n    | TransactionSigner<TAccountWithdrawWithheldAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getWithdrawWithheldTokensFromMintInstruction<\n  TAccountMint extends string,\n  TAccountFeeReceiver extends string,\n  TAccountWithdrawWithheldAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: WithdrawWithheldTokensFromMintInput<\n    TAccountMint,\n    TAccountFeeReceiver,\n    TAccountWithdrawWithheldAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawWithheldTokensFromMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountFeeReceiver,\n  (typeof input)['withdrawWithheldAuthority'] extends TransactionSigner<TAccountWithdrawWithheldAuthority>\n    ? ReadonlySignerAccount<TAccountWithdrawWithheldAuthority> &\n        IAccountSignerMeta<TAccountWithdrawWithheldAuthority>\n    : TAccountWithdrawWithheldAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    feeReceiver: { value: input.feeReceiver ?? null, isWritable: true },\n    withdrawWithheldAuthority: {\n      value: input.withdrawWithheldAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.feeReceiver),\n      getAccountMeta(accounts.withdrawWithheldAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getWithdrawWithheldTokensFromMintInstructionDataEncoder().encode({}),\n  } as WithdrawWithheldTokensFromMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountFeeReceiver,\n    (typeof input)['withdrawWithheldAuthority'] extends TransactionSigner<TAccountWithdrawWithheldAuthority>\n      ? ReadonlySignerAccount<TAccountWithdrawWithheldAuthority> &\n          IAccountSignerMeta<TAccountWithdrawWithheldAuthority>\n      : TAccountWithdrawWithheldAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedWithdrawWithheldTokensFromMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. Must include the `TransferFeeConfig` extension. */\n    mint: TAccountMetas[0];\n    /**\n     * The fee receiver account. Must include the `TransferFeeAmount`\n     * extension associated with the provided mint.\n     */\n\n    feeReceiver: TAccountMetas[1];\n    /** The mint's `withdraw_withheld_authority` or its multisignature account. */\n    withdrawWithheldAuthority: TAccountMetas[2];\n  };\n  data: WithdrawWithheldTokensFromMintInstructionData;\n};\n\nexport function parseWithdrawWithheldTokensFromMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedWithdrawWithheldTokensFromMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      feeReceiver: getNextAccount(),\n      withdrawWithheldAuthority: getNextAccount(),\n    },\n    data: getWithdrawWithheldTokensFromMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 1;\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountDestination extends string | IAccountMeta<string> = string,\n  TAccountInstructionsSysvarOrContextState extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountRecord extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountInstructionsSysvarOrContextState extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvarOrContextState>\n        : TAccountInstructionsSysvarOrContextState,\n      TAccountRecord extends string\n        ? ReadonlyAccount<TAccountRecord>\n        : TAccountRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionData =\n  {\n    discriminator: number;\n    confidentialTransferFeeDiscriminator: number;\n    /** Proof instruction offset */\n    proofInstructionOffset: number;\n    /** The new decryptable balance in the destination token account */\n    newDecryptableAvailableBalance: DecryptableBalance;\n  };\n\nexport type WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs =\n  {\n    /** Proof instruction offset */\n    proofInstructionOffset: number;\n    /** The new decryptable balance in the destination token account */\n    newDecryptableAvailableBalance: DecryptableBalanceArgs;\n  };\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataEncoder(): Encoder<WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n      ['proofInstructionOffset', getI8Encoder()],\n      ['newDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataDecoder(): Decoder<WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n    ['proofInstructionOffset', getI8Decoder()],\n    ['newDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n  ]);\n}\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataCodec(): Codec<\n  WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs,\n  WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionData\n> {\n  return combineCodec(\n    getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataEncoder(),\n    getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawWithheldTokensFromMintForConfidentialTransferFeeInput<\n  TAccountMint extends string = string,\n  TAccountDestination extends string = string,\n  TAccountInstructionsSysvarOrContextState extends string = string,\n  TAccountRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The fee receiver account. */\n  destination: Address<TAccountDestination>;\n  /** Instructions sysvar or context state account */\n  instructionsSysvarOrContextState: Address<TAccountInstructionsSysvarOrContextState>;\n  /** Optional record account if proof is read from record */\n  record?: Address<TAccountRecord>;\n  /** The mint's withdraw_withheld_authority */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  proofInstructionOffset: WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs['proofInstructionOffset'];\n  newDecryptableAvailableBalance: WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs['newDecryptableAvailableBalance'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TAccountMint extends string,\n  TAccountDestination extends string,\n  TAccountInstructionsSysvarOrContextState extends string,\n  TAccountRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: WithdrawWithheldTokensFromMintForConfidentialTransferFeeInput<\n    TAccountMint,\n    TAccountDestination,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountDestination,\n  TAccountInstructionsSysvarOrContextState,\n  TAccountRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n    instructionsSysvarOrContextState: {\n      value: input.instructionsSysvarOrContextState ?? null,\n      isWritable: false,\n    },\n    record: { value: input.record ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.instructionsSysvarOrContextState),\n      getAccountMeta(accounts.record),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataEncoder().encode(\n      args as WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs\n    ),\n  } as WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountDestination,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. */\n    mint: TAccountMetas[0];\n    /** The fee receiver account. */\n    destination: TAccountMetas[1];\n    /** Instructions sysvar or context state account */\n    instructionsSysvarOrContextState: TAccountMetas[2];\n    /** Optional record account if proof is read from record */\n    record?: TAccountMetas[3] | undefined;\n    /** The mint's withdraw_withheld_authority */\n    authority: TAccountMetas[4];\n  };\n  data: WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionData;\n};\n\nexport function parseWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      instructionsSysvarOrContextState: getNextAccount(),\n      record: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","import {\n  type GetAccountInfoApi,\n  type Rpc,\n  Address,\n  UnixTimestamp,\n  unwrapOption,\n} from '@solana/kit';\nimport { fetchSysvarClock } from '@solana/sysvars';\nimport { fetchMint } from './generated';\n\n/**\n * Calculates the exponent for the interest rate formula.\n * @param t1 - The start time in seconds.\n * @param t2 - The end time in seconds.\n * @param r  - The interest rate in basis points.\n *\n * @returns The calculated exponent.\n */\nfunction calculateExponentForTimesAndRate(t1: number, t2: number, r: number) {\n  const ONE_IN_BASIS_POINTS = 10000;\n  const SECONDS_PER_YEAR = 60 * 60 * 24 * 365.24;\n  const timespan = t2 - t1;\n  if (timespan < 0) {\n    throw new Error('Invalid timespan: end time before start time');\n  }\n\n  const numerator = r * timespan;\n  const exponent = numerator / (SECONDS_PER_YEAR * ONE_IN_BASIS_POINTS);\n  return Math.exp(exponent);\n}\n\n/**\n * Calculates the total scale factor for an interest bearing token by combining two exponential functions:\n * One for the period between initialization and last update using the pre-update average rate,\n * and another for the period between last update and current time using the current rate.\n *\n * @param currentTimestamp         Current timestamp in seconds\n * @param lastUpdateTimestamp      Last time the interest rate was updated in seconds\n * @param initializationTimestamp  Time the interest bearing extension was initialized in seconds\n * @param preUpdateAverageRate     Interest rate in basis points before last update\n * @param currentRate              Current interest rate in basis points\n *\n * @returns The total scale factor as a product of the two exponential functions\n */\nfunction calculateTotalScale({\n  currentTimestamp,\n  lastUpdateTimestamp,\n  initializationTimestamp,\n  preUpdateAverageRate,\n  currentRate,\n}: {\n  currentTimestamp: number;\n  lastUpdateTimestamp: number;\n  initializationTimestamp: number;\n  preUpdateAverageRate: number;\n  currentRate: number;\n}): number {\n  // Calculate pre-update exponent\n  // e^(preUpdateAverageRate * (lastUpdateTimestamp - initializationTimestamp) / (SECONDS_PER_YEAR * ONE_IN_BASIS_POINTS))\n  const preUpdateExp = calculateExponentForTimesAndRate(\n    initializationTimestamp,\n    lastUpdateTimestamp,\n    preUpdateAverageRate\n  );\n\n  // Calculate post-update exponent\n  // e^(currentRate * (currentTimestamp - lastUpdateTimestamp) / (SECONDS_PER_YEAR * ONE_IN_BASIS_POINTS))\n  const postUpdateExp = calculateExponentForTimesAndRate(\n    lastUpdateTimestamp,\n    currentTimestamp,\n    currentRate\n  );\n\n  return preUpdateExp * postUpdateExp;\n}\n\n/**\n * Retrieves the current timestamp from the Solana clock sysvar.\n * @param rpc - The Solana rpc object.\n * @returns A promise that resolves to the current timestamp in seconds.\n * @throws An error if the sysvar clock cannot be fetched or parsed.\n */\nasync function getSysvarClockTimestamp(\n  rpc: Rpc<GetAccountInfoApi>\n): Promise<UnixTimestamp> {\n  const info = await fetchSysvarClock(rpc);\n  if (!info) {\n    throw new Error('Failed to fetch sysvar clock');\n  }\n  return info.unixTimestamp;\n}\n\n/**\n * Convert amount to UiAmount for a mint with interest bearing extension without simulating a transaction\n * This implements the same logic as the CPI instruction available in /token/program-2022/src/extension/interest_bearing_mint/mod.rs\n * In general to calculate compounding interest over a period of time, the formula is:\n * A = P * e^(r * t) where\n * A = final amount after interest\n * P = principal amount (initial investment)\n * r = annual interest rate (as a decimal, e.g., 5% = 0.05)\n * t = time in years\n * e = mathematical constant (~2.718)\n *\n * In this case, we are calculating the total scale factor for the interest bearing extension which is the product of two exponential functions:\n * totalScale = e^(r1 * t1) * e^(r2 * t2)\n * where r1 and r2 are the interest rates before and after the last update, and t1 and t2 are the times in years between\n * the initialization timestamp and the last update timestamp, and between the last update timestamp and the current timestamp.\n *\n * @param amount                   Amount of tokens to be converted\n * @param decimals                 Number of decimals of the mint\n * @param currentTimestamp         Current timestamp in seconds\n * @param lastUpdateTimestamp      Last time the interest rate was updated in seconds\n * @param initializationTimestamp  Time the interest bearing extension was initialized in seconds\n * @param preUpdateAverageRate     Interest rate in basis points (1 basis point = 0.01%) before last update\n * @param currentRate              Current interest rate in basis points\n *\n * @return Amount scaled by accrued interest as a string with appropriate decimal places\n */\nexport function amountToUiAmountForInterestBearingMintWithoutSimulation(\n  amount: bigint,\n  decimals: number,\n  currentTimestamp: number, // in seconds\n  lastUpdateTimestamp: number,\n  initializationTimestamp: number,\n  preUpdateAverageRate: number,\n  currentRate: number\n): string {\n  const totalScale = calculateTotalScale({\n    currentTimestamp,\n    lastUpdateTimestamp,\n    initializationTimestamp,\n    preUpdateAverageRate,\n    currentRate,\n  });\n  // Scale the amount by the total interest factor\n  const scaledAmount = Number(amount) * totalScale;\n\n  // Calculate the decimal factor (e.g. 100 for 2 decimals)\n  const decimalFactor = Math.pow(10, decimals);\n\n  // Convert to UI amount by:\n  // 1. Truncating to remove any remaining decimals\n  // 2. Dividing by decimal factor to get final UI amount\n  // 3. Converting to string\n  return (Math.trunc(scaledAmount) / decimalFactor).toString();\n}\n\n/**\n * Convert amount to UiAmount for a mint without simulating a transaction\n * This implements the same logic as `process_amount_to_ui_amount` in\n * solana-labs/solana-program-library/token/program-2022/src/processor.rs\n * and `process_amount_to_ui_amount` in solana-labs/solana-program-library/token/program/src/processor.rs\n *\n * @param rpc     Rpc to use\n * @param mint    Mint to use for calculations\n * @param amount  Amount of tokens to be converted to Ui Amount\n *\n * @return Ui Amount generated\n */\nexport async function amountToUiAmountForMintWithoutSimulation(\n  rpc: Rpc<GetAccountInfoApi>,\n  mint: Address,\n  amount: bigint\n): Promise<string> {\n  const accountInfo = await fetchMint(rpc, mint);\n  const extensions = unwrapOption(accountInfo.data.extensions);\n  const interestBearingMintConfigState = extensions?.find(\n    (ext) => ext.__kind === 'InterestBearingConfig'\n  );\n  if (!interestBearingMintConfigState) {\n    const amountNumber = Number(amount);\n    const decimalsFactor = Math.pow(10, accountInfo.data.decimals);\n    return (amountNumber / decimalsFactor).toString();\n  }\n\n  const timestamp = await getSysvarClockTimestamp(rpc);\n\n  return amountToUiAmountForInterestBearingMintWithoutSimulation(\n    amount,\n    accountInfo.data.decimals,\n    Number(timestamp),\n    Number(interestBearingMintConfigState.lastUpdateTimestamp),\n    Number(interestBearingMintConfigState.initializationTimestamp),\n    interestBearingMintConfigState.preUpdateAverageRate,\n    interestBearingMintConfigState.currentRate\n  );\n}\n\n/**\n * Convert an amount with interest back to the original amount without interest\n * This implements the same logic as the CPI instruction available in /token/program-2022/src/extension/interest_bearing_mint/mod.rs\n *\n * @param uiAmount                  UI Amount (principal plus continuously compounding interest) to be converted back to original principal\n * @param decimals                  Number of decimals for the mint\n * @param currentTimestamp          Current timestamp in seconds\n * @param lastUpdateTimestamp       Last time the interest rate was updated in seconds\n * @param initializationTimestamp   Time the interest bearing extension was initialized in seconds\n * @param preUpdateAverageRate      Interest rate in basis points (hundredths of a percent) before the last update\n * @param currentRate              Current interest rate in basis points\n *\n * In general to calculate the principal from the UI amount, the formula is:\n * P = A / (e^(r * t)) where\n * P = principal\n * A = UI amount\n * r = annual interest rate (as a decimal, e.g., 5% = 0.05)\n * t = time in years\n *\n * In this case, we are calculating the principal by dividing the UI amount by the total scale factor which is the product of two exponential functions:\n * totalScale = e^(r1 * t1) * e^(r2 * t2)\n * where r1 is the pre-update average rate, r2 is the current rate, t1 is the time in years between the initialization timestamp and the last update timestamp,\n * and t2 is the time in years between the last update timestamp and the current timestamp.\n * then to calculate the principal, we divide the UI amount by the total scale factor:\n * P = A / totalScale\n *\n * @return Original amount (principal) without interest\n */\nexport function uiAmountToAmountForInterestBearingMintWithoutSimulation(\n  uiAmount: string,\n  decimals: number,\n  currentTimestamp: number, // in seconds\n  lastUpdateTimestamp: number,\n  initializationTimestamp: number,\n  preUpdateAverageRate: number,\n  currentRate: number\n): bigint {\n  const uiAmountNumber = parseFloat(uiAmount);\n  const decimalsFactor = Math.pow(10, decimals);\n  const uiAmountScaled = uiAmountNumber * decimalsFactor;\n\n  const totalScale = calculateTotalScale({\n    currentTimestamp,\n    lastUpdateTimestamp,\n    initializationTimestamp,\n    preUpdateAverageRate,\n    currentRate,\n  });\n\n  // Calculate original principal by dividing the UI amount (principal + interest) by the total scale\n  const originalPrincipal = uiAmountScaled / totalScale;\n  return BigInt(Math.trunc(originalPrincipal));\n}\n\n/**\n * Convert a UI amount back to the raw amount\n *\n * @param rpc      Rpc to use\n * @param mint     Mint to use for calculations\n * @param uiAmount UI Amount to be converted back to raw amount\n *\n * @return Raw amount\n */\nexport async function uiAmountToAmountForMintWithoutSimulation(\n  rpc: Rpc<GetAccountInfoApi>,\n  mint: Address,\n  uiAmount: string\n): Promise<bigint> {\n  const accountInfo = await fetchMint(rpc, mint);\n  const extensions = unwrapOption(accountInfo.data.extensions);\n  const interestBearingMintConfigState = extensions?.find(\n    (ext) => ext.__kind === 'InterestBearingConfig'\n  );\n  if (!interestBearingMintConfigState) {\n    const uiAmountScaled =\n      parseFloat(uiAmount) * Math.pow(10, accountInfo.data.decimals);\n    return BigInt(Math.trunc(uiAmountScaled));\n  }\n\n  const timestamp = await getSysvarClockTimestamp(rpc);\n\n  return uiAmountToAmountForInterestBearingMintWithoutSimulation(\n    uiAmount,\n    accountInfo.data.decimals,\n    Number(timestamp),\n    Number(interestBearingMintConfigState.lastUpdateTimestamp),\n    Number(interestBearingMintConfigState.initializationTimestamp),\n    interestBearingMintConfigState.preUpdateAverageRate,\n    interestBearingMintConfigState.currentRate\n  );\n}\n","import {\n  Address,\n  IInstruction,\n  isNone,\n  isOption,\n  TransactionSigner,\n  wrapNullable,\n} from '@solana/kit';\nimport {\n  ExtensionArgs,\n  getDisableMemoTransfersInstruction,\n  getEnableMemoTransfersInstruction,\n  getEnableCpiGuardInstruction,\n  getDisableCpiGuardInstruction,\n  getInitializeConfidentialTransferMintInstruction,\n  getInitializeDefaultAccountStateInstruction,\n  getInitializeGroupMemberPointerInstruction,\n  getInitializeGroupPointerInstruction,\n  getInitializeInterestBearingMintInstruction,\n  getInitializeMetadataPointerInstruction,\n  getInitializeMintCloseAuthorityInstruction,\n  getInitializeTokenGroupInstruction,\n  getInitializeTokenMetadataInstruction,\n  getInitializeTransferFeeConfigInstruction,\n  getInitializeNonTransferableMintInstruction,\n  getInitializeTransferHookInstruction,\n  getInitializePermanentDelegateInstruction,\n  getInitializeConfidentialTransferFeeInstruction,\n} from './generated';\n\n/**\n * Given a mint address and a list of mint extensions, returns a list of\n * instructions that MUST be run _before_ the `initializeMint` instruction\n * to properly initialize the given extensions on the mint account.\n */\nexport function getPreInitializeInstructionsForMintExtensions(\n  mint: Address,\n  extensions: ExtensionArgs[]\n): IInstruction[] {\n  return extensions.flatMap((extension) => {\n    switch (extension.__kind) {\n      case 'ConfidentialTransferMint':\n        return [\n          getInitializeConfidentialTransferMintInstruction({\n            mint,\n            ...extension,\n          }),\n        ];\n      case 'DefaultAccountState':\n        return [\n          getInitializeDefaultAccountStateInstruction({\n            mint,\n            state: extension.state,\n          }),\n        ];\n      case 'TransferFeeConfig':\n        return [\n          getInitializeTransferFeeConfigInstruction({\n            mint,\n            transferFeeConfigAuthority: extension.transferFeeConfigAuthority,\n            withdrawWithheldAuthority: extension.withdrawWithheldAuthority,\n            transferFeeBasisPoints:\n              extension.newerTransferFee.transferFeeBasisPoints,\n            maximumFee: extension.newerTransferFee.maximumFee,\n          }),\n        ];\n      case 'MetadataPointer':\n        return [\n          getInitializeMetadataPointerInstruction({\n            mint,\n            authority: extension.authority,\n            metadataAddress: extension.metadataAddress,\n          }),\n        ];\n      case 'InterestBearingConfig':\n        return [\n          getInitializeInterestBearingMintInstruction({\n            mint,\n            rateAuthority: extension.rateAuthority,\n            rate: extension.currentRate,\n          }),\n        ];\n      case 'GroupPointer':\n        return [\n          getInitializeGroupPointerInstruction({\n            mint,\n            authority: extension.authority,\n            groupAddress: extension.groupAddress,\n          }),\n        ];\n      case 'GroupMemberPointer':\n        return [\n          getInitializeGroupMemberPointerInstruction({\n            mint,\n            authority: extension.authority,\n            memberAddress: extension.memberAddress,\n          }),\n        ];\n      case 'NonTransferable':\n        return getInitializeNonTransferableMintInstruction({ mint });\n      case 'TransferHook':\n        return [\n          getInitializeTransferHookInstruction({\n            mint,\n            authority: extension.authority,\n            programId: extension.programId,\n          }),\n        ];\n      case 'PermanentDelegate':\n        return getInitializePermanentDelegateInstruction({\n          mint,\n          delegate: extension.delegate,\n        });\n      case 'ConfidentialTransferFee':\n        return [\n          getInitializeConfidentialTransferFeeInstruction({\n            mint,\n            authority: extension.authority,\n            withdrawWithheldAuthorityElGamalPubkey: extension.elgamalPubkey,\n          }),\n        ];\n      case 'MintCloseAuthority':\n        return getInitializeMintCloseAuthorityInstruction({\n          closeAuthority: extension.closeAuthority,\n          mint,\n        });\n      default:\n        return [];\n    }\n  });\n}\n\n/**\n * Given a mint address and a list of mint extensions, returns a list of\n * instructions that MUST be run _after_ the `initializeMint` instruction\n * to properly initialize the given extensions on the mint account.\n */\nexport function getPostInitializeInstructionsForMintExtensions(\n  mint: Address,\n  authority: TransactionSigner,\n  extensions: ExtensionArgs[]\n): IInstruction[] {\n  return extensions.flatMap((extension): IInstruction[] => {\n    switch (extension.__kind) {\n      case 'TokenMetadata':\n        // eslint-disable-next-line no-case-declarations\n        const tokenMetadataUpdateAuthority = isOption(extension.updateAuthority)\n          ? extension.updateAuthority\n          : wrapNullable(extension.updateAuthority);\n        if (isNone(tokenMetadataUpdateAuthority)) {\n          return [];\n        }\n        return [\n          getInitializeTokenMetadataInstruction({\n            metadata: mint,\n            updateAuthority: tokenMetadataUpdateAuthority.value,\n            mint,\n            mintAuthority: authority,\n            name: extension.name,\n            symbol: extension.symbol,\n            uri: extension.uri,\n          }),\n        ];\n      case 'TokenGroup':\n        return [\n          getInitializeTokenGroupInstruction({\n            group: mint,\n            updateAuthority: isOption(extension.updateAuthority)\n              ? extension.updateAuthority\n              : wrapNullable(extension.updateAuthority),\n            mint,\n            mintAuthority: authority,\n            maxSize: extension.maxSize,\n          }),\n        ];\n      default:\n        return [];\n    }\n  });\n}\n\n/**\n * Given a token address, its owner and a list of token extensions, returns a list\n * of instructions that MUST be run _after_ the `initializeAccount` instruction\n * to properly initialize the given extensions on the token account.\n */\nexport function getPostInitializeInstructionsForTokenExtensions(\n  token: Address,\n  owner: TransactionSigner | Address,\n  extensions: ExtensionArgs[],\n  multiSigners?: TransactionSigner[]\n): IInstruction[] {\n  return extensions.flatMap((extension) => {\n    switch (extension.__kind) {\n      case 'MemoTransfer':\n        return [\n          extension.requireIncomingTransferMemos\n            ? getEnableMemoTransfersInstruction({ owner, token, multiSigners })\n            : getDisableMemoTransfersInstruction({\n                owner,\n                token,\n                multiSigners,\n              }),\n        ];\n      case 'CpiGuard':\n        return [\n          extension.lockCpi\n            ? getEnableCpiGuardInstruction({ owner, token, multiSigners })\n            : getDisableCpiGuardInstruction({\n                owner,\n                token,\n                multiSigners,\n              }),\n        ];\n      default:\n        return [];\n    }\n  });\n}\n","import {\n  getArrayEncoder,\n  getConstantEncoder,\n  getHiddenPrefixEncoder,\n  getU8Encoder,\n} from '@solana/kit';\nimport { ExtensionArgs, getExtensionEncoder } from './generated';\n\nconst TOKEN_BASE_SIZE = 165;\n\nexport function getTokenSize(extensions?: ExtensionArgs[]): number {\n  if (extensions == null) return TOKEN_BASE_SIZE;\n  const tvlEncoder = getHiddenPrefixEncoder(\n    getArrayEncoder(getExtensionEncoder(), { size: 'remainder' }),\n    [getConstantEncoder(getU8Encoder().encode(2))]\n  );\n  return TOKEN_BASE_SIZE + tvlEncoder.encode(extensions).length;\n}\n","import {\n  getArrayEncoder,\n  getConstantEncoder,\n  getHiddenPrefixEncoder,\n  getU8Encoder,\n  padLeftEncoder,\n} from '@solana/kit';\nimport { ExtensionArgs, getExtensionEncoder } from './generated';\n\nconst MINT_BASE_SIZE = 82;\n\nexport function getMintSize(extensions?: ExtensionArgs[]): number {\n  if (extensions == null) return MINT_BASE_SIZE;\n  const tvlEncoder = getHiddenPrefixEncoder(\n    getArrayEncoder(getExtensionEncoder(), { size: 'remainder' }),\n    [getConstantEncoder(padLeftEncoder(getU8Encoder(), 83).encode(1))]\n  );\n  return MINT_BASE_SIZE + tvlEncoder.encode(extensions).length;\n}\n"]}
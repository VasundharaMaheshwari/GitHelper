{"version":3,"sources":["../../src/generated/programs/computeBudget.ts","../../src/generated/instructions/requestHeapFrame.ts","../../src/generated/instructions/requestUnits.ts","../../src/generated/instructions/setComputeUnitLimit.ts","../../src/generated/instructions/setComputeUnitPrice.ts","../../src/generated/instructions/setLoadedAccountsDataSizeLimit.ts"],"names":["ComputeBudgetInstruction","getU8Encoder","transformEncoder","getStructEncoder","getU32Encoder","getStructDecoder","getU8Decoder","getU32Decoder","combineCodec"],"mappings":"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","file":"index.mjs","sourcesContent":["/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU8Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedRequestHeapFrameInstruction,\n  type ParsedRequestUnitsInstruction,\n  type ParsedSetComputeUnitLimitInstruction,\n  type ParsedSetComputeUnitPriceInstruction,\n  type ParsedSetLoadedAccountsDataSizeLimitInstruction,\n} from '../instructions';\n\nexport const COMPUTE_BUDGET_PROGRAM_ADDRESS =\n  'ComputeBudget111111111111111111111111111111' as Address<'ComputeBudget111111111111111111111111111111'>;\n\nexport enum ComputeBudgetInstruction {\n  RequestUnits,\n  RequestHeapFrame,\n  SetComputeUnitLimit,\n  SetComputeUnitPrice,\n  SetLoadedAccountsDataSizeLimit,\n}\n\nexport function identifyComputeBudgetInstruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): ComputeBudgetInstruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU8Encoder().encode(0), 0)) {\n    return ComputeBudgetInstruction.RequestUnits;\n  }\n  if (containsBytes(data, getU8Encoder().encode(1), 0)) {\n    return ComputeBudgetInstruction.RequestHeapFrame;\n  }\n  if (containsBytes(data, getU8Encoder().encode(2), 0)) {\n    return ComputeBudgetInstruction.SetComputeUnitLimit;\n  }\n  if (containsBytes(data, getU8Encoder().encode(3), 0)) {\n    return ComputeBudgetInstruction.SetComputeUnitPrice;\n  }\n  if (containsBytes(data, getU8Encoder().encode(4), 0)) {\n    return ComputeBudgetInstruction.SetLoadedAccountsDataSizeLimit;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a computeBudget instruction.'\n  );\n}\n\nexport type ParsedComputeBudgetInstruction<\n  TProgram extends string = 'ComputeBudget111111111111111111111111111111',\n> =\n  | ({\n      instructionType: ComputeBudgetInstruction.RequestUnits;\n    } & ParsedRequestUnitsInstruction<TProgram>)\n  | ({\n      instructionType: ComputeBudgetInstruction.RequestHeapFrame;\n    } & ParsedRequestHeapFrameInstruction<TProgram>)\n  | ({\n      instructionType: ComputeBudgetInstruction.SetComputeUnitLimit;\n    } & ParsedSetComputeUnitLimitInstruction<TProgram>)\n  | ({\n      instructionType: ComputeBudgetInstruction.SetComputeUnitPrice;\n    } & ParsedSetComputeUnitPriceInstruction<TProgram>)\n  | ({\n      instructionType: ComputeBudgetInstruction.SetLoadedAccountsDataSizeLimit;\n    } & ParsedSetLoadedAccountsDataSizeLimitInstruction<TProgram>);\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n} from '@solana/kit';\nimport { COMPUTE_BUDGET_PROGRAM_ADDRESS } from '../programs';\n\nexport const REQUEST_HEAP_FRAME_DISCRIMINATOR = 1;\n\nexport function getRequestHeapFrameDiscriminatorBytes() {\n  return getU8Encoder().encode(REQUEST_HEAP_FRAME_DISCRIMINATOR);\n}\n\nexport type RequestHeapFrameInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<TRemainingAccounts>;\n\nexport type RequestHeapFrameInstructionData = {\n  discriminator: number;\n  /**\n   * Requested transaction-wide program heap size in bytes.\n   * Must be multiple of 1024. Applies to each program, including CPIs.\n   */\n  bytes: number;\n};\n\nexport type RequestHeapFrameInstructionDataArgs = {\n  /**\n   * Requested transaction-wide program heap size in bytes.\n   * Must be multiple of 1024. Applies to each program, including CPIs.\n   */\n  bytes: number;\n};\n\nexport function getRequestHeapFrameInstructionDataEncoder(): Encoder<RequestHeapFrameInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['bytes', getU32Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: REQUEST_HEAP_FRAME_DISCRIMINATOR })\n  );\n}\n\nexport function getRequestHeapFrameInstructionDataDecoder(): Decoder<RequestHeapFrameInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['bytes', getU32Decoder()],\n  ]);\n}\n\nexport function getRequestHeapFrameInstructionDataCodec(): Codec<\n  RequestHeapFrameInstructionDataArgs,\n  RequestHeapFrameInstructionData\n> {\n  return combineCodec(\n    getRequestHeapFrameInstructionDataEncoder(),\n    getRequestHeapFrameInstructionDataDecoder()\n  );\n}\n\nexport type RequestHeapFrameInput = {\n  bytes: RequestHeapFrameInstructionDataArgs['bytes'];\n};\n\nexport function getRequestHeapFrameInstruction<\n  TProgramAddress extends Address = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n>(\n  input: RequestHeapFrameInput,\n  config?: { programAddress?: TProgramAddress }\n): RequestHeapFrameInstruction<TProgramAddress> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? COMPUTE_BUDGET_PROGRAM_ADDRESS;\n\n  // Original args.\n  const args = { ...input };\n\n  const instruction = {\n    programAddress,\n    data: getRequestHeapFrameInstructionDataEncoder().encode(\n      args as RequestHeapFrameInstructionDataArgs\n    ),\n  } as RequestHeapFrameInstruction<TProgramAddress>;\n\n  return instruction;\n}\n\nexport type ParsedRequestHeapFrameInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n> = {\n  programAddress: Address<TProgram>;\n  data: RequestHeapFrameInstructionData;\n};\n\nexport function parseRequestHeapFrameInstruction<TProgram extends string>(\n  instruction: IInstruction<TProgram> & IInstructionWithData<Uint8Array>\n): ParsedRequestHeapFrameInstruction<TProgram> {\n  return {\n    programAddress: instruction.programAddress,\n    data: getRequestHeapFrameInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n} from '@solana/kit';\nimport { COMPUTE_BUDGET_PROGRAM_ADDRESS } from '../programs';\n\nexport const REQUEST_UNITS_DISCRIMINATOR = 0;\n\nexport function getRequestUnitsDiscriminatorBytes() {\n  return getU8Encoder().encode(REQUEST_UNITS_DISCRIMINATOR);\n}\n\nexport type RequestUnitsInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<TRemainingAccounts>;\n\nexport type RequestUnitsInstructionData = {\n  discriminator: number;\n  /** Units to request for transaction-wide compute. */\n  units: number;\n  /** Prioritization fee lamports. */\n  additionalFee: number;\n};\n\nexport type RequestUnitsInstructionDataArgs = {\n  /** Units to request for transaction-wide compute. */\n  units: number;\n  /** Prioritization fee lamports. */\n  additionalFee: number;\n};\n\nexport function getRequestUnitsInstructionDataEncoder(): Encoder<RequestUnitsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['units', getU32Encoder()],\n      ['additionalFee', getU32Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: REQUEST_UNITS_DISCRIMINATOR })\n  );\n}\n\nexport function getRequestUnitsInstructionDataDecoder(): Decoder<RequestUnitsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['units', getU32Decoder()],\n    ['additionalFee', getU32Decoder()],\n  ]);\n}\n\nexport function getRequestUnitsInstructionDataCodec(): Codec<\n  RequestUnitsInstructionDataArgs,\n  RequestUnitsInstructionData\n> {\n  return combineCodec(\n    getRequestUnitsInstructionDataEncoder(),\n    getRequestUnitsInstructionDataDecoder()\n  );\n}\n\nexport type RequestUnitsInput = {\n  units: RequestUnitsInstructionDataArgs['units'];\n  additionalFee: RequestUnitsInstructionDataArgs['additionalFee'];\n};\n\nexport function getRequestUnitsInstruction<\n  TProgramAddress extends Address = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n>(\n  input: RequestUnitsInput,\n  config?: { programAddress?: TProgramAddress }\n): RequestUnitsInstruction<TProgramAddress> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? COMPUTE_BUDGET_PROGRAM_ADDRESS;\n\n  // Original args.\n  const args = { ...input };\n\n  const instruction = {\n    programAddress,\n    data: getRequestUnitsInstructionDataEncoder().encode(\n      args as RequestUnitsInstructionDataArgs\n    ),\n  } as RequestUnitsInstruction<TProgramAddress>;\n\n  return instruction;\n}\n\nexport type ParsedRequestUnitsInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n> = {\n  programAddress: Address<TProgram>;\n  data: RequestUnitsInstructionData;\n};\n\nexport function parseRequestUnitsInstruction<TProgram extends string>(\n  instruction: IInstruction<TProgram> & IInstructionWithData<Uint8Array>\n): ParsedRequestUnitsInstruction<TProgram> {\n  return {\n    programAddress: instruction.programAddress,\n    data: getRequestUnitsInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n} from '@solana/kit';\nimport { COMPUTE_BUDGET_PROGRAM_ADDRESS } from '../programs';\n\nexport const SET_COMPUTE_UNIT_LIMIT_DISCRIMINATOR = 2;\n\nexport function getSetComputeUnitLimitDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_COMPUTE_UNIT_LIMIT_DISCRIMINATOR);\n}\n\nexport type SetComputeUnitLimitInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<TRemainingAccounts>;\n\nexport type SetComputeUnitLimitInstructionData = {\n  discriminator: number;\n  /** Transaction-wide compute unit limit. */\n  units: number;\n};\n\nexport type SetComputeUnitLimitInstructionDataArgs = {\n  /** Transaction-wide compute unit limit. */\n  units: number;\n};\n\nexport function getSetComputeUnitLimitInstructionDataEncoder(): Encoder<SetComputeUnitLimitInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['units', getU32Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_COMPUTE_UNIT_LIMIT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetComputeUnitLimitInstructionDataDecoder(): Decoder<SetComputeUnitLimitInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['units', getU32Decoder()],\n  ]);\n}\n\nexport function getSetComputeUnitLimitInstructionDataCodec(): Codec<\n  SetComputeUnitLimitInstructionDataArgs,\n  SetComputeUnitLimitInstructionData\n> {\n  return combineCodec(\n    getSetComputeUnitLimitInstructionDataEncoder(),\n    getSetComputeUnitLimitInstructionDataDecoder()\n  );\n}\n\nexport type SetComputeUnitLimitInput = {\n  units: SetComputeUnitLimitInstructionDataArgs['units'];\n};\n\nexport function getSetComputeUnitLimitInstruction<\n  TProgramAddress extends Address = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n>(\n  input: SetComputeUnitLimitInput,\n  config?: { programAddress?: TProgramAddress }\n): SetComputeUnitLimitInstruction<TProgramAddress> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? COMPUTE_BUDGET_PROGRAM_ADDRESS;\n\n  // Original args.\n  const args = { ...input };\n\n  const instruction = {\n    programAddress,\n    data: getSetComputeUnitLimitInstructionDataEncoder().encode(\n      args as SetComputeUnitLimitInstructionDataArgs\n    ),\n  } as SetComputeUnitLimitInstruction<TProgramAddress>;\n\n  return instruction;\n}\n\nexport type ParsedSetComputeUnitLimitInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n> = {\n  programAddress: Address<TProgram>;\n  data: SetComputeUnitLimitInstructionData;\n};\n\nexport function parseSetComputeUnitLimitInstruction<TProgram extends string>(\n  instruction: IInstruction<TProgram> & IInstructionWithData<Uint8Array>\n): ParsedSetComputeUnitLimitInstruction<TProgram> {\n  return {\n    programAddress: instruction.programAddress,\n    data: getSetComputeUnitLimitInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n} from '@solana/kit';\nimport { COMPUTE_BUDGET_PROGRAM_ADDRESS } from '../programs';\n\nexport const SET_COMPUTE_UNIT_PRICE_DISCRIMINATOR = 3;\n\nexport function getSetComputeUnitPriceDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_COMPUTE_UNIT_PRICE_DISCRIMINATOR);\n}\n\nexport type SetComputeUnitPriceInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<TRemainingAccounts>;\n\nexport type SetComputeUnitPriceInstructionData = {\n  discriminator: number;\n  /** Transaction compute unit price used for prioritization fees. */\n  microLamports: bigint;\n};\n\nexport type SetComputeUnitPriceInstructionDataArgs = {\n  /** Transaction compute unit price used for prioritization fees. */\n  microLamports: number | bigint;\n};\n\nexport function getSetComputeUnitPriceInstructionDataEncoder(): Encoder<SetComputeUnitPriceInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['microLamports', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_COMPUTE_UNIT_PRICE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetComputeUnitPriceInstructionDataDecoder(): Decoder<SetComputeUnitPriceInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['microLamports', getU64Decoder()],\n  ]);\n}\n\nexport function getSetComputeUnitPriceInstructionDataCodec(): Codec<\n  SetComputeUnitPriceInstructionDataArgs,\n  SetComputeUnitPriceInstructionData\n> {\n  return combineCodec(\n    getSetComputeUnitPriceInstructionDataEncoder(),\n    getSetComputeUnitPriceInstructionDataDecoder()\n  );\n}\n\nexport type SetComputeUnitPriceInput = {\n  microLamports: SetComputeUnitPriceInstructionDataArgs['microLamports'];\n};\n\nexport function getSetComputeUnitPriceInstruction<\n  TProgramAddress extends Address = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n>(\n  input: SetComputeUnitPriceInput,\n  config?: { programAddress?: TProgramAddress }\n): SetComputeUnitPriceInstruction<TProgramAddress> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? COMPUTE_BUDGET_PROGRAM_ADDRESS;\n\n  // Original args.\n  const args = { ...input };\n\n  const instruction = {\n    programAddress,\n    data: getSetComputeUnitPriceInstructionDataEncoder().encode(\n      args as SetComputeUnitPriceInstructionDataArgs\n    ),\n  } as SetComputeUnitPriceInstruction<TProgramAddress>;\n\n  return instruction;\n}\n\nexport type ParsedSetComputeUnitPriceInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n> = {\n  programAddress: Address<TProgram>;\n  data: SetComputeUnitPriceInstructionData;\n};\n\nexport function parseSetComputeUnitPriceInstruction<TProgram extends string>(\n  instruction: IInstruction<TProgram> & IInstructionWithData<Uint8Array>\n): ParsedSetComputeUnitPriceInstruction<TProgram> {\n  return {\n    programAddress: instruction.programAddress,\n    data: getSetComputeUnitPriceInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n} from '@solana/kit';\nimport { COMPUTE_BUDGET_PROGRAM_ADDRESS } from '../programs';\n\nexport const SET_LOADED_ACCOUNTS_DATA_SIZE_LIMIT_DISCRIMINATOR = 4;\n\nexport function getSetLoadedAccountsDataSizeLimitDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    SET_LOADED_ACCOUNTS_DATA_SIZE_LIMIT_DISCRIMINATOR\n  );\n}\n\nexport type SetLoadedAccountsDataSizeLimitInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<TRemainingAccounts>;\n\nexport type SetLoadedAccountsDataSizeLimitInstructionData = {\n  discriminator: number;\n  accountDataSizeLimit: number;\n};\n\nexport type SetLoadedAccountsDataSizeLimitInstructionDataArgs = {\n  accountDataSizeLimit: number;\n};\n\nexport function getSetLoadedAccountsDataSizeLimitInstructionDataEncoder(): Encoder<SetLoadedAccountsDataSizeLimitInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['accountDataSizeLimit', getU32Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_LOADED_ACCOUNTS_DATA_SIZE_LIMIT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetLoadedAccountsDataSizeLimitInstructionDataDecoder(): Decoder<SetLoadedAccountsDataSizeLimitInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['accountDataSizeLimit', getU32Decoder()],\n  ]);\n}\n\nexport function getSetLoadedAccountsDataSizeLimitInstructionDataCodec(): Codec<\n  SetLoadedAccountsDataSizeLimitInstructionDataArgs,\n  SetLoadedAccountsDataSizeLimitInstructionData\n> {\n  return combineCodec(\n    getSetLoadedAccountsDataSizeLimitInstructionDataEncoder(),\n    getSetLoadedAccountsDataSizeLimitInstructionDataDecoder()\n  );\n}\n\nexport type SetLoadedAccountsDataSizeLimitInput = {\n  accountDataSizeLimit: SetLoadedAccountsDataSizeLimitInstructionDataArgs['accountDataSizeLimit'];\n};\n\nexport function getSetLoadedAccountsDataSizeLimitInstruction<\n  TProgramAddress extends Address = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n>(\n  input: SetLoadedAccountsDataSizeLimitInput,\n  config?: { programAddress?: TProgramAddress }\n): SetLoadedAccountsDataSizeLimitInstruction<TProgramAddress> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? COMPUTE_BUDGET_PROGRAM_ADDRESS;\n\n  // Original args.\n  const args = { ...input };\n\n  const instruction = {\n    programAddress,\n    data: getSetLoadedAccountsDataSizeLimitInstructionDataEncoder().encode(\n      args as SetLoadedAccountsDataSizeLimitInstructionDataArgs\n    ),\n  } as SetLoadedAccountsDataSizeLimitInstruction<TProgramAddress>;\n\n  return instruction;\n}\n\nexport type ParsedSetLoadedAccountsDataSizeLimitInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n> = {\n  programAddress: Address<TProgram>;\n  data: SetLoadedAccountsDataSizeLimitInstructionData;\n};\n\nexport function parseSetLoadedAccountsDataSizeLimitInstruction<\n  TProgram extends string,\n>(\n  instruction: IInstruction<TProgram> & IInstructionWithData<Uint8Array>\n): ParsedSetLoadedAccountsDataSizeLimitInstruction<TProgram> {\n  return {\n    programAddress: instruction.programAddress,\n    data: getSetLoadedAccountsDataSizeLimitInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n"]}